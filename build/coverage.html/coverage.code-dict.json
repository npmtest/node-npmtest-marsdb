{"/home/travis/build/npmtest/node-npmtest-marsdb/test.js":"/* istanbul instrument in package npmtest_marsdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-marsdb/lib.npmtest_marsdb.js":"/* istanbul instrument in package npmtest_marsdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_marsdb = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_marsdb = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-marsdb/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-marsdb && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_marsdb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_marsdb\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_marsdb.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_marsdb.rollup.js'] =\n            local.assetsDict['/assets.npmtest_marsdb.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_marsdb.__dirname + '/lib.npmtest_marsdb.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/index.js":"var EventEmitter = require('./dist/AsyncEventEmitter').default;\nvar Collection = require('./dist/Collection').default;\nvar CursorObservable = require('./dist/CursorObservable').default;\nvar debounce = require('./dist/debounce').default;\nvar StorageManager = require('./dist/StorageManager').default;\nvar Random = require('./dist/Random').default;\nvar EJSON = require('./dist/EJSON').default;\nvar Base64 = require('./dist/Base64').default;\nvar PromiseQueue = require('./dist/PromiseQueue').default;\n\n\nmodule.exports = {\n  __esModule: true,\n  default: Collection,\n  Random: Random,\n  EJSON: EJSON,\n  Base64: Base64,\n  Collection: Collection,\n  CursorObservable: CursorObservable,\n  StorageManager: StorageManager,\n  EventEmitter: EventEmitter,\n  PromiseQueue: PromiseQueue,\n  debounce: debounce\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/AsyncEventEmitter.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _eventemitter = require('eventemitter3');\n\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Extension of a regular EventEmitter that provides a method\n * that returns a Promise then resolved when all listeners of the event\n * will be resolved.\n */\n/* istanbul ignore next */\n\nvar AsyncEventEmitter = function (_EventEmitter) {\n  _inherits(AsyncEventEmitter, _EventEmitter);\n\n  function AsyncEventEmitter() {\n    _classCallCheck(this, AsyncEventEmitter);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(AsyncEventEmitter).apply(this, arguments));\n  }\n\n  _createClass(AsyncEventEmitter, [{\n    key: 'emitAsync',\n\n    /**\n     * Emit an event and return a Promise that will be resolved\n     * when all listeren's Promises will be resolved.\n     * @param  {String} event\n     * @return {Promise}\n     */\n    value: function emitAsync(event, a1, a2, a3, a4, a5) {\n      var prefix = _eventemitter2.default.prefixed;\n      var evt = prefix ? prefix + event : event;\n\n      if (!this._events || !this._events[evt]) {\n        return Promise.resolve();\n      }\n\n      var i = undefined;\n      var listeners = this._events[evt];\n      var len = arguments.length;\n      var args = undefined;\n\n      if ('function' === typeof listeners.fn) {\n        if (listeners.once) {\n          this.removeListener(event, listeners.fn, undefined, true);\n        }\n\n        switch (len) {\n          case 1:\n            return Promise.resolve(listeners.fn.call(listeners.context));\n          case 2:\n            return Promise.resolve(listeners.fn.call(listeners.context, a1));\n          case 3:\n            return Promise.resolve(listeners.fn.call(listeners.context, a1, a2));\n          case 4:\n            return Promise.resolve(listeners.fn.call(listeners.context, a1, a2, a3));\n          case 5:\n            return Promise.resolve(listeners.fn.call(listeners.context, a1, a2, a3, a4));\n          case 6:\n            return Promise.resolve(listeners.fn.call(listeners.context, a1, a2, a3, a4, a5));\n        }\n\n        for (i = 1, args = new Array(len - 1); i < len; i++) {\n          args[i - 1] = arguments[i];\n        }\n\n        return Promise.resolve(listeners.fn.apply(listeners.context, args));\n      } else {\n        var promises = [];\n        var length = listeners.length;\n        var j = undefined;\n\n        for (i = 0; i < length; i++) {\n          if (listeners[i].once) {\n            this.removeListener(event, listeners[i].fn, undefined, true);\n          }\n\n          switch (len) {\n            case 1:\n              promises.push(Promise.resolve(listeners[i].fn.call(listeners[i].context)));break;\n            case 2:\n              promises.push(Promise.resolve(listeners[i].fn.call(listeners[i].context, a1)));break;\n            case 3:\n              promises.push(Promise.resolve(listeners[i].fn.call(listeners[i].context, a1, a2)));break;\n            default:\n              if (!args) {\n                for (j = 1, args = new Array(len - 1); j < len; j++) {\n                  args[j - 1] = arguments[j];\n                }\n              }\n              promises.push(Promise.resolve(listeners[i].fn.apply(listeners[i].context, args)));\n          }\n        }\n\n        return Promise.all(promises);\n      }\n    }\n  }]);\n\n  return AsyncEventEmitter;\n}(_eventemitter2.default);\n\nexports.default = AsyncEventEmitter;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/Collection.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = undefined;\nexports._resetStartup = _resetStartup;\nexports._warnIfAlreadyStarted = _warnIfAlreadyStarted;\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _AsyncEventEmitter = require('./AsyncEventEmitter');\n\nvar _AsyncEventEmitter2 = _interopRequireDefault(_AsyncEventEmitter);\n\nvar _IndexManager = require('./IndexManager');\n\nvar _IndexManager2 = _interopRequireDefault(_IndexManager);\n\nvar _StorageManager = require('./StorageManager');\n\nvar _StorageManager2 = _interopRequireDefault(_StorageManager);\n\nvar _CollectionDelegate = require('./CollectionDelegate');\n\nvar _CollectionDelegate2 = _interopRequireDefault(_CollectionDelegate);\n\nvar _CursorObservable = require('./CursorObservable');\n\nvar _CursorObservable2 = _interopRequireDefault(_CursorObservable);\n\nvar _ShortIdGenerator = require('./ShortIdGenerator');\n\nvar _ShortIdGenerator2 = _interopRequireDefault(_ShortIdGenerator);\n\nvar _EJSON = require('./EJSON');\n\nvar _EJSON2 = _interopRequireDefault(_EJSON);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Defaults\nvar _defaultCursor = _CursorObservable2.default;\nvar _defaultDelegate = _CollectionDelegate2.default;\nvar _defaultStorageManager = _StorageManager2.default;\nvar _defaultIndexManager = _IndexManager2.default;\nvar _defaultIdGenerator = _ShortIdGenerator2.default;\n\n// Startup all init dependent functions on\n// the second execution cycle\nvar _startedUp = false;\nvar _startUpQueue = [];\nvar _startUpId = 0;\n\n// Internals\nfunction _resetStartup() {\n  var waitMs = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];\n\n  _startUpId += 1;\n  _startUpQueue = [];\n  _startedUp = false;\n  var currStartId = _startUpId;\n  setTimeout(function () {\n    if (currStartId === _startUpId) {\n      _startedUp = true;\n      (0, _forEach2.default)(_startUpQueue, function (fn) {\n        return fn();\n      });\n      _startUpQueue = [];\n    }\n  }, waitMs);\n}\n\nfunction _warnIfAlreadyStarted() {\n  if (_startedUp) {\n    console.warn('You are trying to change some default of the Collection,' + 'but all collections is already initialized. It may be happened ' + 'because you are trying to configure Collection not at first ' + 'execution cycle of main script. Please consider to move all ' + 'configuration to first execution cycle.');\n  }\n}\n\n// Initiate startup\n_resetStartup();\n\n/**\n * Core class of the database.\n * It delegates almost all it's methods to managers\n * and emits events for live queries and other cuctomisation.\n */\n\nvar Collection = exports.Collection = function (_EventEmitter) {\n  _inherits(Collection, _EventEmitter);\n\n  function Collection(name) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Collection);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Collection).call(this));\n\n    _this.options = options;\n    _this._modelName = name;\n\n    // Shorthand for defining in-memory collection\n    if (options.inMemory) {\n      options.cursorClass = options.cursorClass || _CursorObservable2.default;\n      options.delegate = options.delegate || _CollectionDelegate2.default;\n      options.storageManager = options.storageManager || _StorageManager2.default;\n      options.indexManager = options.indexManager || _IndexManager2.default;\n      options.idGenerator = options.idGenerator || _ShortIdGenerator2.default;\n    }\n\n    // Initialize collection only after configuration done\n    Collection.startup(function () {\n      return _this._lazyInitCollection();\n    });\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: 'create',\n\n    /**\n     * Factory for creating an object of the model\n     * @param  {String|Object} raw\n     * @return {Object}\n     */\n    value: function create(raw) {\n      return _checkTypes2.default.string(raw) ? _EJSON2.default.parse(raw) : raw;\n    }\n\n    /**\n     * Insert a document into the model and\n     * emit `synd:insert` event (if not quiet).\n     * @param  {Object} doc\n     * @param  {Boolean} quiet\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'insert',\n    value: function insert(doc) {\n      var _this2 = this;\n\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      this._lazyInitCollection();\n      var randomId = this.idGenerator(this.modelName);\n      doc = this.create(doc);\n      doc._id = doc._id || randomId.value;\n\n      this.emit('beforeInsert', doc, randomId);\n      if (!options.quiet) {\n        this.emit('sync:insert', doc, randomId);\n      }\n      return this.delegate.insert(doc, options, randomId).then(function (docId) {\n        _this2.emit('insert', doc, null, randomId);\n        return docId;\n      });\n    }\n\n    /**\n     * Just a sugar for mulpitle inserts. Wrap all inserts\n     * with a single Promise and return it.\n     * @param  {Array} docs\n     * @param  {Object} options\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'insertAll',\n    value: function insertAll(docs) {\n      var _this3 = this;\n\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      return Promise.all((0, _map3.default)(docs, function (d) {\n        return _this3.insert(d, options);\n      }));\n    }\n\n    /**\n     * Remove an object (or objects with options.multi)\n     * from the model.\n     * @param  {Object} query\n     * @param  {Object} options\n     * @param  {Boolean} quiet\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(query) {\n      var _this4 = this;\n\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      this._lazyInitCollection();\n\n      this.emit('beforeRemove', query, options);\n      if (!options.quiet) {\n        this.emit('sync:remove', query, options);\n      }\n      return this.delegate.remove(query, options).then(function (removedDocs) {\n        (0, _forEach2.default)(removedDocs, function (d) {\n          return _this4.emit('remove', null, d);\n        });\n        return removedDocs;\n      });\n    }\n\n    /**\n     * Remove an object (or objects with options.multi)\n     * from the model.\n     * NOTE: `upsert` is not supported, only `multi`\n     * @param  {Object} query\n     * @param  {Object} options\n     * @param  {Boolean} quiet\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'update',\n    value: function update(query, modifier) {\n      var _this5 = this;\n\n      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n      this._lazyInitCollection();\n\n      this.emit('beforeUpdate', query, modifier, options);\n      if (!options.quiet) {\n        this.emit('sync:update', query, modifier, options);\n      }\n      return this.delegate.update(query, modifier, options).then(function (res) {\n        (0, _forEach2.default)(res.updated, function (d, i) {\n          _this5.emit('update', d, res.original[i]);\n        });\n        return res;\n      });\n    }\n\n    /**\n     * Make a cursor with given query and return.\n     * By default all documents clonned before passed\n     * to pipeline functions. By setting `options.noClone`\n     * to `true` clonning may be disabled (for your own risk)\n     * @param  {Object} query\n     * @param  {Number} options.noClone\n     * @return {CursorObservable}\n     */\n\n  }, {\n    key: 'find',\n    value: function find(query) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      this._lazyInitCollection();\n      return this.delegate.find(query, options);\n    }\n\n    /**\n     * Finds one object by given query and sort object.\n     * Return a promise that resolved with a document object\n     * or with undefined if no object found.\n     * @param  {Object} query\n     * @param  {Object} sortObj\n     * @return {CursorObservable}\n     */\n\n  }, {\n    key: 'findOne',\n    value: function findOne(query) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      this._lazyInitCollection();\n      return this.delegate.findOne(query, options);\n    }\n\n    /**\n     * Returns a number of matched by query objects. It's\n     * based on `ids` function and uses only indexes.\n     * In this case it's much more faster then doing\n     * `find().length`, because it does not going to the\n     * storage.\n     * @param  {Object} query\n     * @return {CursorObservable}\n     */\n\n  }, {\n    key: 'count',\n    value: function count(query) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      this._lazyInitCollection();\n      return this.delegate.count(query, options);\n    }\n\n    /**\n     * Return a list of ids by given query. Uses only\n     * indexes.\n     * @param  {Object} query\n     * @return {CursorObservable}\n     */\n\n  }, {\n    key: 'ids',\n    value: function ids(query) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      this._lazyInitCollection();\n      return this.delegate.ids(query, options);\n    }\n\n    /**\n     * Initialize collection managers by stored options. It is\n     * used for solving execution order problem of Collection\n     * configuration functions.\n     */\n\n  }, {\n    key: '_lazyInitCollection',\n    value: function _lazyInitCollection() {\n      if (!this._initialized) {\n        this._initialized = true;\n        var options = this.options;\n        var storageManagerClass = options.storageManager || _defaultStorageManager;\n        var delegateClass = options.delegate || _defaultDelegate;\n        var indexManagerClass = options.indexManager || _defaultIndexManager;\n        this.idGenerator = options.idGenerator || _defaultIdGenerator;\n        this.cursorClass = options.cursorClass || _defaultCursor;\n        this.indexManager = new indexManagerClass(this, options);\n        this.storageManager = new storageManagerClass(this, options);\n        this.delegate = new delegateClass(this, options);\n      }\n    }\n\n    /**\n     * Wihout arguments it returns current default storage manager.\n     * If arguments provided, then first argument will be set as default\n     * storage manager and all collections, who uses default storage manager,\n     * will be upgraded to a new strage manager.\n     * @return {undefined|Class}\n     */\n\n  }, {\n    key: 'modelName',\n    get: function get() {\n      return this._modelName;\n    }\n  }, {\n    key: 'indexes',\n    get: function get() {\n      this._lazyInitCollection();\n      return this.indexManager.indexes;\n    }\n  }, {\n    key: 'storage',\n    get: function get() {\n      this._lazyInitCollection();\n      return this.storageManager;\n    }\n  }], [{\n    key: 'defaultCursor',\n    value: function defaultCursor() {\n      if (arguments.length > 0) {\n        _warnIfAlreadyStarted();\n        _defaultCursor = arguments[0];\n      } else {\n        return _defaultCursor;\n      }\n    }\n\n    /**\n     * Wihout arguments it returns current default storage manager.\n     * If arguments provided, then first argument will be set as default\n     * storage manager and all collections, who uses default storage manager,\n     * will be upgraded to a new strage manager.\n     * @return {undefined|Class}\n     */\n\n  }, {\n    key: 'defaultStorageManager',\n    value: function defaultStorageManager() {\n      if (arguments.length > 0) {\n        _warnIfAlreadyStarted();\n        _defaultStorageManager = arguments[0];\n      } else {\n        return _defaultStorageManager;\n      }\n    }\n\n    /**\n     * Wihout arguments it returns current default id generator.\n     * If arguments provided, then first argument will be set as default\n     * id generator and all collections, who uses default id generator,\n     * will be upgraded to a new id generator.\n     * @return {undefined|Class}\n     */\n\n  }, {\n    key: 'defaultIdGenerator',\n    value: function defaultIdGenerator() {\n      if (arguments.length > 0) {\n        _warnIfAlreadyStarted();\n        _defaultIdGenerator = arguments[0];\n      } else {\n        return _defaultIdGenerator;\n      }\n    }\n\n    /**\n     * Wihout arguments it returns current default delegate class.\n     * If arguments provided, then first argument will be set as default\n     * delegate and all collections, who uses default delegate,\n     * will be upgraded to a new delegate.\n     * @return {undefined|Class}\n     */\n\n  }, {\n    key: 'defaultDelegate',\n    value: function defaultDelegate() {\n      if (arguments.length > 0) {\n        _warnIfAlreadyStarted();\n        _defaultDelegate = arguments[0];\n      } else {\n        return _defaultDelegate;\n      }\n    }\n\n    /**\n     * Wihout arguments it returns current default index manager class.\n     * If arguments provided, then first argument will be set as default\n     * index manager and all collections, who uses default index manager,\n     * will be upgraded to a new index manager.\n     * @return {undefined|Class}\n     */\n\n  }, {\n    key: 'defaultIndexManager',\n    value: function defaultIndexManager() {\n      if (arguments.length > 0) {\n        _warnIfAlreadyStarted();\n        _defaultIndexManager = arguments[0];\n      } else {\n        return _defaultIndexManager;\n      }\n    }\n\n    /**\n     * Execute some function after current execution cycle. For using fully\n     * configured collection.\n     * @param  {Function} fn\n     */\n\n  }, {\n    key: 'startup',\n    value: function startup(fn) {\n      if (_startedUp) {\n        fn();\n      } else {\n        _startUpQueue.push(fn);\n      }\n    }\n  }]);\n\n  return Collection;\n}(_AsyncEventEmitter2.default);\n\nexports.default = Collection;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/IndexManager.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexManager = undefined;\n\nvar _bind2 = require('fast.js/function/bind');\n\nvar _bind3 = _interopRequireDefault(_bind2);\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _PromiseQueue = require('./PromiseQueue');\n\nvar _PromiseQueue2 = _interopRequireDefault(_PromiseQueue);\n\nvar _CollectionIndex = require('./CollectionIndex');\n\nvar _CollectionIndex2 = _interopRequireDefault(_CollectionIndex);\n\nvar _DocumentRetriver = require('./DocumentRetriver');\n\nvar _DocumentRetriver2 = _interopRequireDefault(_DocumentRetriver);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Manager for controlling a list of indexes\n * for some model. Building indexes is promise\n * based.\n * By default it creates an index for `_id` field.\n */\n/* istanbul ignore next */\n\nvar IndexManager = exports.IndexManager = function () {\n  function IndexManager(db) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, IndexManager);\n\n    this.db = db;\n    this.indexes = {};\n    this._queue = new _PromiseQueue2.default(options.concurrency || 2);\n\n    // By default ensure index by _id field\n    this.ensureIndex({\n      fieldName: '_id',\n      unique: true\n    });\n  }\n\n  /**\n   * Check index existance for given `options.fieldName` and\n   * if index not exists it creates new one.\n   * Always return a promise that resolved only when\n   * index succesfully created, built and ready for working with.\n   * If `options.forceRebuild` provided and equals to true then\n   * existing index will be rebuilt, otherwise existing index\n   * don't touched.\n   *\n   * @param  {Object} options.fieldName     name of the field for indexing\n   * @param  {Object} options.forceRebuild  rebuild index if it exists\n   * @return {Promise}\n   */\n\n  _createClass(IndexManager, [{\n    key: 'ensureIndex',\n    value: function ensureIndex(options) {\n      (0, _invariant2.default)(options && options.fieldName, 'You must specify a fieldName in options object');\n\n      var key = options.fieldName;\n      if (!this.indexes[key]) {\n        this.indexes[key] = new _CollectionIndex2.default(options);\n        return this.buildIndex(key);\n      } else if (this.indexes[key].buildPromise) {\n        return this.indexes[key].buildPromise;\n      } else if (options && options.forceRebuild) {\n        return this.buildIndex(key);\n      } else {\n        return Promise.resolve();\n      }\n    }\n\n    /**\n     * Buld an existing index (ensured) and return a\n     * promise that will be resolved only when index successfully\n     * built for all documents in the storage.\n     * @param  {String} key\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'buildIndex',\n    value: function buildIndex(key) {\n      var _this = this;\n\n      (0, _invariant2.default)(this.indexes[key], 'Index with key `%s` does not ensured yet', key);\n\n      var cleanup = function cleanup() {\n        return _this.indexes[key].buildPromise = null;\n      };\n      var buildPromise = this._queue.add((0, _bind3.default)(this._doBuildIndex, this, key)).then(cleanup, cleanup);\n\n      this.indexes[key].buildPromise = buildPromise;\n      return buildPromise;\n    }\n\n    /**\n     * Schedule a task for each index in the\n     * manager. Return promise that will be resolved\n     * when all indexes is successfully built.\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'buildAllIndexes',\n    value: function buildAllIndexes() {\n      var _this2 = this;\n\n      return Promise.all((0, _map3.default)(this.indexes, function (v, k) {\n        return _this2.ensureIndex({\n          fieldName: k,\n          forceRebuild: true\n        });\n      }));\n    }\n\n    /**\n     * Remove an index\n     * @param  {String} key\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'removeIndex',\n    value: function removeIndex(key) {\n      var _this3 = this;\n\n      return this._queue.add(function () {\n        delete _this3.indexes[key];\n      });\n    }\n\n    /**\n     * Add a document to all indexes\n     * @param  {Object} doc\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'indexDocument',\n    value: function indexDocument(doc) {\n      var _this4 = this;\n\n      return this._queue.add(function () {\n        var keys = (0, _keys3.default)(_this4.indexes);\n        var failingIndex = null;\n        try {\n          (0, _forEach2.default)(keys, function (k, i) {\n            failingIndex = i;\n            _this4.indexes[k].insert(doc);\n          });\n        } catch (e) {\n          (0, _forEach2.default)(keys.slice(0, failingIndex), function (k) {\n            _this4.indexes[k].remove(doc);\n          });\n          throw e;\n        }\n      });\n    }\n\n    /**\n     * Update all indexes with new version of\n     * the document\n     * @param  {Object} oldDoc\n     * @param  {Object} newDoc\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'reindexDocument',\n    value: function reindexDocument(oldDoc, newDoc) {\n      var _this5 = this;\n\n      return this._queue.add(function () {\n        var keys = (0, _keys3.default)(_this5.indexes);\n        var failingIndex = null;\n        try {\n          (0, _forEach2.default)(keys, function (k, i) {\n            failingIndex = i;\n            _this5.indexes[k].update(oldDoc, newDoc);\n          });\n        } catch (e) {\n          (0, _forEach2.default)(keys.slice(0, failingIndex), function (k) {\n            _this5.indexes[k].revertUpdate(oldDoc, newDoc);\n          });\n          throw e;\n        }\n      });\n    }\n\n    /**\n     * Remove document from all indexes\n     * @param  {Object} doc\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'deindexDocument',\n    value: function deindexDocument(doc) {\n      var _this6 = this;\n\n      return this._queue.add(function () {\n        var keys = (0, _keys3.default)(_this6.indexes);\n        (0, _forEach2.default)(keys, function (k) {\n          _this6.indexes[k].remove(doc);\n        });\n      });\n    }\n\n    /**\n     * Build an existing index with reseting first\n     * @param  {String} key\n     * @return {Promise}\n     */\n\n  }, {\n    key: '_doBuildIndex',\n    value: function _doBuildIndex(key) {\n      // Get and reset index\n      var index = this.indexes[key];\n      index.reset();\n\n      // Loop through all doucments in the storage\n      var errors = [];\n      return new _DocumentRetriver2.default(this.db).retriveAll().then(function (docs) {\n        (0, _forEach2.default)(docs, function (doc) {\n          try {\n            index.insert(doc);\n          } catch (e) {\n            errors.push([e, doc]);\n          }\n        });\n\n        if (errors.length > 0) {\n          throw new Error('Index build failed with errors: ', errors);\n        }\n      });\n    }\n  }]);\n\n  return IndexManager;\n}();\n\nexports.default = IndexManager;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/PromiseQueue.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _try2 = require('fast.js/function/try');\n\nvar _try3 = _interopRequireDefault(_try2);\n\nvar _doubleEndedQueue = require('double-ended-queue');\n\nvar _doubleEndedQueue2 = _interopRequireDefault(_doubleEndedQueue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * It limits concurrently executed promises\n *\n * @param {Number} [maxPendingPromises=Infinity] max number of concurrently executed promises\n * @param {Number} [maxQueuedPromises=Infinity]  max number of queued promises\n * @constructor\n */\n\nvar PromiseQueue = function () {\n  function PromiseQueue() {\n    var maxPendingPromises = arguments.length <= 0 || arguments[0] === undefined ? Infinity : arguments[0];\n    var maxQueuedPromises = arguments.length <= 1 || arguments[1] === undefined ? Infinity : arguments[1];\n\n    _classCallCheck(this, PromiseQueue);\n\n    this.pendingPromises = 0;\n    this.maxPendingPromises = maxPendingPromises;\n    this.maxQueuedPromises = maxQueuedPromises;\n    this.queue = new _doubleEndedQueue2.default();\n    this.length = 0;\n  }\n\n  /**\n   * Pause queue processing\n   */\n\n  _createClass(PromiseQueue, [{\n    key: 'pause',\n    value: function pause() {\n      this._paused = true;\n    }\n\n    /**\n     * Resume queue processing\n     */\n\n  }, {\n    key: 'unpause',\n    value: function unpause() {\n      this._paused = false;\n      this._dequeue();\n    }\n\n    /**\n     * Adds new promise generator in the queue\n     * @param {Function} promiseGenerator\n     */\n\n  }, {\n    key: 'add',\n    value: function add(promiseGenerator) {\n      var _this = this;\n\n      var unshift = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      return new Promise(function (resolve, reject) {\n        if (_this.length >= _this.maxQueuedPromises) {\n          reject(new Error('Queue limit reached'));\n        } else {\n          var queueItem = {\n            promiseGenerator: promiseGenerator,\n            resolve: resolve,\n            reject: reject\n          };\n\n          if (!unshift) {\n            _this.queue.push(queueItem);\n          } else {\n            _this.queue.unshift(queueItem);\n          }\n\n          _this.length += 1;\n          _this._dequeue();\n        }\n      });\n    }\n\n    /**\n     * Internal queue processor. Starts processing of\n     * the next queued function\n     * @return {Boolean}\n     */\n\n  }, {\n    key: '_dequeue',\n    value: function _dequeue() {\n      var _this2 = this;\n\n      if (this._paused || this.pendingPromises >= this.maxPendingPromises) {\n        return false;\n      }\n\n      var item = this.queue.shift();\n      if (!item) {\n        return false;\n      }\n\n      var result = (0, _try3.default)(function () {\n        _this2.pendingPromises++;\n        return Promise.resolve().then(function () {\n          return item.promiseGenerator();\n        }).then(function (value) {\n          _this2.length--;\n          _this2.pendingPromises--;\n          item.resolve(value);\n          _this2._dequeue();\n        }, function (err) {\n          _this2.length--;\n          _this2.pendingPromises--;\n          item.reject(err);\n          _this2._dequeue();\n        });\n      });\n\n      if (result instanceof Error) {\n        this.length--;\n        this.pendingPromises--;\n        item.reject(result);\n        this._dequeue();\n      }\n\n      return true;\n    }\n  }]);\n\n  return PromiseQueue;\n}();\n\nexports.default = PromiseQueue;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/CollectionIndex.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollectionIndex = undefined;\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar CollectionIndex = exports.CollectionIndex = function () {\n  function CollectionIndex() {\n    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, CollectionIndex);\n\n    (0, _invariant2.default)(options.fieldName, 'CollectionIndex(...): you must specify a \"feildName\" option');\n    (0, _invariant2.default)(!Array.isArray(options.fieldName), 'CollectionIndex(...): compound index is not supported yet');\n\n    this.fieldName = options.fieldName;\n    this.unique = options.unique || false;\n    this.sparse = options.sparse || false;\n\n    this.reset();\n  }\n\n  _createClass(CollectionIndex, [{\n    key: 'reset',\n    value: function reset() {\n      // TODO\n    }\n  }, {\n    key: 'insert',\n    value: function insert(doc) {\n      // TODO\n    }\n  }, {\n    key: 'remove',\n    value: function remove(doc) {\n      // TODO\n    }\n  }, {\n    key: 'update',\n    value: function update(oldDoc, newDoc) {\n      // TODO\n    }\n  }, {\n    key: 'getMatching',\n    value: function getMatching(value) {\n      // TODO\n    }\n  }, {\n    key: 'getBetweenBounds',\n    value: function getBetweenBounds(query) {\n      // TODO\n    }\n  }, {\n    key: 'getAll',\n    value: function getAll(options) {\n      // TODO\n    }\n  }]);\n\n  return CollectionIndex;\n}();\n\nexports.default = CollectionIndex;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/DocumentRetriver.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocumentRetriver = undefined;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _filter2 = require('fast.js/array/filter');\n\nvar _filter3 = _interopRequireDefault(_filter2);\n\nvar _Document = require('./Document');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Internals\nvar DEFAULT_QUERY_FILTER = function DEFAULT_QUERY_FILTER() {\n  return true;\n};\n\n/**\n * Class for getting data objects by given list of ids.\n * Promises based. It makes requests asyncronousle by\n * getting request frame from database.\n * It's not use caches, because it's a task of store.\n * It just retrives content by 'get' method.\n */\n\nvar DocumentRetriver = exports.DocumentRetriver = function () {\n  function DocumentRetriver(db) {\n    _classCallCheck(this, DocumentRetriver);\n\n    this.db = db;\n  }\n\n  /**\n   * Retrive an optimal superset of documents\n   * by given query based on _id field of the query\n   *\n   * TODO: there is a place for indexes\n   *\n   * @param  {Object} query\n   * @return {Promise}\n   */\n\n  _createClass(DocumentRetriver, [{\n    key: 'retriveForQeury',\n    value: function retriveForQeury(query) {\n      var queryFilter = arguments.length <= 1 || arguments[1] === undefined ? DEFAULT_QUERY_FILTER : arguments[1];\n      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n      // Try to get list of ids\n      var selectorIds = undefined;\n      if ((0, _Document.selectorIsId)(query)) {\n        // fast path for scalar query\n        selectorIds = [query];\n      } else if ((0, _Document.selectorIsIdPerhapsAsObject)(query)) {\n        // also do the fast path for { _id: idString }\n        selectorIds = [query._id];\n      } else if (_checkTypes2.default.object(query) && query.hasOwnProperty('_id') && _checkTypes2.default.object(query._id) && query._id.hasOwnProperty('$in') && _checkTypes2.default.array(query._id.$in)) {\n        // and finally fast path for multiple ids\n        // selected by $in operator\n        selectorIds = query._id.$in;\n      }\n\n      // Retrive optimally\n      if (_checkTypes2.default.array(selectorIds) && selectorIds.length > 0) {\n        return this.retriveIds(queryFilter, selectorIds, options);\n      } else {\n        return this.retriveAll(queryFilter, options);\n      }\n    }\n\n    /**\n     * Rterive all ids given in constructor.\n     * If some id is not retrived (retrived qith error),\n     * then returned promise will be rejected with that error.\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'retriveAll',\n    value: function retriveAll() {\n      var _this = this;\n\n      var queryFilter = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_QUERY_FILTER : arguments[0];\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var limit = options.limit || +Infinity;\n      var result = [];\n      var stopped = false;\n\n      return new Promise(function (resolve, reject) {\n        var stream = _this.db.storage.createReadStream();\n\n        stream.on('data', function (data) {\n          // After deleting of an item some storages\n          // may return an undefined for a few times.\n          // We need to check it there.\n          if (!stopped && data.value) {\n            var doc = _this.db.create(data.value);\n            if (result.length < limit && queryFilter(doc)) {\n              result.push(doc);\n            }\n            // Limit the result if storage supports it\n            if (result.length === limit && stream.pause) {\n              stream.pause();\n              resolve(result);\n              stopped = true;\n            }\n          }\n        }).on('end', function () {\n          return !stopped && resolve(result);\n        });\n      });\n    }\n\n    /**\n     * Rterive all ids given in constructor.\n     * If some id is not retrived (retrived qith error),\n     * then returned promise will be rejected with that error.\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'retriveIds',\n    value: function retriveIds() {\n      var queryFilter = arguments.length <= 0 || arguments[0] === undefined ? DEFAULT_QUERY_FILTER : arguments[0];\n\n      var _this2 = this;\n\n      var ids = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n      var uniqIds = (0, _filter3.default)(ids, function (id, i) {\n        return ids.indexOf(id) === i;\n      });\n      var retrPromises = (0, _map3.default)(uniqIds, function (id) {\n        return _this2.retriveOne(id);\n      });\n      var limit = options.limit || +Infinity;\n\n      return Promise.all(retrPromises).then(function (res) {\n        var filteredRes = [];\n\n        for (var i = 0; i < res.length; i++) {\n          var doc = res[i];\n          if (doc && queryFilter(doc)) {\n            filteredRes.push(doc);\n            if (filteredRes.length === limit) {\n              break;\n            }\n          }\n        }\n\n        return filteredRes;\n      });\n    }\n\n    /**\n     * Retrive one document by given id\n     * @param  {String} id\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'retriveOne',\n    value: function retriveOne(id) {\n      var _this3 = this;\n\n      return this.db.storage.get(id).then(function (buf) {\n        return _this3.db.create(buf);\n      });\n    }\n  }]);\n\n  return DocumentRetriver;\n}();\n\nexports.default = DocumentRetriver;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/Document.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoTypeComp = undefined;\nexports.selectorIsId = selectorIsId;\nexports.selectorIsIdPerhapsAsObject = selectorIsIdPerhapsAsObject;\nexports.isArray = isArray;\nexports.isPlainObject = isPlainObject;\nexports.isIndexable = isIndexable;\nexports.isOperatorObject = isOperatorObject;\nexports.isNumericKey = isNumericKey;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _EJSON = require('./EJSON');\n\nvar _EJSON2 = _interopRequireDefault(_EJSON);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Return true if given selector is an\n * object id type (string or number)\n * @param  {Mixed} selector\n * @return {Boolean}\n */\nfunction selectorIsId(selector) {\n  return _checkTypes2.default.string(selector) || _checkTypes2.default.number(selector);\n}\n\nfunction selectorIsIdPerhapsAsObject(selector) {\n  return selectorIsId(selector) || selector && _checkTypes2.default.object(selector) && selector._id && selectorIsId(selector._id) && (0, _keys3.default)(selector).length === 1;\n}\n\nfunction isArray(x) {\n  return _checkTypes2.default.array(x) && !_EJSON2.default.isBinary(x);\n}\n\nfunction isPlainObject(x) {\n  return x && MongoTypeComp._type(x) === 3;\n}\n\nfunction isIndexable(x) {\n  return isArray(x) || isPlainObject(x);\n}\n\n// Returns true if this is an object with at least one key and all keys begin\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\n// others don't.\nfunction isOperatorObject(valueSelector, inconsistentOK) {\n  if (!isPlainObject(valueSelector)) {\n    return false;\n  }\n\n  var theseAreOperators = undefined;\n  (0, _forEach2.default)(valueSelector, function (value, selKey) {\n    var thisIsOperator = selKey.substr(0, 1) === '$';\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) {\n        throw new Error('Inconsistent operator: ' + JSON.stringify(valueSelector));\n      }\n      theseAreOperators = false;\n    }\n  });\n  return !!theseAreOperators; // {} has no operators\n}\n\n// string can be converted to integer\nfunction isNumericKey(s) {\n  return (/^[0-9]+$/.test(s)\n  );\n}\n\n// helpers used by compiled selector code\nvar MongoTypeComp = exports.MongoTypeComp = {\n  // XXX for _all and _in, consider building 'inquery' at compile time..\n\n  _type: function _type(v) {\n    if (typeof v === 'number') {\n      return 1;\n    } else if (typeof v === 'string') {\n      return 2;\n    } else if (typeof v === 'boolean') {\n      return 8;\n    } else if (isArray(v)) {\n      return 4;\n    } else if (v === null) {\n      return 10;\n    } else if (v instanceof RegExp) {\n      // note that typeof(/x/) === 'object'\n      return 11;\n    } else if (typeof v === 'function') {\n      return 13;\n    } else if (v instanceof Date) {\n      return 9;\n    } else if (_EJSON2.default.isBinary(v)) {\n      return 5;\n    }\n    return 3; // object\n\n    // XXX support some/all of these:\n    // 14, symbol\n    // 15, javascript code with scope\n    // 16, 18: 32-bit/64-bit integer\n    // 17, timestamp\n    // 255, minkey\n    // 127, maxkey\n  },\n\n  // deep equality test: use for literal document and array matches\n  _equal: function _equal(a, b) {\n    return _EJSON2.default.equals(a, b, { keyOrderSensitive: true });\n  },\n\n  // maps a type code to a value that can be used to sort values of\n  // different types\n  _typeorder: function _typeorder(t) {\n    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types\n    // XXX what is the correct sort position for Javascript code?\n    // ('100' in the matrix below)\n    // XXX minkey/maxkey\n    return [-1, // (not a type)\n    1, // number\n    2, // string\n    3, // object\n    4, // array\n    5, // binary\n    -1, // deprecated\n    6, // ObjectID\n    7, // bool\n    8, // Date\n    0, // null\n    9, // RegExp\n    -1, // deprecated\n    100, // JS code\n    2, // deprecated (symbol)\n    100, // JS code\n    1, // 32-bit int\n    8, // Mongo timestamp\n    1][// 64-bit int\n    t];\n  },\n\n  // compare two values of unknown type according to BSON ordering\n  // semantics. (as an extension, consider 'undefined' to be less than\n  // any other value.) return negative if a is less, positive if b is\n  // less, or 0 if equal\n  _cmp: function _cmp(a, b) {\n    if (a === undefined) {\n      return b === undefined ? 0 : -1;\n    }\n    if (b === undefined) {\n      return 1;\n    }\n    var ta = MongoTypeComp._type(a);\n    var tb = MongoTypeComp._type(b);\n    var oa = MongoTypeComp._typeorder(ta);\n    var ob = MongoTypeComp._typeorder(tb);\n    if (oa !== ob) {\n      return oa < ob ? -1 : 1;\n    }\n    if (ta !== tb) {\n      // XXX need to implement this if we implement Symbol or integers, or\n      // Timestamp\n      throw Error('Missing type coercion logic in _cmp');\n    }\n    if (ta === 7) {\n      // ObjectID\n      // Convert to string.\n      ta = tb = 2;\n      a = a.toHexString();\n      b = b.toHexString();\n    }\n    if (ta === 9) {\n      // Date\n      // Convert to millis.\n      ta = tb = 1;\n      a = a.getTime();\n      b = b.getTime();\n    }\n\n    if (ta === 1) {\n      // double\n      return a - b;\n    }\n    if (tb === 2) {\n      // string\n      return a < b ? -1 : a === b ? 0 : 1;\n    }\n    if (ta === 3) {\n      // Object\n      // this could be much more efficient in the expected case ...\n      var to_array = function to_array(obj) {\n        var ret = [];\n        for (var key in obj) {\n          ret.push(key);\n          ret.push(obj[key]);\n        }\n        return ret;\n      };\n      return MongoTypeComp._cmp(to_array(a), to_array(b));\n    }\n    if (ta === 4) {\n      // Array\n      for (var i = 0;; i++) {\n        if (i === a.length) {\n          return i === b.length ? 0 : -1;\n        }\n        if (i === b.length) {\n          return 1;\n        }\n        var s = MongoTypeComp._cmp(a[i], b[i]);\n        if (s !== 0) {\n          return s;\n        }\n      }\n    }\n    if (ta === 5) {\n      // binary\n      // Surprisingly, a small binary blob is always less than a large one in\n      // Mongo.\n      if (a.length !== b.length) {\n        return a.length - b.length;\n      }\n      for (i = 0; i < a.length; i++) {\n        if (a[i] < b[i]) {\n          return -1;\n        }\n        if (a[i] > b[i]) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    if (ta === 8) {\n      // boolean\n      if (a) {\n        return b ? 0 : 1;\n      }\n      return b ? -1 : 0;\n    }\n    if (ta === 10) {\n      // null\n      return 0;\n    }\n    if (ta === 11) {\n      // regexp\n      throw Error('Sorting not supported on regular expression'); // XXX\n    }\n    // 13: javascript code\n    // 14: symbol\n    // 15: javascript code with scope\n    // 16: 32-bit integer\n    // 17: timestamp\n    // 18: 64-bit integer\n    // 255: minkey\n    // 127: maxkey\n    if (ta === 13) {\n      // javascript code\n      throw Error('Sorting not supported on Javascript code'); // XXX\n    }\n    throw Error('Unknown type to sort');\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/EJSON.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; }; /**\n                                                                                                                                                                                                                                                   * Based on Meteor's EJSON package.\n                                                                                                                                                                                                                                                   * Rewrite with ES6 and better formated for passing\n                                                                                                                                                                                                                                                   * linter\n                                                                                                                                                                                                                                                   */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EJSON = undefined;\n\nvar _Base = require('./Base64');\n\nvar _Base2 = _interopRequireDefault(_Base);\n\nvar _some2 = require('fast.js/array/some');\n\nvar _some3 = _interopRequireDefault(_some2);\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Internal utils\nfunction _isNaN(val) {\n  return typeof val === 'number' && val != +val;\n}\nfunction _has(obj, key) {\n  return _checkTypes2.default.object(obj) && obj.hasOwnProperty(key);\n}\nfunction _isInfOrNan(val) {\n  return _isNaN(val) || val === Infinity || val === -Infinity;\n}\nfunction _isArguments(val) {\n  return !!val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) == 'object' && Object.prototype.hasOwnProperty.call(val, 'callee') && !Object.prototype.propertyIsEnumerable.call(val, 'callee');\n}\n\nvar EJSON = exports.EJSON = function () {\n  // @ngInject\n\n  function EJSON() {\n    _classCallCheck(this, EJSON);\n\n    this._setupBuiltinConverters();\n    this._customTypes = {};\n  }\n\n  /**\n   * @summary Add a custom type, using a method of your choice to get to and\n   * from a basic JSON-able representation.  The factory argument\n   * is a function of JSON-able --> your object\n   * The type you add must have:\n   * - A toJSONValue() method, so that Meteor can serialize it\n   * - a typeName() method, to show how to look it up in our type table.\n   * It is okay if these methods are monkey-patched on.\n   * EJSON.clone will use toJSONValue and the given factory to produce\n   * a clone, but you may specify a method clone() that will be used instead.\n   * Similarly, EJSON.equals will use toJSONValue to make comparisons,\n   * but you may provide a method equals() instead.\n   * @locus Anywhere\n   * @param {String} name A tag for your custom type; must be unique among custom data types defined in your project, and must match the result of your type's `typeName` method.\n   * @param {Function} factory A function that deserializes a JSON-compatible value into an instance of your type.  This should match the serialization performed by your type's `toJSONValue` method.\n   */\n\n  _createClass(EJSON, [{\n    key: 'addType',\n    value: function addType(name, factory) {\n      if (_has(this._customTypes, name)) {\n        throw new Error('Type ' + name + ' already present');\n      }\n      this._customTypes[name] = factory;\n    }\n\n    /**\n     * @summary Serialize an EJSON-compatible value into its plain JSON representation.\n     * @locus Anywhere\n     * @param {EJSON} val A value to serialize to plain JSON.\n     */\n\n  }, {\n    key: 'toJSONValue',\n    value: function toJSONValue(item) {\n      var changed = this._toJSONValueHelper(item);\n      if (changed !== undefined) {\n        return changed;\n      }\n      if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n        item = this.clone(item);\n        this._adjustTypesToJSONValue(item);\n      }\n      return item;\n    }\n\n    /**\n     * @summary Deserialize an EJSON value from its plain JSON representation.\n     * @locus Anywhere\n     * @param {JSONCompatible} val A value to deserialize into EJSON.\n     */\n\n  }, {\n    key: 'fromJSONValue',\n    value: function fromJSONValue(item) {\n      var changed = this._fromJSONValueHelper(item);\n      if (changed === item && (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n        item = this.clone(item);\n        this._adjustTypesFromJSONValue(item);\n        return item;\n      } else {\n        return changed;\n      }\n    }\n\n    /**\n     * @summary Serialize a value to a string.\n     * For EJSON values, the serialization fully represents the value. For non-EJSON values, serializes the same way as `JSON.stringify`.\n     * @locus Anywhere\n     * @param {EJSON} val A value to stringify.\n     */\n\n  }, {\n    key: 'stringify',\n    value: function stringify(item) {\n      var json = this.toJSONValue(item);\n      return JSON.stringify(json);\n    }\n\n    /**\n     * @summary Parse a string into an EJSON value. Throws an error if the string is not valid EJSON.\n     * @locus Anywhere\n     * @param {String} str A string to parse into an EJSON value.\n     */\n\n  }, {\n    key: 'parse',\n    value: function parse(item) {\n      if (typeof item !== 'string') {\n        throw new Error('EJSON.parse argument should be a string');\n      }\n      return this.fromJSONValue(JSON.parse(item));\n    }\n\n    /**\n     * @summary Returns true if `x` is a buffer of binary data, as returned from [`EJSON.newBinary`](#ejson_new_binary).\n     * @param {Object} x The variable to check.\n     * @locus Anywhere\n     */\n\n  }, {\n    key: 'isBinary',\n    value: function isBinary(obj) {\n      return !!(typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && obj.$Uint8ArrayPolyfill);\n    }\n\n    /**\n     * @summary Return true if `a` and `b` are equal to each other.  Return false otherwise.  Uses the `equals` method on `a` if present, otherwise performs a deep comparison.\n     * @locus Anywhere\n     * @param {EJSON} a\n     * @param {EJSON} b\n     * @param {Object} [options]\n     * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order, if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}` is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The default is `false`.\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(a, b, options) {\n      var _this = this;\n\n      var i;\n      var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n      if (a === b) {\n        return true;\n      }\n      if (_isNaN(a) && _isNaN(b)) {\n        return true; // This differs from the IEEE spec for NaN equality, b/c we don't want\n        // anything ever with a NaN to be poisoned from becoming equal to anything.\n      }\n      if (!a || !b) {\n        // if either one is falsy, they'd have to be === to be equal\n        return false;\n      }\n      if (!((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object' && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object')) {\n        return false;\n      }\n      if (a instanceof Date && b instanceof Date) {\n        return a.valueOf() === b.valueOf();\n      }\n      if (this.isBinary(a) && this.isBinary(b)) {\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (i = 0; i < a.length; i++) {\n          if (a[i] !== b[i]) {\n            return false;\n          }\n        }\n        return true;\n      }\n      if (typeof a.equals === 'function') {\n        return a.equals(b, options);\n      }\n      if (typeof b.equals === 'function') {\n        return b.equals(a, options);\n      }\n      if (a instanceof Array) {\n        if (!(b instanceof Array)) {\n          return false;\n        }\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (i = 0; i < a.length; i++) {\n          if (!this.equals(a[i], b[i], options)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      // fallback for custom types that don't implement their own equals\n      switch (this._isCustomType(a) + this._isCustomType(b)) {\n        case 1:\n          return false;\n        case 2:\n          return this.equals(this.toJSONValue(a), this.toJSONValue(b));\n      }\n      // fall back to structural equality of objects\n      var ret;\n      if (keyOrderSensitive) {\n        var bKeys = (0, _keys3.default)(b);\n        i = 0;\n        ret = (0, _keys3.default)(a).every(function (x) {\n          if (i >= bKeys.length) {\n            return false;\n          }\n          if (x !== bKeys[i]) {\n            return false;\n          }\n          if (!_this.equals(a[x], b[bKeys[i]], options)) {\n            return false;\n          }\n          i++;\n          return true;\n        });\n        return ret && i === bKeys.length;\n      } else {\n        i = 0;\n        ret = (0, _keys3.default)(a).every(function (key) {\n          if (!_has(b, key)) {\n            return false;\n          }\n          if (!_this.equals(a[key], b[key], options)) {\n            return false;\n          }\n          i++;\n          return true;\n        });\n        return ret && (0, _keys3.default)(b).length === i;\n      }\n    }\n\n    /**\n     * @summary Return a deep copy of `val`.\n     * @locus Anywhere\n     * @param {EJSON} val A value to copy.\n     */\n\n  }, {\n    key: 'clone',\n    value: function clone(v) {\n      var _this2 = this;\n\n      var ret;\n      if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) !== 'object') {\n        return v;\n      }\n      if (v === null) {\n        return null; // null has typeof 'object'\n      }\n      if (v instanceof Date) {\n        return new Date(v.getTime());\n      }\n      // RegExps are not really EJSON elements (eg we don't define a serialization\n      // for them), but they're immutable anyway, so we can support them in clone.\n      if (v instanceof RegExp) {\n        return v;\n      }\n      if (this.isBinary(v)) {\n        ret = _Base2.default.newBinary(v.length);\n        for (var i = 0; i < v.length; i++) {\n          ret[i] = v[i];\n        }\n        return ret;\n      }\n\n      if (_checkTypes2.default.array(v) || _isArguments(v)) {\n        ret = [];\n        for (var i = 0; i < v.length; i++) {\n          ret[i] = this.clone(v[i]);\n        }\n        return ret;\n      }\n      // handle general user-defined typed Objects if they have a clone method\n      if (typeof v.clone === 'function') {\n        return v.clone();\n      }\n      // handle other custom types\n      if (this._isCustomType(v)) {\n        return this.fromJSONValue(this.clone(this.toJSONValue(v)), true);\n      }\n      // handle other objects\n      ret = {};\n      (0, _forEach2.default)(v, function (val, key) {\n        ret[key] = _this2.clone(val);\n      });\n      return ret;\n    }\n  }, {\n    key: 'newBinary',\n    value: function newBinary(len) {\n      return _Base2.default.newBinary(len);\n    }\n  }, {\n    key: '_setupBuiltinConverters',\n    value: function _setupBuiltinConverters() {\n      var _this3 = this;\n\n      this._builtinConverters = [{ // Date\n        matchJSONValue: function matchJSONValue(obj) {\n          return _has(obj, '$date') && (0, _keys3.default)(obj).length === 1;\n        },\n        matchObject: function matchObject(obj) {\n          return obj instanceof Date;\n        },\n        toJSONValue: function toJSONValue(obj) {\n          return { $date: obj.getTime() };\n        },\n        fromJSONValue: function fromJSONValue(obj) {\n          return new Date(obj.$date);\n        }\n      }, { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n        // which we match.)\n        matchJSONValue: function matchJSONValue(obj) {\n          return _has(obj, '$InfNaN') && (0, _keys3.default)(obj).length === 1;\n        },\n        matchObject: _isInfOrNan,\n        toJSONValue: function toJSONValue(obj) {\n          var sign;\n          if (_isNaN(obj)) {\n            sign = 0;\n          } else if (obj === Infinity) {\n            sign = 1;\n          } else {\n            sign = -1;\n          }\n          return { $InfNaN: sign };\n        },\n        fromJSONValue: function fromJSONValue(obj) {\n          return obj.$InfNaN / 0;\n        }\n      }, { // Binary\n        matchJSONValue: function matchJSONValue(obj) {\n          return _has(obj, '$binary') && (0, _keys3.default)(obj).length === 1;\n        },\n        matchObject: function matchObject(obj) {\n          return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && _has(obj, '$Uint8ArrayPolyfill');\n        },\n        toJSONValue: function toJSONValue(obj) {\n          return { $binary: _Base2.default.encode(obj) };\n        },\n        fromJSONValue: function fromJSONValue(obj) {\n          return _Base2.default.decode(obj.$binary);\n        }\n      }, { // Escaping one level\n        matchJSONValue: function matchJSONValue(obj) {\n          return _has(obj, '$escape') && (0, _keys3.default)(obj).length === 1;\n        },\n        matchObject: function matchObject(obj) {\n          if (!_checkTypes2.default.assigned(obj) || _checkTypes2.default.emptyObject(obj) || _checkTypes2.default.object(obj) && (0, _keys3.default)(obj).length > 2) {\n            return false;\n          }\n          return (0, _some3.default)(_this3._builtinConverters, function (converter) {\n            return converter.matchJSONValue(obj);\n          });\n        },\n        toJSONValue: function toJSONValue(obj) {\n          var newObj = {};\n          (0, _forEach2.default)(obj, function (val, key) {\n            newObj[key] = _this3.toJSONValue(val);\n          });\n          return { $escape: newObj };\n        },\n        fromJSONValue: function fromJSONValue(obj) {\n          var newObj = {};\n          (0, _forEach2.default)(obj.$escape, function (val, key) {\n            newObj[key] = _this3.fromJSONValue(val);\n          });\n          return newObj;\n        }\n      }, { // Custom\n        matchJSONValue: function matchJSONValue(obj) {\n          return _has(obj, '$type') && _has(obj, '$value') && (0, _keys3.default)(obj).length === 2;\n        },\n        matchObject: function matchObject(obj) {\n          return _this3._isCustomType(obj);\n        },\n        toJSONValue: function toJSONValue(obj) {\n          var jsonValue = obj.toJSONValue();\n          return { $type: obj.typeName(), $value: jsonValue };\n        },\n        fromJSONValue: function fromJSONValue(obj) {\n          var typeName = obj.$type;\n          if (!_has(_this3._customTypes, typeName)) {\n            throw new Error('Custom EJSON type ' + typeName + ' is not defined');\n          }\n          var converter = _this3._customTypes[typeName];\n          return converter(obj.$value);\n        }\n      }];\n    }\n  }, {\n    key: '_isCustomType',\n    value: function _isCustomType(obj) {\n      return obj && typeof obj.toJSONValue === 'function' && typeof obj.typeName === 'function' && _has(this._customTypes, obj.typeName());\n    }\n\n    /**\n     * For both arrays and objects, in-place modification.\n     */\n\n  }, {\n    key: '_adjustTypesToJSONValue',\n    value: function _adjustTypesToJSONValue(obj) {\n      var _this4 = this;\n\n      // Is it an atom that we need to adjust?\n      if (obj === null) {\n        return null;\n      }\n      var maybeChanged = this._toJSONValueHelper(obj);\n      if (maybeChanged !== undefined) {\n        return maybeChanged;\n      }\n\n      // Other atoms are unchanged.\n      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n        return obj;\n      }\n\n      // Iterate over array or object structure.\n      (0, _forEach2.default)(obj, function (value, key) {\n        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' && value !== undefined && !_isInfOrNan(value)) {\n          return;\n        }\n\n        var changed = _this4._toJSONValueHelper(value);\n        if (changed) {\n          obj[key] = changed;\n          return;\n        }\n        // if we get here, value is an object but not adjustable\n        // at this level.  recurse.\n        _this4._adjustTypesToJSONValue(value);\n      });\n      return obj;\n    }\n\n    /**\n     * Either return the JSON-compatible version of the argument, or undefined\n     * (if the item isn't itself replaceable, but maybe some fields in it are)\n     */\n\n  }, {\n    key: '_toJSONValueHelper',\n    value: function _toJSONValueHelper(item) {\n      for (var i = 0; i < this._builtinConverters.length; i++) {\n        var converter = this._builtinConverters[i];\n        if (converter.matchObject(item)) {\n          return converter.toJSONValue(item);\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * For both arrays and objects. Tries its best to just\n     * use the object you hand it, but may return something\n     * different if the object you hand it itself needs changing.\n     */\n\n  }, {\n    key: '_adjustTypesFromJSONValue',\n    value: function _adjustTypesFromJSONValue(obj) {\n      var _this5 = this;\n\n      if (obj === null) {\n        return null;\n      }\n      var maybeChanged = this._fromJSONValueHelper(obj);\n      if (maybeChanged !== obj) {\n        return maybeChanged;\n      }\n\n      // Other atoms are unchanged.\n      if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n        return obj;\n      }\n\n      (0, _forEach2.default)(obj, function (value, key) {\n        if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n          var changed = _this5._fromJSONValueHelper(value);\n          if (value !== changed) {\n            obj[key] = changed;\n            return;\n          }\n          // if we get here, value is an object but not adjustable\n          // at this level.  recurse.\n          _this5._adjustTypesFromJSONValue(value);\n        }\n      });\n      return obj;\n    }\n\n    /**\n     * Either return the argument changed to have the non-json\n     * rep of itself (the Object version) or the argument itself.\n     * DOES NOT RECURSE.  For actually getting the fully-changed value,\n     * use EJSON.fromJSONValue\n     */\n\n  }, {\n    key: '_fromJSONValueHelper',\n    value: function _fromJSONValueHelper(value) {\n      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null) {\n        if ((0, _keys3.default)(value).length <= 2 && (0, _keys3.default)(value).every(function (k) {\n          return typeof k === 'string' && k.substr(0, 1) === '$';\n        })) {\n          for (var i = 0; i < this._builtinConverters.length; i++) {\n            var converter = this._builtinConverters[i];\n            if (converter.matchJSONValue(value)) {\n              return converter.fromJSONValue(value);\n            }\n          }\n        }\n      }\n      return value;\n    }\n  }]);\n\n  return EJSON;\n}();\n\nexports.default = new EJSON();","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/Base64.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Based on Meteor's Base64 package.\n * Rewrite with ES6 and better formated for passing\n * linter\n */\nvar BASE_64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nvar BASE_64_VALS = {};\n\n(function setupBase64Vals() {\n  for (var j = 0; j < BASE_64_CHARS.length; j++) {\n    BASE_64_VALS[BASE_64_CHARS.charAt(j)] = j;\n  }\n})();\n\nvar getChar = function getChar(val) {\n  return BASE_64_CHARS.charAt(val);\n};\n\nvar getVal = function getVal(ch) {\n  if (ch === '=') {\n    return -1;\n  }\n  return BASE_64_VALS[ch];\n};\n\n// Base 64 encoding\n\nvar Base64 = exports.Base64 = function () {\n  function Base64() {\n    _classCallCheck(this, Base64);\n  }\n\n  _createClass(Base64, [{\n    key: 'encode',\n    value: function encode(array) {\n      if (typeof array === 'string') {\n        var str = array;\n        array = this.newBinary(str.length);\n        for (var i = 0; i < str.length; i++) {\n          var ch = str.charCodeAt(i);\n          if (ch > 0xFF) {\n            throw new Error('Not ascii. Base64.encode can only take ascii strings.');\n          }\n          array[i] = ch;\n        }\n      }\n\n      var answer = [];\n      var a = null;\n      var b = null;\n      var c = null;\n      var d = null;\n      for (var i = 0; i < array.length; i++) {\n        switch (i % 3) {\n          case 0:\n            a = array[i] >> 2 & 0x3F;\n            b = (array[i] & 0x03) << 4;\n            break;\n          case 1:\n            b |= array[i] >> 4 & 0xF;\n            c = (array[i] & 0xF) << 2;\n            break;\n          case 2:\n            c |= array[i] >> 6 & 0x03;\n            d = array[i] & 0x3F;\n            answer.push(getChar(a));\n            answer.push(getChar(b));\n            answer.push(getChar(c));\n            answer.push(getChar(d));\n            a = null;\n            b = null;\n            c = null;\n            d = null;\n            break;\n        }\n      }\n      if (a != null) {\n        answer.push(getChar(a));\n        answer.push(getChar(b));\n        if (c == null) {\n          answer.push('=');\n        } else {\n          answer.push(getChar(c));\n        }\n        if (d == null) {\n          answer.push('=');\n        }\n      }\n      return answer.join('');\n    }\n  }, {\n    key: 'decode',\n    value: function decode(str) {\n      var len = Math.floor(str.length * 3 / 4);\n      if (str.charAt(str.length - 1) == '=') {\n        len--;\n        if (str.charAt(str.length - 2) == '=') {\n          len--;\n        }\n      }\n      var arr = this.newBinary(len);\n\n      var one = null;\n      var two = null;\n      var three = null;\n\n      var j = 0;\n\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        var v = getVal(c);\n        switch (i % 4) {\n          case 0:\n            if (v < 0) {\n              throw new Error('invalid base64 string');\n            }\n            one = v << 2;\n            break;\n          case 1:\n            if (v < 0) {\n              throw new Error('invalid base64 string');\n            }\n            one |= v >> 4;\n            arr[j++] = one;\n            two = (v & 0x0F) << 4;\n            break;\n          case 2:\n            if (v >= 0) {\n              two |= v >> 2;\n              arr[j++] = two;\n              three = (v & 0x03) << 6;\n            }\n            break;\n          case 3:\n            if (v >= 0) {\n              arr[j++] = three | v;\n            }\n            break;\n        }\n      }\n      return arr;\n    }\n  }, {\n    key: 'newBinary',\n    value: function newBinary(len) {\n      if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\n        var ret = [];\n        for (var i = 0; i < len; i++) {\n          ret.push(0);\n        }\n        ret.$Uint8ArrayPolyfill = true;\n        return ret;\n      }\n      return new Uint8Array(new ArrayBuffer(len));\n    }\n  }]);\n\n  return Base64;\n}();\n\nexports.default = new Base64();","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/StorageManager.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StorageManager = undefined;\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _eventemitter = require('eventemitter3');\n\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\nvar _PromiseQueue = require('./PromiseQueue');\n\nvar _PromiseQueue2 = _interopRequireDefault(_PromiseQueue);\n\nvar _EJSON = require('./EJSON');\n\nvar _EJSON2 = _interopRequireDefault(_EJSON);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Manager for dealing with backend storage\n * of the daatabase. Default implementation uses\n * memory. You can implement the same interface\n * and use another storage (with levelup, for example)\n */\n\nvar StorageManager = exports.StorageManager = function () {\n  function StorageManager(db) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, StorageManager);\n\n    this.db = db;\n    this.options = options;\n    this._queue = new _PromiseQueue2.default(1);\n    this._storage = {};\n    this.reload();\n  }\n\n  _createClass(StorageManager, [{\n    key: 'loaded',\n    value: function loaded() {\n      return this._loadedPromise;\n    }\n  }, {\n    key: 'reload',\n    value: function reload() {\n      var _this = this;\n\n      if (this._loadedPromise) {\n        this._loadedPromise = this._loadedPromise.then(function () {\n          return _this._loadStorage();\n        });\n      } else {\n        this._loadedPromise = this._loadStorage();\n      }\n      return this.loaded();\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      var _this2 = this;\n\n      return this.loaded().then(function () {\n        _this2._storage = {};\n      });\n    }\n  }, {\n    key: 'persist',\n    value: function persist(key, value) {\n      var _this3 = this;\n\n      return this.loaded().then(function () {\n        _this3._storage[key] = _EJSON2.default.clone(value);\n      });\n    }\n  }, {\n    key: 'delete',\n    value: function _delete(key) {\n      var _this4 = this;\n\n      return this.loaded().then(function () {\n        delete _this4._storage[key];\n      });\n    }\n  }, {\n    key: 'get',\n    value: function get(key) {\n      var _this5 = this;\n\n      return this.loaded().then(function () {\n        return _this5._storage[key];\n      });\n    }\n  }, {\n    key: 'createReadStream',\n    value: function createReadStream() {\n      var _this6 = this;\n\n      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      // Very limited subset of ReadableStream\n      var paused = false;\n      var emitter = new _eventemitter2.default();\n      emitter.pause = function () {\n        return paused = true;\n      };\n\n      this.loaded().then(function () {\n        var keys = (0, _keys3.default)(_this6._storage);\n        for (var i = 0; i < keys.length; i++) {\n          emitter.emit('data', { value: _this6._storage[keys[i]] });\n          if (paused) {\n            return;\n          }\n        }\n        emitter.emit('end');\n      });\n\n      return emitter;\n    }\n  }, {\n    key: '_loadStorage',\n    value: function _loadStorage() {\n      this._storage = {};\n      return Promise.resolve();\n    }\n  }]);\n\n  return StorageManager;\n}();\n\nexports.default = StorageManager;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/CollectionDelegate.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollectionDelegate = undefined;\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _DocumentModifier = require('./DocumentModifier');\n\nvar _DocumentModifier2 = _interopRequireDefault(_DocumentModifier);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Default collection delegate for working with a\n * normal MarsDB approach – within a browser.\n */\n\nvar CollectionDelegate = exports.CollectionDelegate = function () {\n  function CollectionDelegate(db) {\n    _classCallCheck(this, CollectionDelegate);\n\n    this.db = db;\n  }\n\n  _createClass(CollectionDelegate, [{\n    key: 'insert',\n    value: function insert(doc) {\n      var _this = this;\n\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n      var randomId = arguments[2];\n\n      return this.db.indexManager.indexDocument(doc).then(function () {\n        return _this.db.storageManager.persist(doc._id, doc).then(function () {\n          return doc._id;\n        });\n      });\n    }\n  }, {\n    key: 'remove',\n    value: function remove(query, _ref) {\n      var _this2 = this;\n\n      var _ref$sort = _ref.sort;\n      var sort = _ref$sort === undefined ? { _id: 1 } : _ref$sort;\n      var _ref$multi = _ref.multi;\n      var multi = _ref$multi === undefined ? false : _ref$multi;\n\n      return this.find(query, { noClone: true }).sort(sort).then(function (docs) {\n        if (docs.length > 1 && !multi) {\n          docs = [docs[0]];\n        }\n        var removeStorgePromises = (0, _map3.default)(docs, function (d) {\n          return _this2.db.storageManager.delete(d._id);\n        });\n        var removeIndexPromises = (0, _map3.default)(docs, function (d) {\n          return _this2.db.indexManager.deindexDocument(d);\n        });\n        return Promise.all([].concat(_toConsumableArray(removeStorgePromises), _toConsumableArray(removeIndexPromises))).then(function () {\n          return docs;\n        });\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update(query, modifier, _ref2) {\n      var _this3 = this;\n\n      var _ref2$sort = _ref2.sort;\n      var sort = _ref2$sort === undefined ? { _id: 1 } : _ref2$sort;\n      var _ref2$multi = _ref2.multi;\n      var multi = _ref2$multi === undefined ? false : _ref2$multi;\n      var _ref2$upsert = _ref2.upsert;\n      var upsert = _ref2$upsert === undefined ? false : _ref2$upsert;\n\n      return this.find(query, { noClone: true }).sort(sort).then(function (docs) {\n        if (docs.length > 1 && !multi) {\n          docs = [docs[0]];\n        }\n        return new _DocumentModifier2.default(query).modify(docs, modifier, { upsert: upsert });\n      }).then(function (_ref3) {\n        var original = _ref3.original;\n        var updated = _ref3.updated;\n\n        var updateStorgePromises = (0, _map3.default)(updated, function (d) {\n          return _this3.db.storageManager.persist(d._id, d);\n        });\n        var updateIndexPromises = (0, _map3.default)(updated, function (d, i) {\n          return _this3.db.indexManager.reindexDocument(original[i], d);\n        });\n        return Promise.all([].concat(_toConsumableArray(updateStorgePromises), _toConsumableArray(updateIndexPromises))).then(function () {\n          return {\n            modified: updated.length,\n            original: original,\n            updated: updated\n          };\n        });\n      });\n    }\n  }, {\n    key: 'find',\n    value: function find(query) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var cursorClass = this.db.cursorClass;\n      return new cursorClass(this.db, query, options);\n    }\n  }, {\n    key: 'findOne',\n    value: function findOne(query) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      return this.find(query, options).aggregate(function (docs) {\n        return docs[0];\n      }).limit(1);\n    }\n  }, {\n    key: 'count',\n    value: function count(query) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.noClone = true;\n      return this.find(query, options).aggregate(function (docs) {\n        return docs.length;\n      });\n    }\n  }, {\n    key: 'ids',\n    value: function ids(query) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      options.noClone = true;\n      return this.find(query, options).map(function (doc) {\n        return doc._id;\n      });\n    }\n  }]);\n\n  return CollectionDelegate;\n}();\n\nexports.default = CollectionDelegate;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/DocumentModifier.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findModTarget = exports.DocumentModifier = undefined;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _assign2 = require('fast.js/object/assign');\n\nvar _assign3 = _interopRequireDefault(_assign2);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _every2 = require('fast.js/array/every');\n\nvar _every3 = _interopRequireDefault(_every2);\n\nvar _EJSON = require('./EJSON');\n\nvar _EJSON2 = _interopRequireDefault(_EJSON);\n\nvar _Random = require('./Random');\n\nvar _Random2 = _interopRequireDefault(_Random);\n\nvar _DocumentMatcher = require('./DocumentMatcher');\n\nvar _DocumentMatcher2 = _interopRequireDefault(_DocumentMatcher);\n\nvar _DocumentSorter = require('./DocumentSorter');\n\nvar _DocumentSorter2 = _interopRequireDefault(_DocumentSorter);\n\nvar _Document = require('./Document');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DocumentModifier = exports.DocumentModifier = function () {\n  function DocumentModifier() {\n    var query = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    _classCallCheck(this, DocumentModifier);\n\n    this._query = query;\n    this._matcher = new _DocumentMatcher2.default(query);\n  }\n\n  _createClass(DocumentModifier, [{\n    key: 'modify',\n    value: function modify(docs) {\n      var _this = this;\n\n      var mod = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n      var oldResults = [];\n      var newResults = [];\n\n      // Regular update\n      (0, _forEach2.default)(docs, function (d) {\n        var match = _this._matcher.documentMatches(d);\n        if (match.result) {\n          var matchOpts = (0, _assign3.default)({ arrayIndices: match.arrayIndices }, options);\n          var newDoc = _this._modifyDocument(d, mod, matchOpts);\n          newResults.push(newDoc);\n          oldResults.push(d);\n        }\n      });\n\n      // Upsert update\n      if (!newResults.length && options.upsert) {\n        var newDoc = documentBySelector(this._query);\n        newDoc._id = newDoc._id || _Random2.default.default().id(17);\n        newDoc = this._modifyDocument(newDoc, mod, { isInsert: true });\n        newResults.push(newDoc);\n        oldResults.push(null);\n      }\n\n      return {\n        updated: newResults,\n        original: oldResults\n      };\n    }\n\n    // XXX need a strategy for passing the binding of $ into this\n    // function, from the compiled selector\n    //\n    // maybe just {key.up.to.just.before.dollarsign: array_index}\n    //\n    // XXX atomicity: if one modification fails, do we roll back the whole\n    // change?\n    //\n    // options:\n    //   - isInsert is set when _modify is being called to compute the document to\n    //     insert as part of an upsert operation. We use this primarily to figure\n    //     out when to set the fields in $setOnInsert, if present.\n\n  }, {\n    key: '_modifyDocument',\n    value: function _modifyDocument(doc, mod) {\n      var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n      if (!(0, _Document.isPlainObject)(mod)) {\n        throw new Error('Modifier must be an object');\n      }\n\n      // Make sure the caller can't mutate our data structures.\n      mod = _EJSON2.default.clone(mod);\n      var isModifier = (0, _Document.isOperatorObject)(mod);\n      var newDoc;\n\n      if (!isModifier) {\n        if (!options.isInsert && mod._id && !_EJSON2.default.equals(doc._id, mod._id)) {\n          throw new Error('Cannot change the _id of a document');\n        }\n\n        // replace the whole document\n        for (var k in mod) {\n          if (/\\./.test(k)) {\n            throw new Error('When replacing document, field name may not contain \\'.\\'');\n          }\n        }\n        newDoc = mod;\n        newDoc._id = doc._id;\n      } else {\n        // apply modifiers to the doc.\n        newDoc = _EJSON2.default.clone(doc);\n\n        (0, _forEach2.default)(mod, function (operand, op) {\n          var modFunc = MODIFIERS[op];\n          // Treat $setOnInsert as $set if this is an insert.\n          if (options.isInsert && op === '$setOnInsert') {\n            modFunc = MODIFIERS.$set;\n          }\n          if (!modFunc) {\n            throw new Error('Invalid modifier specified ' + op);\n          }\n          (0, _forEach2.default)(operand, function (arg, keypath) {\n            if (keypath === '') {\n              throw new Error('An empty update path is not valid.');\n            }\n            if (keypath === '_id' && !options.isInsert) {\n              throw new Error('Mod on _id not allowed for update.');\n            }\n\n            var keyparts = keypath.split('.');\n\n            if (!(0, _every3.default)(keyparts, function (x) {\n              return x;\n            })) {\n              throw new Error('The update path \\'' + keypath + '\\' contains an empty field name, which is not allowed.');\n            }\n\n            var target = findModTarget(newDoc, keyparts, {\n              noCreate: NO_CREATE_MODIFIERS[op],\n              forbidArray: op === '$rename',\n              arrayIndices: options.arrayIndices\n            });\n            var field = keyparts.pop();\n            modFunc(target, field, arg, keypath, newDoc);\n          });\n        });\n      }\n\n      return newDoc;\n    }\n  }]);\n\n  return DocumentModifier;\n}();\n\nexports.default = DocumentModifier;\n\n// by given selector returns an object that should\n// be used for upsert operation\n\nvar documentBySelector = function documentBySelector(selector) {\n  var selectorDoc = {};\n\n  if (!_checkTypes2.default.object(selector)) {\n    selector = { _id: selector };\n  }\n\n  (0, _forEach2.default)(selector, function (v, k) {\n    if (k.substr(0, 1) !== '$' && !(0, _Document.isOperatorObject)(v, true)) {\n      var keyparts = k.split('.');\n      var modTarget = findModTarget(selectorDoc, keyparts);\n      if (modTarget) {\n        modTarget[keyparts[keyparts.length - 1]] = v;\n      }\n    }\n  });\n\n  return selectorDoc;\n};\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nvar findModTarget = exports.findModTarget = function findModTarget(doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = i === keyparts.length - 1;\n    var keypart = keyparts[i];\n    var indexable = (0, _Document.isIndexable)(doc);\n    if (!indexable) {\n      if (options.noCreate) {\n        return undefined;\n      }\n      var e = new Error('cannot use the part \\'' + keypart + '\\' to traverse ' + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw new Error('Too many positional (i.e. \\'$\\') elements');\n        }\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw new Error('The positional operator did not find the ' + 'match needed from the query');\n        }\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if ((0, _Document.isNumericKey)(keypart)) {\n        keypart = parseInt(keypart, 10);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n        throw new Error('can\\'t append to array using string field name [' + keypart + ']');\n      }\n      if (last) {\n        // handle 'a.01'\n        keyparts[i] = keypart;\n      }\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if (_typeof(doc[keypart]) !== 'object') {\n          throw new Error('can\\'t modify field \\'' + keyparts[i + 1] + '\\' of list value ' + JSON.stringify(doc[keypart]));\n        }\n      }\n    } else {\n      if (keypart.length && keypart.substr(0, 1) === '$') {\n        throw new Error('can\\'t set field named ' + keypart);\n      }\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n\n    if (last) {\n      return doc;\n    }\n    doc = doc[keypart];\n  }\n\n  // notreached\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true\n};\n\nvar MODIFIERS = {\n  $inc: function $inc(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw new Error('Modifier $inc allowed for numbers only');\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw new Error('Cannot apply $inc modifier to non-number');\n      }\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function $set(target, field, arg) {\n    if (!_checkTypes2.default.object(target) && !_checkTypes2.default.array(target)) {\n      var e = new Error('Cannot set property on non-object field');\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (target === null) {\n      var e = new Error('Cannot set property on null');\n      e.setPropertyError = true;\n      throw e;\n    }\n    target[field] = arg;\n  },\n  $setOnInsert: function $setOnInsert(target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset: function $unset(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push: function $push(target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n    if (!(target[field] instanceof Array)) {\n      throw new Error('Cannot apply $push modifier to non-array');\n    }\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      target[field].push(arg);\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array)) {\n      throw new Error('$each must be an array');\n    }\n\n    // Parse $position\n    var position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw new Error('$position must be a numeric value');\n      }\n      // XXX should check to make sure integer\n      if (arg.$position < 0) {\n        throw new Error('$position in $push must be zero or positive');\n      }\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    var slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw new Error('$slice must be a numeric value');\n      }\n      // XXX should check to make sure integer\n      if (arg.$slice > 0) {\n        throw new Error('$slice in $push must be zero or negative');\n      }\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    var sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw new Error('$sort requires $slice to be present');\n      }\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new _DocumentSorter2.default(arg.$sort).getComparator();\n      for (var i = 0; i < toPush.length; i++) {\n        if (_Document.MongoTypeComp._type(toPush[i]) !== 3) {\n          throw new Error('$push like modifiers using $sort ' + 'require all elements to be objects');\n        }\n      }\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      for (var j = 0; j < toPush.length; j++) {\n        target[field].push(toPush[j]);\n      }\n    } else {\n      var spliceArguments = [position, 0];\n      for (var j = 0; j < toPush.length; j++) {\n        spliceArguments.push(toPush[j]);\n      }\n      Array.prototype.splice.apply(target[field], spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    }\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = []; // differs from Array.slice!\n      } else {\n          target[field] = target[field].slice(slice);\n        }\n    }\n  },\n  $pushAll: function $pushAll(target, field, arg) {\n    if (!((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg instanceof Array)) {\n      throw new Error('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n    var x = target[field];\n    if (x === undefined) {\n      target[field] = arg;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $pushAll modifier to non-array');\n    } else {\n      for (var i = 0; i < arg.length; i++) {\n        x.push(arg[i]);\n      }\n    }\n  },\n  $addToSet: function $addToSet(target, field, arg) {\n    var isEach = false;\n    if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {\n      //check if first key is '$each'\n      for (var k in arg) {\n        if (k === '$each') {\n          isEach = true;\n        }\n        break;\n      }\n    }\n    var values = isEach ? arg.$each : [arg];\n    var x = target[field];\n    if (x === undefined) {\n      target[field] = values;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $addToSet modifier to non-array');\n    } else {\n      (0, _forEach2.default)(values, function (value) {\n        for (var i = 0; i < x.length; i++) {\n          if (_Document.MongoTypeComp._equal(value, x[i])) {\n            return;\n          }\n        }\n        x.push(value);\n      });\n    }\n  },\n  $pop: function $pop(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n    var x = target[field];\n    if (x === undefined) {\n      return;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $pop modifier to non-array');\n    } else {\n      if (typeof arg === 'number' && arg < 0) {\n        x.splice(0, 1);\n      } else {\n        x.pop();\n      }\n    }\n  },\n  $pull: function $pull(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n    var x = target[field];\n    if (x === undefined) {\n      return;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $pull/pullAll modifier to non-array');\n    } else {\n      var out = [];\n      if (arg != null && (typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && !(arg instanceof Array)) {\n        // XXX would be much nicer to compile this once, rather than\n        // for each document we modify.. but usually we're not\n        // modifying that many documents, so we'll let it slide for\n        // now\n\n        // XXX Minimongo.Matcher isn't up for the job, because we need\n        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n        // like {$gt: 4} is not normally a complete selector.\n        // same issue as $elemMatch possibly?\n        var matcher = new _DocumentMatcher2.default(arg);\n        for (var i = 0; i < x.length; i++) {\n          if (!matcher.documentMatches(x[i]).result) {\n            out.push(x[i]);\n          }\n        }\n      } else {\n        for (var i = 0; i < x.length; i++) {\n          if (!_Document.MongoTypeComp._equal(x[i], arg)) {\n            out.push(x[i]);\n          }\n        }\n      }\n      target[field] = out;\n    }\n  },\n  $pullAll: function $pullAll(target, field, arg) {\n    if (!((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object' && arg instanceof Array)) {\n      throw new Error('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n    if (target === undefined) {\n      return;\n    }\n    var x = target[field];\n    if (x === undefined) {\n      return;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $pull/pullAll modifier to non-array');\n    } else {\n      var out = [];\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n        for (var j = 0; j < arg.length; j++) {\n          if (_Document.MongoTypeComp._equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n        if (!exclude) {\n          out.push(x[i]);\n        }\n      }\n      target[field] = out;\n    }\n  },\n  $rename: function $rename(target, field, arg, keypath, doc) {\n    if (keypath === arg) {\n      // no idea why mongo has this restriction..\n      throw new Error('$rename source must differ from target');\n    }\n    if (target === null) {\n      throw new Error('$rename source field invalid');\n    }\n    if (typeof arg !== 'string') {\n      throw new Error('$rename target must be a string');\n    }\n    if (target === undefined) {\n      return;\n    }\n    var v = target[field];\n    delete target[field];\n\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, { forbidArray: true });\n    if (target2 === null) {\n      throw new Error('$rename target field invalid');\n    }\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function $bit(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw new Error('$bit is not supported');\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/Random.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getBrowserSeeds = _getBrowserSeeds;\n\nvar _try2 = require('fast.js/function/try');\n\nvar _try3 = _interopRequireDefault(_try2);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Intarnals\nvar _defaultRandomGenerator = undefined;\nvar RANDOM_GENERATOR_TYPE = {\n  NODE_CRYPTO: 'NODE_CRYPTO',\n  BROWSER_CRYPTO: 'BROWSER_CRYPTO',\n  ALEA: 'ALEA'\n};\nvar UNMISTAKABLE_CHARS = '23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz';\nvar BASE64_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' + '0123456789-_';\n\n// see http://baagoe.org/en/wiki/Better_random_numbers_for_javascript\n// for a full discussion and Alea implementation.\nvar Alea = function Alea() {\n  function Mash() {\n    var n = 0xefc8249d;\n\n    var mash = function mash(data) {\n      data = data.toString();\n      for (var i = 0; i < data.length; i++) {\n        n += data.charCodeAt(i);\n        var h = 0.02519603282416938 * n;\n        n = h >>> 0;\n        h -= n;\n        h *= n;\n        n = h >>> 0;\n        h -= n;\n        n += h * 0x100000000; // 2^32\n      }\n      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n    };\n\n    mash.version = 'Mash 0.9';\n    return mash;\n  }\n\n  return function (args) {\n    var s0 = 0;\n    var s1 = 0;\n    var s2 = 0;\n    var c = 1;\n\n    if (args.length == 0) {\n      args = [+new Date()];\n    }\n    var mash = Mash();\n    s0 = mash(' ');\n    s1 = mash(' ');\n    s2 = mash(' ');\n\n    for (var i = 0; i < args.length; i++) {\n      s0 -= mash(args[i]);\n      if (s0 < 0) {\n        s0 += 1;\n      }\n      s1 -= mash(args[i]);\n      if (s1 < 0) {\n        s1 += 1;\n      }\n      s2 -= mash(args[i]);\n      if (s2 < 0) {\n        s2 += 1;\n      }\n    }\n    mash = null;\n\n    var random = function random() {\n      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n      s0 = s1;\n      s1 = s2;\n      return s2 = t - (c = t | 0);\n    };\n    random.uint32 = function () {\n      return random() * 0x100000000; // 2^32\n    };\n    random.fract53 = function () {\n      return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n    };\n    random.version = 'Alea 0.9';\n    random.args = args;\n    return random;\n  }(Array.prototype.slice.call(arguments));\n};\n\n/**\n * Create seeds array for a browser based on window sizes,\n * Date and some random number.\n * @return {Arrat}\n */\nfunction _getBrowserSeeds() {\n  var height = typeof window !== 'undefined' && window.innerHeight || typeof document !== 'undefined' && document.documentElement && document.documentElement.clientHeight || typeof document !== 'undefined' && document.body && document.body.clientHeight || 1;\n\n  var width = typeof window !== 'undefined' && window.innerWidth || typeof document !== 'undefined' && document.documentElement && document.documentElement.clientWidth || typeof document !== 'undefined' && document.body && document.body.clientWidth || 1;\n\n  var agent = typeof navigator !== 'undefined' && navigator.userAgent || '';\n  return [new Date(), height, width, agent, Math.random()];\n}\n\n/**\n * Random string generator copied from Meteor\n * with minor modifications and refactoring.\n */\n\nvar Random = function () {\n  function Random(type) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, Random);\n\n    this.type = type;\n\n    (0, _invariant2.default)(RANDOM_GENERATOR_TYPE[type], 'Random(...): no generator type %s', type);\n\n    if (type === RANDOM_GENERATOR_TYPE.ALEA) {\n      (0, _invariant2.default)(options.seeds, 'Random(...): seed is not provided for ALEA seeded generator');\n      this.alea = Alea.apply(null, options.seeds);\n    }\n  }\n\n  _createClass(Random, [{\n    key: 'fraction',\n    value: function fraction() {\n      if (this.type === RANDOM_GENERATOR_TYPE.ALEA) {\n        return this.alea();\n      } else if (this.type === RANDOM_GENERATOR_TYPE.NODE_CRYPTO) {\n        var numerator = parseInt(this.hexString(8), 16);\n        return numerator * 2.3283064365386963e-10; // 2^-32\n      } else if (this.type === RANDOM_GENERATOR_TYPE.BROWSER_CRYPTO) {\n          var array = new Uint32Array(1);\n          window.crypto.getRandomValues(array);\n          return array[0] * 2.3283064365386963e-10; // 2^-32\n        } else {\n            throw new Error('Unknown random generator type: ' + this.type);\n          }\n    }\n  }, {\n    key: 'hexString',\n    value: function hexString(digits) {\n      if (this.type === RANDOM_GENERATOR_TYPE.NODE_CRYPTO) {\n        var _ret = function () {\n          var nodeCrypto = require('crypto');\n          var numBytes = Math.ceil(digits / 2);\n\n          // Try to get cryptographically strong randomness. Fall back to\n          // non-cryptographically strong if not available.\n          var bytes = (0, _try3.default)(function () {\n            return nodeCrypto.randomBytes(numBytes);\n          });\n          if (bytes instanceof Error) {\n            bytes = nodeCrypto.pseudoRandomBytes(numBytes);\n          }\n\n          var result = bytes.toString('hex');\n          // If the number of digits is odd, we'll have generated an extra 4 bits\n          // of randomness, so we need to trim the last digit.\n          return {\n            v: result.substring(0, digits)\n          };\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      } else {\n        return this._randomString(digits, '0123456789abcdef');\n      }\n    }\n  }, {\n    key: '_randomString',\n    value: function _randomString(charsCount, alphabet) {\n      var digits = [];\n      for (var i = 0; i < charsCount; i++) {\n        digits[i] = this.choice(alphabet);\n      }\n      return digits.join('');\n    }\n  }, {\n    key: 'id',\n    value: function id(charsCount) {\n      // 17 characters is around 96 bits of entropy, which is the amount of\n      // state in the Alea PRNG.\n      if (charsCount === undefined) {\n        charsCount = 17;\n      }\n      return this._randomString(charsCount, UNMISTAKABLE_CHARS);\n    }\n  }, {\n    key: 'secret',\n    value: function secret(charsCount) {\n      // Default to 256 bits of entropy, or 43 characters at 6 bits per\n      // character.\n      if (charsCount === undefined) {\n        charsCount = 43;\n      }\n      return this._randomString(charsCount, BASE64_CHARS);\n    }\n  }, {\n    key: 'choice',\n    value: function choice(arrayOrString) {\n      var index = Math.floor(this.fraction() * arrayOrString.length);\n      if (typeof arrayOrString === 'string') {\n        return arrayOrString.substr(index, 1);\n      } else {\n        return arrayOrString[index];\n      }\n    }\n  }], [{\n    key: 'default',\n    value: function _default() {\n      if (!_defaultRandomGenerator) {\n        if (typeof window !== 'undefined') {\n          if (window.crypto && window.crypto.getRandomValues) {\n            return new Random(RANDOM_GENERATOR_TYPE.BROWSER_CRYPTO);\n          } else {\n            return new Random(RANDOM_GENERATOR_TYPE.ALEA, { seeds: _getBrowserSeeds() });\n          }\n        } else {\n          return new Random(RANDOM_GENERATOR_TYPE.NODE_CRYPTO);\n        }\n      }\n      return _defaultRandomGenerator;\n    }\n  }, {\n    key: 'createWithSeeds',\n    value: function createWithSeeds() {\n      (0, _invariant2.default)(arguments.length, 'Random.createWithSeeds(...): no seeds were provided');\n\n      return new Random(RANDOM_GENERATOR_TYPE.ALEA, { seeds: arguments });\n    }\n  }]);\n\n  return Random;\n}();\n\nexports.default = Random;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/DocumentMatcher.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ELEMENT_OPERATORS = exports.DocumentMatcher = undefined;\nexports.regexpElementMatcher = regexpElementMatcher;\nexports.equalityElementMatcher = equalityElementMatcher;\nexports.makeLookupFunction = makeLookupFunction;\nexports.expandArraysInBranches = expandArraysInBranches;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _some2 = require('fast.js/array/some');\n\nvar _some3 = _interopRequireDefault(_some2);\n\nvar _every2 = require('fast.js/array/every');\n\nvar _every3 = _interopRequireDefault(_every2);\n\nvar _indexOf2 = require('fast.js/array/indexOf');\n\nvar _indexOf3 = _interopRequireDefault(_indexOf2);\n\nvar _geojsonUtils = require('geojson-utils');\n\nvar _geojsonUtils2 = _interopRequireDefault(_geojsonUtils);\n\nvar _EJSON = require('./EJSON');\n\nvar _EJSON2 = _interopRequireDefault(_EJSON);\n\nvar _Document = require('./Document');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// The minimongo selector compiler!\n\n// Terminology:\n//  - a 'selector' is the EJSON object representing a selector\n//  - a 'matcher' is its compiled form (whether a full Minimongo.Matcher\n//    object or one of the component lambdas that matches parts of it)\n//  - a 'result object' is an object with a 'result' field and maybe\n//    distance and arrayIndices.\n//  - a 'branched value' is an object with a 'value' field and maybe\n//    'dontIterate' and 'arrayIndices'.\n//  - a 'document' is a top-level object that can be stored in a collection.\n//  - a 'lookup function' is a function that takes in a document and returns\n//    an array of 'branched values'.\n//  - a 'branched matcher' maps from an array of branched values to a result\n//    object.\n//  - an 'element matcher' maps from a single value to a bool.\n\n// Main entry point.\n//   var matcher = new Minimongo.Matcher({a: {$gt: 5}});\n//   if (matcher.documentMatches({a: 7})) ...\n\nvar DocumentMatcher = exports.DocumentMatcher = function () {\n  function DocumentMatcher(selector) {\n    _classCallCheck(this, DocumentMatcher);\n\n    // A set (object mapping string -> *) of all of the document paths looked\n    // at by the selector. Also includes the empty string if it may look at any\n    // path (eg, $where).\n    this._paths = {};\n    // Set to true if compilation finds a $near.\n    this._hasGeoQuery = false;\n    // Set to true if compilation finds a $where.\n    this._hasWhere = false;\n    // Set to false if compilation finds anything other than a simple equality or\n    // one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used with\n    // scalars as operands.\n    this._isSimple = true;\n    // Set to a dummy document which always matches this Matcher. Or set to null\n    // if such document is too hard to find.\n    this._matchingDocument = undefined;\n    // A clone of the original selector. It may just be a function if the user\n    // passed in a function; otherwise is definitely an object (eg, IDs are\n    // translated into {_id: ID} first. Used by canBecomeTrueByModifier and\n    // Sorter._useWithMatcher.\n    this._selector = null;\n    this._docMatcher = this._compileSelector(selector);\n  }\n\n  _createClass(DocumentMatcher, [{\n    key: 'documentMatches',\n    value: function documentMatches(doc) {\n      if (!doc || (typeof doc === 'undefined' ? 'undefined' : _typeof(doc)) !== 'object') {\n        throw Error('documentMatches needs a document');\n      }\n      return this._docMatcher(doc);\n    }\n  }, {\n    key: '_compileSelector',\n\n    // Given a selector, return a function that takes one argument, a\n    // document. It returns a result object.\n    value: function _compileSelector(selector) {\n      // you can pass a literal function instead of a selector\n      if (selector instanceof Function) {\n        this._isSimple = false;\n        this._selector = selector;\n        this._recordPathUsed('');\n        return function (doc) {\n          return { result: !!selector.call(doc) };\n        };\n      }\n\n      // shorthand -- scalars match _id\n      if ((0, _Document.selectorIsId)(selector)) {\n        this._selector = { _id: selector };\n        this._recordPathUsed('_id');\n        return function (doc) {\n          return { result: _EJSON2.default.equals(doc._id, selector) };\n        };\n      }\n\n      // protect against dangerous selectors.  falsey and {_id: falsey} are both\n      // likely programmer error, and not what you want, particularly for\n      // destructive operations.\n      if (!selector || '_id' in selector && !selector._id) {\n        this._isSimple = false;\n        return nothingMatcher;\n      }\n\n      // Top level can't be an array or true or binary.\n      if (typeof selector === 'boolean' || (0, _Document.isArray)(selector) || _EJSON2.default.isBinary(selector)) {\n        throw new Error('Invalid selector: ' + selector);\n      }\n\n      this._selector = _EJSON2.default.clone(selector);\n      return compileDocumentSelector(selector, this, { isRoot: true });\n    }\n  }, {\n    key: '_recordPathUsed',\n    value: function _recordPathUsed(path) {\n      this._paths[path] = true;\n    }\n\n    // Returns a list of key paths the given selector is looking for. It includes\n    // the empty string if there is a $where.\n\n  }, {\n    key: '_getPaths',\n    value: function _getPaths() {\n      return _checkTypes2.default.object(this._paths) ? (0, _keys3.default)(this._paths) : null;\n    }\n  }, {\n    key: 'hasGeoQuery',\n    get: function get() {\n      return this._hasGeoQuery;\n    }\n  }, {\n    key: 'hasWhere',\n    get: function get() {\n      return this._hasWhere;\n    }\n  }, {\n    key: 'isSimple',\n    get: function get() {\n      return this._isSimple;\n    }\n  }]);\n\n  return DocumentMatcher;\n}();\n\nexports.default = DocumentMatcher;\n\n// Takes in a selector that could match a full document (eg, the original\n// selector). Returns a function mapping document->result object.\n//\n// matcher is the Matcher object we are compiling.\n//\n// If this is the root document selector (ie, not wrapped in $and or the like),\n// then isRoot is true. (This is used by $near.)\n\nvar compileDocumentSelector = function compileDocumentSelector(docSelector, matcher) {\n  var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n  var docMatchers = [];\n  (0, _forEach2.default)(docSelector, function (subSelector, key) {\n    if (key.substr(0, 1) === '$') {\n      // Outer operators are either logical operators (they recurse back into\n      // this function), or $where.\n      if (!LOGICAL_OPERATORS.hasOwnProperty(key)) {\n        throw new Error('Unrecognized logical operator: ' + key);\n      }\n      matcher._isSimple = false;\n      docMatchers.push(LOGICAL_OPERATORS[key](subSelector, matcher, options.inElemMatch));\n    } else {\n      // Record this path, but only if we aren't in an elemMatcher, since in an\n      // elemMatch this is a path inside an object in an array, not in the doc\n      // root.\n      if (!options.inElemMatch) {\n        matcher._recordPathUsed(key);\n      }\n      var lookUpByIndex = makeLookupFunction(key);\n      var valueMatcher = compileValueSelector(subSelector, matcher, options.isRoot);\n      docMatchers.push(function (doc) {\n        var branchValues = lookUpByIndex(doc);\n        return valueMatcher(branchValues);\n      });\n    }\n  });\n\n  return andDocumentMatchers(docMatchers);\n};\n\n// Takes in a selector that could match a key-indexed value in a document; eg,\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\n// indicate equality).  Returns a branched matcher: a function mapping\n// [branched value]->result object.\nvar compileValueSelector = function compileValueSelector(valueSelector, matcher, isRoot) {\n  if (valueSelector instanceof RegExp) {\n    matcher._isSimple = false;\n    return convertElementMatcherToBranchedMatcher(regexpElementMatcher(valueSelector));\n  } else if ((0, _Document.isOperatorObject)(valueSelector)) {\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);\n  } else {\n    return convertElementMatcherToBranchedMatcher(equalityElementMatcher(valueSelector));\n  }\n};\n\n// Given an element matcher (which evaluates a single value), returns a branched\n// value (which evaluates the element matcher on all the branches and returns a\n// more structured return value possibly including arrayIndices).\nvar convertElementMatcherToBranchedMatcher = function convertElementMatcherToBranchedMatcher(elementMatcher) {\n  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  return function (branches) {\n    var expanded = branches;\n    if (!options.dontExpandLeafArrays) {\n      expanded = expandArraysInBranches(branches, options.dontIncludeLeafArrays);\n    }\n    var ret = {};\n    ret.result = (0, _some3.default)(expanded, function (element) {\n      var matched = elementMatcher(element.value);\n\n      // Special case for $elemMatch: it means 'true, and use this as an array\n      // index if I didn't already have one'.\n      if (typeof matched === 'number') {\n        // XXX This code dates from when we only stored a single array index\n        // (for the outermost array). Should we be also including deeper array\n        // indices from the $elemMatch match?\n        if (!element.arrayIndices) {\n          element.arrayIndices = [matched];\n        }\n        matched = true;\n      }\n\n      // If some element matched, and it's tagged with array indices, include\n      // those indices in our result object.\n      if (matched && element.arrayIndices) {\n        ret.arrayIndices = element.arrayIndices;\n      }\n\n      return matched;\n    });\n    return ret;\n  };\n};\n\n// Takes a RegExp object and returns an element matcher.\nfunction regexpElementMatcher(regexp) {\n  return function (value) {\n    if (value instanceof RegExp) {\n      // Comparing two regexps means seeing if the regexps are identical\n      // (really!). Underscore knows how.\n      return String(value) === String(regexp);\n    }\n    // Regexps only work against strings.\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    // Reset regexp's state to avoid inconsistent matching for objects with the\n    // same value on consecutive calls of regexp.test. This happens only if the\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\n    // which we should *not* change the lastIndex but MongoDB doesn't support\n    // either of these flags.\n    regexp.lastIndex = 0;\n\n    return regexp.test(value);\n  };\n}\n\n// Takes something that is not an operator object and returns an element matcher\n// for equality with that thing.\nfunction equalityElementMatcher(elementSelector) {\n  if ((0, _Document.isOperatorObject)(elementSelector)) {\n    throw Error('Can\\'t create equalityValueSelector for operator object');\n  }\n\n  // Special-case: null and undefined are equal (if you got undefined in there\n  // somewhere, or if you got it due to some branch being non-existent in the\n  // weird special case), even though they aren't with EJSON.equals.\n  if (elementSelector == null) {\n    // undefined or null\n    return function (value) {\n      return value == null; // undefined or null\n    };\n  }\n\n  return function (value) {\n    return _Document.MongoTypeComp._equal(elementSelector, value);\n  };\n}\n\n// Takes an operator object (an object with $ keys) and returns a branched\n// matcher for it.\nvar operatorBranchedMatcher = function operatorBranchedMatcher(valueSelector, matcher, isRoot) {\n  // Each valueSelector works separately on the various branches.  So one\n  // operator can match one branch and another can match another branch.  This\n  // is OK.\n\n  var operatorMatchers = [];\n  (0, _forEach2.default)(valueSelector, function (operand, operator) {\n    // XXX we should actually implement $eq, which is new in 2.6\n    var simpleRange = (0, _indexOf3.default)(['$lt', '$lte', '$gt', '$gte'], operator) >= 0 && _checkTypes2.default.number(operand);\n    var simpleInequality = operator === '$ne' && !_checkTypes2.default.object(operand);\n    var simpleInclusion = (0, _indexOf3.default)(['$in', '$nin'], operator) >= 0 && _checkTypes2.default.array(operand) && !(0, _some3.default)(operand, _checkTypes2.default.object);\n\n    if (!(operator === '$eq' || simpleRange || simpleInclusion || simpleInequality)) {\n      matcher._isSimple = false;\n    }\n\n    if (VALUE_OPERATORS.hasOwnProperty(operator)) {\n      operatorMatchers.push(VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot));\n    } else if (ELEMENT_OPERATORS.hasOwnProperty(operator)) {\n      var options = ELEMENT_OPERATORS[operator];\n      operatorMatchers.push(convertElementMatcherToBranchedMatcher(options.compileElementSelector(operand, valueSelector, matcher), options));\n    } else {\n      throw new Error('Unrecognized operator: ' + operator);\n    }\n  });\n\n  return andBranchedMatchers(operatorMatchers);\n};\n\nvar compileArrayOfDocumentSelectors = function compileArrayOfDocumentSelectors(selectors, matcher, inElemMatch) {\n  if (!(0, _Document.isArray)(selectors) || _checkTypes2.default.emptyArray(selectors)) {\n    throw Error('$and/$or/$nor must be nonempty array');\n  }\n  return (0, _map3.default)(selectors, function (subSelector) {\n    if (!(0, _Document.isPlainObject)(subSelector)) {\n      throw Error('$or/$and/$nor entries need to be full objects');\n    }\n    return compileDocumentSelector(subSelector, matcher, { inElemMatch: inElemMatch });\n  });\n};\n\n// Operators that appear at the top level of a document selector.\nvar LOGICAL_OPERATORS = {\n  $and: function $and(subSelector, matcher, inElemMatch) {\n    var matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch);\n    return andDocumentMatchers(matchers);\n  },\n\n  $or: function $or(subSelector, matcher, inElemMatch) {\n    var matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch);\n\n    // Special case: if there is only one matcher, use it directly, *preserving*\n    // any arrayIndices it returns.\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n\n    return function (doc) {\n      var result = (0, _some3.default)(matchers, function (f) {\n        return f(doc).result;\n      });\n      // $or does NOT set arrayIndices when it has multiple\n      // sub-expressions. (Tested against MongoDB.)\n      return { result: result };\n    };\n  },\n\n  $nor: function $nor(subSelector, matcher, inElemMatch) {\n    var matchers = compileArrayOfDocumentSelectors(subSelector, matcher, inElemMatch);\n    return function (doc) {\n      var result = (0, _every3.default)(matchers, function (f) {\n        return !f(doc).result;\n      });\n      // Never set arrayIndices, because we only match if nothing in particular\n      // 'matched' (and because this is consistent with MongoDB).\n      return { result: result };\n    };\n  },\n\n  $where: function $where(selectorValue, matcher) {\n    // Record that *any* path may be used.\n    matcher._recordPathUsed('');\n    matcher._hasWhere = true;\n    if (!(selectorValue instanceof Function)) {\n      // XXX MongoDB seems to have more complex logic to decide where or or not\n      // to add 'return'; not sure exactly what it is.\n      selectorValue = Function('obj', 'return ' + selectorValue); //eslint-disable-line no-new-func\n    }\n    return function (doc) {\n      // We make the document available as both `this` and `obj`.\n      // XXX not sure what we should do if this throws\n      return { result: selectorValue.call(doc, doc) };\n    };\n  },\n\n  // This is just used as a comment in the query (in MongoDB, it also ends up in\n  // query logs); it has no effect on the actual selection.\n  $comment: function $comment() {\n    return function () {\n      return { result: true };\n    };\n  }\n};\n\n// Returns a branched matcher that matches iff the given matcher does not.\n// Note that this implicitly 'deMorganizes' the wrapped function.  ie, it\n// means that ALL branch values need to fail to match innerBranchedMatcher.\nvar invertBranchedMatcher = function invertBranchedMatcher(branchedMatcher) {\n  return function (branchValues) {\n    var invertMe = branchedMatcher(branchValues);\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to\n    // say 'update the array element that does not match something', at least\n    // in mongo-land.\n    return { result: !invertMe.result };\n  };\n};\n\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\n// 'match each branched value independently and combine with\n// convertElementMatcherToBranchedMatcher'.\nvar VALUE_OPERATORS = {\n  $not: function $not(operand, valueSelector, matcher) {\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));\n  },\n  $ne: function $ne(operand) {\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(equalityElementMatcher(operand)));\n  },\n  $nin: function $nin(operand) {\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(ELEMENT_OPERATORS.$in.compileElementSelector(operand)));\n  },\n  $exists: function $exists(operand) {\n    var exists = convertElementMatcherToBranchedMatcher(function (value) {\n      return value !== undefined;\n    });\n    return operand ? exists : invertBranchedMatcher(exists);\n  },\n  // $options just provides options for $regex; its logic is inside $regex\n  $options: function $options(operand, valueSelector) {\n    if (!_checkTypes2.default.object(valueSelector) || !valueSelector.hasOwnProperty('$regex')) {\n      throw Error('$options needs a $regex');\n    }\n    return everythingMatcher;\n  },\n  // $maxDistance is basically an argument to $near\n  $maxDistance: function $maxDistance(operand, valueSelector) {\n    if (!valueSelector.$near) {\n      throw Error('$maxDistance needs a $near');\n    }\n    return everythingMatcher;\n  },\n  $all: function $all(operand, valueSelector, matcher) {\n    if (!(0, _Document.isArray)(operand)) {\n      throw Error('$all requires array');\n    }\n    // Not sure why, but this seems to be what MongoDB does.\n    if (_checkTypes2.default.emptyArray(operand)) {\n      return nothingMatcher;\n    }\n\n    var branchedMatchers = [];\n    (0, _forEach2.default)(operand, function (criterion) {\n      // XXX handle $all/$elemMatch combination\n      if ((0, _Document.isOperatorObject)(criterion)) {\n        throw Error('no $ expressions in $all');\n      }\n      // This is always a regexp or equality selector.\n      branchedMatchers.push(compileValueSelector(criterion, matcher));\n    });\n    // andBranchedMatchers does NOT require all selectors to return true on the\n    // SAME branch.\n    return andBranchedMatchers(branchedMatchers);\n  },\n  $near: function $near(operand, valueSelector, matcher, isRoot) {\n    if (!isRoot) {\n      throw Error('$near can\\'t be inside another $ operator');\n    }\n    matcher._hasGeoQuery = true;\n\n    // There are two kinds of geodata in MongoDB: coordinate pairs and\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are\n    // marked with a $geometry property.\n\n    var maxDistance, point, distance;\n    if ((0, _Document.isPlainObject)(operand) && operand.hasOwnProperty('$geometry')) {\n      // GeoJSON '2dsphere' mode.\n      maxDistance = operand.$maxDistance;\n      point = operand.$geometry;\n      distance = function distance(value) {\n        // XXX: for now, we don't calculate the actual distance between, say,\n        // polygon and circle. If people care about this use-case it will get\n        // a priority.\n        if (!value || !value.type) {\n          return null;\n        }\n        if (value.type === 'Point') {\n          return _geojsonUtils2.default.pointDistance(point, value);\n        } else {\n          return _geojsonUtils2.default.geometryWithinRadius(value, point, maxDistance) ? 0 : maxDistance + 1;\n        }\n      };\n    } else {\n      maxDistance = valueSelector.$maxDistance;\n      if (!(0, _Document.isArray)(operand) && !(0, _Document.isPlainObject)(operand)) {\n        throw Error('$near argument must be coordinate pair or GeoJSON');\n      }\n      point = pointToArray(operand);\n      distance = function distance(value) {\n        if (!(0, _Document.isArray)(value) && !(0, _Document.isPlainObject)(value)) {\n          return null;\n        }\n        return distanceCoordinatePairs(point, value);\n      };\n    }\n\n    return function (branchedValues) {\n      // There might be multiple points in the document that match the given\n      // field. Only one of them needs to be within $maxDistance, but we need to\n      // evaluate all of them and use the nearest one for the implicit sort\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\n      //\n      // Note: This differs from MongoDB's implementation, where a document will\n      // actually show up *multiple times* in the result set, with one entry for\n      // each within-$maxDistance branching point.\n      branchedValues = expandArraysInBranches(branchedValues);\n      var result = { result: false };\n      (0, _forEach2.default)(branchedValues, function (branch) {\n        var curDistance = distance(branch.value);\n        // Skip branches that aren't real points or are too far away.\n        if (curDistance === null || curDistance > maxDistance) {\n          return;\n        }\n        // Skip anything that's a tie.\n        if (result.distance !== undefined && result.distance <= curDistance) {\n          return;\n        }\n        result.result = true;\n        result.distance = curDistance;\n        if (!branch.arrayIndices) {\n          delete result.arrayIndices;\n        } else {\n          result.arrayIndices = branch.arrayIndices;\n        }\n      });\n      return result;\n    };\n  }\n};\n\n// Helpers for $near.\nvar distanceCoordinatePairs = function distanceCoordinatePairs(a, b) {\n  a = pointToArray(a);\n  b = pointToArray(b);\n  var x = a[0] - b[0];\n  var y = a[1] - b[1];\n  if (!_checkTypes2.default.number(x) || !_checkTypes2.default.number(y)) {\n    return null;\n  }\n  return Math.sqrt(x * x + y * y);\n};\n\n// Makes sure we get 2 elements array and assume the first one to be x and\n// the second one to y no matter what user passes.\n// In case user passes { lon: x, lat: y } returns [x, y]\nvar pointToArray = function pointToArray(point) {\n  return (0, _map3.default)(point, function (x) {\n    return x;\n  });\n};\n\n// Helper for $lt/$gt/$lte/$gte.\nvar makeInequality = function makeInequality(cmpValueComparator) {\n  return {\n    compileElementSelector: function compileElementSelector(operand) {\n      // Arrays never compare false with non-arrays for any inequality.\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but\n      //     it seems to have been reverted.\n      //     See https://jira.mongodb.org/browse/SERVER-11444\n      if ((0, _Document.isArray)(operand)) {\n        return function () {\n          return false;\n        };\n      }\n\n      // Special case: consider undefined and null the same (so true with\n      // $gte/$lte).\n      if (operand === undefined) {\n        operand = null;\n      }\n\n      var operandType = _Document.MongoTypeComp._type(operand);\n\n      return function (value) {\n        if (value === undefined) {\n          value = null;\n        }\n        // Comparisons are never true among things of different type (except\n        // null vs undefined).\n        if (_Document.MongoTypeComp._type(value) !== operandType) {\n          return false;\n        }\n        return cmpValueComparator(_Document.MongoTypeComp._cmp(value, operand));\n      };\n    }\n  };\n};\n\n// Each element selector contains:\n//  - compileElementSelector, a function with args:\n//    - operand - the 'right hand side' of the operator\n//    - valueSelector - the 'context' for the operator (so that $regex can find\n//      $options)\n//    - matcher - the Matcher this is going into (so that $elemMatch can compile\n//      more things)\n//    returning a function mapping a single value to bool.\n//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from\n//    being called\n//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to\n//    expandArraysInBranches if it is called\nvar ELEMENT_OPERATORS = exports.ELEMENT_OPERATORS = {\n  $lt: makeInequality(function (cmpValue) {\n    return cmpValue < 0;\n  }),\n  $gt: makeInequality(function (cmpValue) {\n    return cmpValue > 0;\n  }),\n  $lte: makeInequality(function (cmpValue) {\n    return cmpValue <= 0;\n  }),\n  $gte: makeInequality(function (cmpValue) {\n    return cmpValue >= 0;\n  }),\n  $mod: {\n    compileElementSelector: function compileElementSelector(operand) {\n      if (!((0, _Document.isArray)(operand) && operand.length === 2 && typeof operand[0] === 'number' && typeof operand[1] === 'number')) {\n        throw Error('argument to $mod must be an array of two numbers');\n      }\n      // XXX could require to be ints or round or something\n      var divisor = operand[0];\n      var remainder = operand[1];\n      return function (value) {\n        return typeof value === 'number' && value % divisor === remainder;\n      };\n    }\n  },\n  $in: {\n    compileElementSelector: function compileElementSelector(operand) {\n      if (!(0, _Document.isArray)(operand)) {\n        throw Error('$in needs an array');\n      }\n\n      var elementMatchers = [];\n      (0, _forEach2.default)(operand, function (option) {\n        if (option instanceof RegExp) {\n          elementMatchers.push(regexpElementMatcher(option));\n        } else if ((0, _Document.isOperatorObject)(option)) {\n          throw Error('cannot nest $ under $in');\n        } else {\n          elementMatchers.push(equalityElementMatcher(option));\n        }\n      });\n\n      return function (value) {\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.\n        if (value === undefined) {\n          value = null;\n        }\n        return (0, _some3.default)(elementMatchers, function (e) {\n          return e(value);\n        });\n      };\n    }\n  },\n  $size: {\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\n    // possible value.\n    dontExpandLeafArrays: true,\n    compileElementSelector: function compileElementSelector(operand) {\n      if (typeof operand === 'string') {\n        // Don't ask me why, but by experimentation, this seems to be what Mongo\n        // does.\n        operand = 0;\n      } else if (typeof operand !== 'number') {\n        throw Error('$size needs a number');\n      }\n      return function (value) {\n        return (0, _Document.isArray)(value) && value.length === operand;\n      };\n    }\n  },\n  $type: {\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\n    // should *not* include it itself.\n    dontIncludeLeafArrays: true,\n    compileElementSelector: function compileElementSelector(operand) {\n      if (typeof operand !== 'number') {\n        throw Error('$type needs a number');\n      }\n      return function (value) {\n        return value !== undefined && _Document.MongoTypeComp._type(value) === operand;\n      };\n    }\n  },\n  $regex: {\n    compileElementSelector: function compileElementSelector(operand, valueSelector) {\n      if (!(typeof operand === 'string' || operand instanceof RegExp)) {\n        throw Error('$regex has to be a string or RegExp');\n      }\n\n      var regexp;\n      if (valueSelector.$options !== undefined) {\n        // Options passed in $options (even the empty string) always overrides\n        // options in the RegExp object itself. (See also\n        // Mongo.Collection._rewriteSelector.)\n\n        // Be clear that we only support the JS-supported options, not extended\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n        // by transforming the regexp, but not today...\n        if (/[^gim]/.test(valueSelector.$options)) {\n          throw new Error('Only the i, m, and g regexp options are supported');\n        }\n\n        var regexSource = operand instanceof RegExp ? operand.source : operand;\n        regexp = new RegExp(regexSource, valueSelector.$options);\n      } else if (operand instanceof RegExp) {\n        regexp = operand;\n      } else {\n        regexp = new RegExp(operand);\n      }\n      return regexpElementMatcher(regexp);\n    }\n  },\n  $elemMatch: {\n    dontExpandLeafArrays: true,\n    compileElementSelector: function compileElementSelector(operand, valueSelector, matcher) {\n      if (!(0, _Document.isPlainObject)(operand)) {\n        throw Error('$elemMatch need an object');\n      }\n\n      var subMatcher, isDocMatcher;\n      if ((0, _Document.isOperatorObject)(operand, true)) {\n        subMatcher = compileValueSelector(operand, matcher);\n        isDocMatcher = false;\n      } else {\n        // This is NOT the same as compileValueSelector(operand), and not just\n        // because of the slightly different calling convention.\n        // {$elemMatch: {x: 3}} means 'an element has a field x:3', not\n        // 'consists only of a field x:3'. Also, regexps and sub-$ are allowed.\n        subMatcher = compileDocumentSelector(operand, matcher, { inElemMatch: true });\n        isDocMatcher = true;\n      }\n\n      return function (value) {\n        if (!(0, _Document.isArray)(value)) {\n          return false;\n        }\n        for (var i = 0; i < value.length; ++i) {\n          var arrayElement = value[i];\n          var arg;\n          if (isDocMatcher) {\n            // We can only match {$elemMatch: {b: 3}} against objects.\n            // (We can also match against arrays, if there's numeric indices,\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\n            if (!(0, _Document.isPlainObject)(arrayElement) && !(0, _Document.isArray)(arrayElement)) {\n              return false;\n            }\n            arg = arrayElement;\n          } else {\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\n            // {a: [8]} but not {a: [[8]]}\n            arg = [{ value: arrayElement, dontIterate: true }];\n          }\n          // XXX support $near in $elemMatch by propagating $distance?\n          if (subMatcher(arg).result) {\n            return i; // specially understood to mean 'use as arrayIndices'\n          }\n        }\n        return false;\n      };\n    }\n  }\n};\n\n// makeLookupFunction(key) returns a lookup function.\n//\n// A lookup function takes in a document and returns an array of matching\n// branches.  If no arrays are found while looking up the key, this array will\n// have exactly one branches (possibly 'undefined', if some segment of the key\n// was not found).\n//\n// If arrays are found in the middle, this can have more than one element, since\n// we 'branch'. When we 'branch', if there are more key segments to look up,\n// then we only pursue branches that are plain objects (not arrays or scalars).\n// This means we can actually end up with no branches!\n//\n// We do *NOT* branch on arrays that are found at the end (ie, at the last\n// dotted member of the key). We just return that array; if you want to\n// effectively 'branch' over the array's values, post-process the lookup\n// function with expandArraysInBranches.\n//\n// Each branch is an object with keys:\n//  - value: the value at the branch\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array\n//    that expandArraysInBranches should NOT expand. This specifically happens\n//    when there is a numeric index in the key, and ensures the\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\n//    match {a: [[5]]}.\n//  - arrayIndices: if any array indexing was done during lookup (either due to\n//    explicit numeric indices or implicit branching), this will be an array of\n//    the array indices used, from outermost to innermost; it is falsey or\n//    absent if no array index is used. If an explicit numeric index is used,\n//    the index will be followed in arrayIndices by the string 'x'.\n//\n//    Note: arrayIndices is used for two purposes. First, it is used to\n//    implement the '$' modifier feature, which only ever looks at its first\n//    element.\n//\n//    Second, it is used for sort key generation, which needs to be able to tell\n//    the difference between different paths. Moreover, it needs to\n//    differentiate between explicit and implicit branching, which is why\n//    there's the somewhat hacky 'x' entry: this means that explicit and\n//    implicit array lookups will have different full arrayIndices paths. (That\n//    code only requires that different paths have different arrayIndices; it\n//    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\n//    could contain objects with flags like 'implicit', but I think that only\n//    makes the code surrounding them more complex.)\n//\n//    (By the way, this field ends up getting passed around a lot without\n//    cloning, so never mutate any arrayIndices field/var in this package!)\n//\n//\n// At the top level, you may only pass in a plain object or array.\n//\n// See the test 'minimongo - lookup' for some examples of what lookup functions\n// return.\nfunction makeLookupFunction(key, options) {\n  options = options || {};\n  var parts = key.split('.');\n  var firstPart = parts.length ? parts[0] : '';\n  var firstPartIsNumeric = (0, _Document.isNumericKey)(firstPart);\n  var nextPartIsNumeric = parts.length >= 2 && (0, _Document.isNumericKey)(parts[1]);\n  var lookupRest;\n  if (parts.length > 1) {\n    lookupRest = makeLookupFunction(parts.slice(1).join('.'));\n  }\n\n  var omitUnnecessaryFields = function omitUnnecessaryFields(retVal) {\n    if (!retVal.dontIterate) {\n      delete retVal.dontIterate;\n    }\n    if (retVal.arrayIndices && !retVal.arrayIndices.length) {\n      delete retVal.arrayIndices;\n    }\n    return retVal;\n  };\n\n  // Doc will always be a plain object or an array.\n  // apply an explicit numeric index, an array.\n  return function (doc, arrayIndices) {\n    if (!arrayIndices) {\n      arrayIndices = [];\n    }\n\n    if ((0, _Document.isArray)(doc)) {\n      // If we're being asked to do an invalid lookup into an array (non-integer\n      // or out-of-bounds), return no results (which is different from returning\n      // a single undefined result, in that `null` equality checks won't match).\n      if (!(firstPartIsNumeric && firstPart < doc.length)) {\n        return [];\n      }\n\n      // Remember that we used this array index. Include an 'x' to indicate that\n      // the previous index came from being considered as an explicit array\n      // index (not branching).\n      arrayIndices = arrayIndices.concat(+firstPart, 'x');\n    }\n\n    // Do our first lookup.\n    var firstLevel = doc[firstPart];\n\n    // If there is no deeper to dig, return what we found.\n    //\n    // If what we found is an array, most value selectors will choose to treat\n    // the elements of the array as matchable values in their own right, but\n    // that's done outside of the lookup function. (Exceptions to this are $size\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\n    // [[1, 2]]}.)\n    //\n    // That said, if we just did an *explicit* array lookup (on doc) to find\n    // firstLevel, and firstLevel is an array too, we do NOT want value\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\n    // So in that case, we mark the return value as 'don't iterate'.\n    if (!lookupRest) {\n      return [omitUnnecessaryFields({\n        value: firstLevel,\n        dontIterate: (0, _Document.isArray)(doc) && (0, _Document.isArray)(firstLevel),\n        arrayIndices: arrayIndices })];\n    }\n\n    // We need to dig deeper.  But if we can't, because what we've found is not\n    // an array or plain object, we're done. If we just did a numeric index into\n    // an array, we return nothing here (this is a change in Mongo 2.5 from\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\n    // return a single `undefined` (which can, for example, match via equality\n    // with `null`).\n    if (!(0, _Document.isIndexable)(firstLevel)) {\n      if ((0, _Document.isArray)(doc)) {\n        return [];\n      }\n      return [omitUnnecessaryFields({\n        value: undefined,\n        arrayIndices: arrayIndices\n      })];\n    }\n\n    var result = [];\n    var appendToResult = function appendToResult(more) {\n      Array.prototype.push.apply(result, more);\n    };\n\n    // Dig deeper: look up the rest of the parts on whatever we've found.\n    // (lookupRest is smart enough to not try to do invalid lookups into\n    // firstLevel if it's an array.)\n    appendToResult(lookupRest(firstLevel, arrayIndices));\n\n    // If we found an array, then in *addition* to potentially treating the next\n    // part as a literal integer lookup, we should also 'branch': try to look up\n    // the rest of the parts on each array element in parallel.\n    //\n    // In this case, we *only* dig deeper into array elements that are plain\n    // objects. (Recall that we only got this far if we have further to dig.)\n    // This makes sense: we certainly don't dig deeper into non-indexable\n    // objects. And it would be weird to dig into an array: it's simpler to have\n    // a rule that explicit integer indexes only apply to an outer array, not to\n    // an array you find after a branching search.\n    //\n    // In the special case of a numeric part in a *sort selector* (not a query\n    // selector), we skip the branching: we ONLY allow the numeric part to mean\n    // 'look up this index' in that case, not 'also look up this index in all\n    // the elements of the array'.\n    if ((0, _Document.isArray)(firstLevel) && !(nextPartIsNumeric && options.forSort)) {\n      (0, _forEach2.default)(firstLevel, function (branch, arrayIndex) {\n        if ((0, _Document.isPlainObject)(branch)) {\n          appendToResult(lookupRest(branch, arrayIndices.concat(arrayIndex)));\n        }\n      });\n    }\n\n    return result;\n  };\n}\n\nfunction expandArraysInBranches(branches, skipTheArrays) {\n  var branchesOut = [];\n  (0, _forEach2.default)(branches, function (branch) {\n    var thisIsArray = (0, _Document.isArray)(branch.value);\n    // We include the branch itself, *UNLESS* we it's an array that we're going\n    // to iterate and we're told to skip arrays.  (That's right, we include some\n    // arrays even skipTheArrays is true: these are arrays that were found via\n    // explicit numerical indices.)\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\n      branchesOut.push({\n        value: branch.value,\n        arrayIndices: branch.arrayIndices\n      });\n    }\n    if (thisIsArray && !branch.dontIterate) {\n      (0, _forEach2.default)(branch.value, function (leaf, i) {\n        branchesOut.push({\n          value: leaf,\n          arrayIndices: (branch.arrayIndices || []).concat(i)\n        });\n      });\n    }\n  });\n  return branchesOut;\n}\n\nvar nothingMatcher = function nothingMatcher(docOrBranchedValues) {\n  return { result: false };\n};\n\nvar everythingMatcher = function everythingMatcher(docOrBranchedValues) {\n  return { result: true };\n};\n\n// NB: We are cheating and using this function to implement 'AND' for both\n// 'document matchers' and 'branched matchers'. They both return result objects\n// but the argument is different: for the former it's a whole doc, whereas for\n// the latter it's an array of 'branched values'.\nvar andSomeMatchers = function andSomeMatchers(subMatchers) {\n  if (subMatchers.length === 0) {\n    return everythingMatcher;\n  }\n  if (subMatchers.length === 1) {\n    return subMatchers[0];\n  }\n\n  return function (docOrBranches) {\n    var ret = {};\n    ret.result = (0, _every3.default)(subMatchers, function (f) {\n      var subResult = f(docOrBranches);\n      // Copy a 'distance' number out of the first sub-matcher that has\n      // one. Yes, this means that if there are multiple $near fields in a\n      // query, something arbitrary happens; this appears to be consistent with\n      // Mongo.\n      if (subResult.result && subResult.distance !== undefined && ret.distance === undefined) {\n        ret.distance = subResult.distance;\n      }\n      // Similarly, propagate arrayIndices from sub-matchers... but to match\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\n      // wins.\n      if (subResult.result && subResult.arrayIndices) {\n        ret.arrayIndices = subResult.arrayIndices;\n      }\n      return subResult.result;\n    });\n\n    // If we didn't actually match, forget any extra metadata we came up with.\n    if (!ret.result) {\n      delete ret.distance;\n      delete ret.arrayIndices;\n    }\n    return ret;\n  };\n};\n\nvar andDocumentMatchers = andSomeMatchers;\nvar andBranchedMatchers = andSomeMatchers;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/DocumentSorter.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DocumentSorter = undefined;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _every2 = require('fast.js/array/every');\n\nvar _every3 = _interopRequireDefault(_every2);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _indexOf2 = require('fast.js/array/indexOf');\n\nvar _indexOf3 = _interopRequireDefault(_indexOf2);\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _DocumentMatcher = require('./DocumentMatcher');\n\nvar _DocumentMatcher2 = _interopRequireDefault(_DocumentMatcher);\n\nvar _Document = require('./Document');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Give a sort spec, which can be in any of these forms:\n//   {'key1': 1, 'key2': -1}\n//   [['key1', 'asc'], ['key2', 'desc']]\n//   ['key1', ['key2', 'desc']]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\n\nvar DocumentSorter = exports.DocumentSorter = function () {\n  function DocumentSorter(spec) {\n    var _this = this;\n\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    _classCallCheck(this, DocumentSorter);\n\n    this._sortSpecParts = [];\n\n    var addSpecPart = function addSpecPart(path, ascending) {\n      if (!path) {\n        throw Error('sort keys must be non-empty');\n      }\n      if (path.charAt(0) === '$') {\n        throw Error('unsupported sort key: ' + path);\n      }\n      _this._sortSpecParts.push({\n        path: path,\n        lookup: (0, _DocumentMatcher.makeLookupFunction)(path, { forSort: true }),\n        ascending: ascending\n      });\n    };\n\n    if (spec instanceof Array) {\n      for (var i = 0; i < spec.length; i++) {\n        if (typeof spec[i] === 'string') {\n          addSpecPart(spec[i], true);\n        } else {\n          addSpecPart(spec[i][0], spec[i][1] !== 'desc');\n        }\n      }\n    } else if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) === 'object') {\n      (0, _forEach2.default)(spec, function (value, key) {\n        addSpecPart(key, value >= 0);\n      });\n    } else {\n      throw Error('Bad sort specification: ' + JSON.stringify(spec));\n    }\n\n    // To implement affectedByModifier, we piggy-back on top of Matcher's\n    // affectedByModifier code; we create a selector that is affected by the same\n    // modifiers as this sort order. This is only implemented on the server.\n    if (this.affectedByModifier) {\n      var selector = {};\n      (0, _forEach2.default)(this._sortSpecParts, function (nextSpec) {\n        selector[nextSpec.path] = 1;\n      });\n      this._selectorForAffectedByModifier = new _DocumentMatcher2.default(selector);\n    }\n\n    this._keyComparator = composeComparators((0, _map3.default)(this._sortSpecParts, function (nextSpec, j) {\n      return _this._keyFieldComparator(j);\n    }));\n\n    // If you specify a matcher for this Sorter, _keyFilter may be set to a\n    // function which selects whether or not a given 'sort key' (tuple of values\n    // for the different sort spec fields) is compatible with the selector.\n    this._keyFilter = null;\n    if (options.matcher) {\n      this._useWithMatcher(options.matcher);\n    }\n  }\n\n  _createClass(DocumentSorter, [{\n    key: 'getComparator',\n    value: function getComparator(options) {\n      // If we have no distances, just use the comparator from the source\n      // specification (which defaults to 'everything is equal'.\n      if (!options || !options.distances) {\n        return this._getBaseComparator();\n      }\n\n      var distances = options.distances;\n\n      // Return a comparator which first tries the sort specification, and if that\n      // says 'it's equal', breaks ties using $near distances.\n      return composeComparators([this._getBaseComparator(), function (a, b) {\n        if (!distances.has(a._id)) {\n          throw Error('Missing distance for ' + a._id);\n        }\n        if (!distances.has(b._id)) {\n          throw Error('Missing distance for ' + b._id);\n        }\n        return distances.get(a._id) - distances.get(b._id);\n      }]);\n    }\n  }, {\n    key: '_getPaths',\n    value: function _getPaths() {\n      return (0, _map3.default)(this._sortSpecParts, function (x) {\n        return x.path;\n      });\n    }\n\n    // Finds the minimum key from the doc, according to the sort specs.  (We say\n    // 'minimum' here but this is with respect to the sort spec, so 'descending'\n    // sort fields mean we're finding the max for that field.)\n    //\n    // Note that this is NOT 'find the minimum value of the first field, the\n    // minimum value of the second field, etc'... it's 'choose the\n    // lexicographically minimum value of the key vector, allowing only keys which\n    // you can find along the same paths'.  ie, for a doc {a: [{x: 0, y: 5}, {x:\n    // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n    // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n\n  }, {\n    key: '_getMinKeyFromDoc',\n    value: function _getMinKeyFromDoc(doc) {\n      var _this2 = this;\n\n      var minKey = null;\n\n      this._generateKeysFromDoc(doc, function (key) {\n        if (!_this2._keyCompatibleWithSelector(key)) {\n          return;\n        }\n\n        if (minKey === null) {\n          minKey = key;\n          return;\n        }\n        if (_this2._compareKeys(key, minKey) < 0) {\n          minKey = key;\n        }\n      });\n\n      // This could happen if our key filter somehow filters out all the keys even\n      // though somehow the selector matches.\n      if (minKey === null) {\n        throw Error('sort selector found no keys in doc?');\n      }\n      return minKey;\n    }\n  }, {\n    key: '_keyCompatibleWithSelector',\n    value: function _keyCompatibleWithSelector(key) {\n      return !this._keyFilter || this._keyFilter(key);\n    }\n\n    // Iterates over each possible 'key' from doc (ie, over each branch), calling\n    // 'cb' with the key.\n\n  }, {\n    key: '_generateKeysFromDoc',\n    value: function _generateKeysFromDoc(doc, cb) {\n      if (this._sortSpecParts.length === 0) {\n        throw new Error('can\\'t generate keys without a spec');\n      }\n\n      // maps index -> ({'' -> value} or {path -> value})\n      var valuesByIndexAndPath = [];\n\n      var pathFromIndices = function pathFromIndices(indices) {\n        return indices.join(',') + ',';\n      };\n\n      var knownPaths = null;\n\n      (0, _forEach2.default)(this._sortSpecParts, function (spec, whichField) {\n        // Expand any leaf arrays that we find, and ignore those arrays\n        // themselves.  (We never sort based on an array itself.)\n        var branches = (0, _DocumentMatcher.expandArraysInBranches)(spec.lookup(doc), true);\n\n        // If there are no values for a key (eg, key goes to an empty array),\n        // pretend we found one null value.\n        if (!branches.length) {\n          branches = [{ value: null }];\n        }\n\n        var usedPaths = false;\n        valuesByIndexAndPath[whichField] = {};\n        (0, _forEach2.default)(branches, function (branch) {\n          if (!branch.arrayIndices) {\n            // If there are no array indices for a branch, then it must be the\n            // only branch, because the only thing that produces multiple branches\n            // is the use of arrays.\n            if (branches.length > 1) {\n              throw Error('multiple branches but no array used?');\n            }\n            valuesByIndexAndPath[whichField][''] = branch.value;\n            return;\n          }\n\n          usedPaths = true;\n          var path = pathFromIndices(branch.arrayIndices);\n          if (valuesByIndexAndPath[whichField].hasOwnProperty(path)) {\n            throw Error('duplicate path: ' + path);\n          }\n          valuesByIndexAndPath[whichField][path] = branch.value;\n\n          // If two sort fields both go into arrays, they have to go into the\n          // exact same arrays and we have to find the same paths.  This is\n          // roughly the same condition that makes MongoDB throw this strange\n          // error message.  eg, the main thing is that if sort spec is {a: 1,\n          // b:1} then a and b cannot both be arrays.\n          //\n          // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n          // and 'a.x.y' are both arrays, but we don't allow this for now.\n          // #NestedArraySort\n          // XXX achieve full compatibility here\n          if (knownPaths && !knownPaths.hasOwnProperty(path)) {\n            throw Error('cannot index parallel arrays');\n          }\n        });\n\n        if (knownPaths) {\n          // Similarly to above, paths must match everywhere, unless this is a\n          // non-array field.\n          if (!valuesByIndexAndPath[whichField].hasOwnProperty('') && (0, _keys3.default)(knownPaths).length !== (0, _keys3.default)(valuesByIndexAndPath[whichField]).length) {\n            throw Error('cannot index parallel arrays!');\n          }\n        } else if (usedPaths) {\n          knownPaths = {};\n          (0, _forEach2.default)(valuesByIndexAndPath[whichField], function (x, path) {\n            knownPaths[path] = true;\n          });\n        }\n      });\n\n      if (!knownPaths) {\n        // Easy case: no use of arrays.\n        var soleKey = (0, _map3.default)(valuesByIndexAndPath, function (values) {\n          if (!values.hasOwnProperty('')) {\n            throw Error('no value in sole key case?');\n          }\n          return values[''];\n        });\n        cb(soleKey);\n        return;\n      }\n\n      (0, _forEach2.default)(knownPaths, function (x, path) {\n        var key = (0, _map3.default)(valuesByIndexAndPath, function (values) {\n          if (values.hasOwnProperty('')) {\n            return values[''];\n          }\n          if (!values.hasOwnProperty(path)) {\n            throw Error('missing path?');\n          }\n          return values[path];\n        });\n        cb(key);\n      });\n    }\n\n    // Takes in two keys: arrays whose lengths match the number of spec\n    // parts. Returns negative, 0, or positive based on using the sort spec to\n    // compare fields.\n\n  }, {\n    key: '_compareKeys',\n    value: function _compareKeys(key1, key2) {\n      if (key1.length !== this._sortSpecParts.length || key2.length !== this._sortSpecParts.length) {\n        throw Error('Key has wrong length');\n      }\n\n      return this._keyComparator(key1, key2);\n    }\n\n    // Given an index 'i', returns a comparator that compares two key arrays based\n    // on field 'i'.\n\n  }, {\n    key: '_keyFieldComparator',\n    value: function _keyFieldComparator(i) {\n      var invert = !this._sortSpecParts[i].ascending;\n      return function (key1, key2) {\n        var compare = _Document.MongoTypeComp._cmp(key1[i], key2[i]);\n        if (invert) {\n          compare = -compare;\n        }\n        return compare;\n      };\n    }\n\n    // Returns a comparator that represents the sort specification (but not\n    // including a possible geoquery distance tie-breaker).\n\n  }, {\n    key: '_getBaseComparator',\n    value: function _getBaseComparator() {\n      var _this3 = this;\n\n      // If we're only sorting on geoquery distance and no specs, just say\n      // everything is equal.\n      if (!this._sortSpecParts.length) {\n        return function (doc1, doc2) {\n          return 0;\n        };\n      }\n\n      return function (doc1, doc2) {\n        var key1 = _this3._getMinKeyFromDoc(doc1);\n        var key2 = _this3._getMinKeyFromDoc(doc2);\n        return _this3._compareKeys(key1, key2);\n      };\n    }\n\n    // In MongoDB, if you have documents\n    //    {_id: 'x', a: [1, 10]} and\n    //    {_id: 'y', a: [5, 15]},\n    // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).\n    // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not\n    // match the selector, and 5 comes before 10).\n    //\n    // The way this works is pretty subtle!  For example, if the documents\n    // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and\n    //             {_id: 'y', a: [{x: 5}, {x: 15}]}),\n    // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and\n    //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})\n    // both follow this rule (y before x).  (ie, you do have to apply this\n    // through $elemMatch.)\n    //\n    // So if you pass a matcher to this sorter's constructor, we will attempt to\n    // skip sort keys that don't match the selector. The logic here is pretty\n    // subtle and undocumented; we've gotten as close as we can figure out based\n    // on our understanding of Mongo's behavior.\n\n  }, {\n    key: '_useWithMatcher',\n    value: function _useWithMatcher(matcher) {\n      if (this._keyFilter) {\n        throw Error('called _useWithMatcher twice?');\n      }\n\n      // If we are only sorting by distance, then we're not going to bother to\n      // build a key filter.\n      // XXX figure out how geoqueries interact with this stuff\n      if (_checkTypes2.default.emptyArray(this._sortSpecParts)) {\n        return;\n      }\n\n      var selector = matcher._selector;\n\n      // If the user just passed a literal function to find(), then we can't get a\n      // key filter from it.\n      if (selector instanceof Function || !selector) {\n        return;\n      }\n\n      var constraintsByPath = {};\n      (0, _forEach2.default)(this._sortSpecParts, function (spec, i) {\n        constraintsByPath[spec.path] = [];\n      });\n\n      (0, _forEach2.default)(selector, function (subSelector, key) {\n        // XXX support $and and $or\n\n        var constraints = constraintsByPath[key];\n        if (!constraints) {\n          return;\n        }\n\n        // XXX it looks like the real MongoDB implementation isn't 'does the\n        // regexp match' but 'does the value fall into a range named by the\n        // literal prefix of the regexp', ie 'foo' in /^foo(bar|baz)+/  But\n        // 'does the regexp match' is a good approximation.\n        if (subSelector instanceof RegExp) {\n          // As far as we can tell, using either of the options that both we and\n          // MongoDB support ('i' and 'm') disables use of the key filter. This\n          // makes sense: MongoDB mostly appears to be calculating ranges of an\n          // index to use, which means it only cares about regexps that match\n          // one range (with a literal prefix), and both 'i' and 'm' prevent the\n          // literal prefix of the regexp from actually meaning one range.\n          if (subSelector.ignoreCase || subSelector.multiline) {\n            return;\n          }\n          constraints.push((0, _DocumentMatcher.regexpElementMatcher)(subSelector));\n          return;\n        }\n\n        if ((0, _Document.isOperatorObject)(subSelector)) {\n          (0, _forEach2.default)(subSelector, function (operand, operator) {\n            if ((0, _indexOf3.default)(['$lt', '$lte', '$gt', '$gte'], operator) >= 0) {\n              // XXX this depends on us knowing that these operators don't use any\n              // of the arguments to compileElementSelector other than operand.\n              constraints.push(_DocumentMatcher.ELEMENT_OPERATORS[operator].compileElementSelector(operand));\n            }\n\n            // See comments in the RegExp block above.\n            if (operator === '$regex' && !subSelector.$options) {\n              constraints.push(_DocumentMatcher.ELEMENT_OPERATORS.$regex.compileElementSelector(operand, subSelector));\n            }\n\n            // XXX support {$exists: true}, $mod, $type, $in, $elemMatch\n          });\n          return;\n        }\n\n        // OK, it's an equality thing.\n        constraints.push((0, _DocumentMatcher.equalityElementMatcher)(subSelector));\n      });\n\n      // It appears that the first sort field is treated differently from the\n      // others; we shouldn't create a key filter unless the first sort field is\n      // restricted, though after that point we can restrict the other sort fields\n      // or not as we wish.\n      var currConstraint = constraintsByPath[this._sortSpecParts[0].path];\n      if (!_checkTypes2.default.assigned(currConstraint) || _checkTypes2.default.emptyArray(currConstraint)) {\n        return;\n      }\n\n      this._keyFilter = function (key) {\n        return (0, _every3.default)(this._sortSpecParts, function (specPart, index) {\n          return (0, _every3.default)(constraintsByPath[specPart.path], function (f) {\n            return f(key[index]);\n          });\n        });\n      };\n    }\n  }]);\n\n  return DocumentSorter;\n}();\n\nexports.default = DocumentSorter;\n\n// Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\n\nvar composeComparators = function composeComparators(comparatorArray) {\n  return function (a, b) {\n    for (var i = 0; i < comparatorArray.length; ++i) {\n      var compare = comparatorArray[i](a, b);\n      if (compare !== 0) {\n        return compare;\n      }\n    }\n    return 0;\n  };\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/CursorObservable.js":"'use strict';\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CursorObservable = undefined;\n\nvar _bind2 = require('fast.js/function/bind');\n\nvar _bind3 = _interopRequireDefault(_bind2);\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _values2 = require('fast.js/object/values');\n\nvar _values3 = _interopRequireDefault(_values2);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _Cursor2 = require('./Cursor');\n\nvar _Cursor3 = _interopRequireDefault(_Cursor2);\n\nvar _EJSON = require('./EJSON');\n\nvar _EJSON2 = _interopRequireDefault(_EJSON);\n\nvar _PromiseQueue = require('./PromiseQueue');\n\nvar _PromiseQueue2 = _interopRequireDefault(_PromiseQueue);\n\nvar _debounce = require('./debounce');\n\nvar _debounce2 = _interopRequireDefault(_debounce);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Defaults\nvar _defaultDebounce = 1000 / 60;\nvar _defaultBatchSize = 10;\n\n/**\n * Observable cursor is used for making request auto-updatable\n * after some changes is happen in a database.\n */\n\nvar CursorObservable = function (_Cursor) {\n  _inherits(CursorObservable, _Cursor);\n\n  function CursorObservable(db, query, options) {\n    _classCallCheck(this, CursorObservable);\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(CursorObservable).call(this, db, query, options));\n\n    _this.maybeUpdate = (0, _bind3.default)(_this.maybeUpdate, _this);\n    _this._observers = 0;\n    _this._updateQueue = new _PromiseQueue2.default(1);\n    _this._propagateUpdate = (0, _debounce2.default)((0, _bind3.default)(_this._propagateUpdate, _this), 0, 0);\n    _this._doUpdate = (0, _debounce2.default)((0, _bind3.default)(_this._doUpdate, _this), _defaultDebounce, _defaultBatchSize);\n    return _this;\n  }\n\n  _createClass(CursorObservable, [{\n    key: 'batchSize',\n\n    /**\n     * Change a batch size of updater.\n     * Btach size is a number of changes must be happen\n     * in debounce interval to force execute debounced\n     * function (update a result, in our case)\n     *\n     * @param  {Number} batchSize\n     * @return {CursorObservable}\n     */\n    value: function batchSize(_batchSize) {\n      this._doUpdate.updateBatchSize(_batchSize);\n      return this;\n    }\n\n    /**\n     * Change debounce wait time of the updater\n     * @param  {Number} waitTime\n     * @return {CursorObservable}\n     */\n\n  }, {\n    key: 'debounce',\n    value: function debounce(waitTime) {\n      this._doUpdate.updateWait(waitTime);\n      return this;\n    }\n\n    /**\n     * Observe changes of the cursor.\n     * It returns a Stopper – Promise with `stop` function.\n     * It is been resolved when first result of cursor is ready and\n     * after first observe listener call.\n     *\n     * @param  {Function}\n     * @param  {Object} options\n     * @return {Stopper}\n     */\n\n  }, {\n    key: 'observe',\n    value: function observe(listener) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      // Make possible to obbserver w/o callback\n      listener = listener || function () {};\n\n      // Start observing when no observers created\n      if (this._observers <= 0) {\n        this.db.on('insert', this.maybeUpdate);\n        this.db.on('update', this.maybeUpdate);\n        this.db.on('remove', this.maybeUpdate);\n      }\n\n      // Create observe stopper for current listeners\n      var running = true;\n      var self = this;\n      function stopper() {\n        if (running) {\n          running = false;\n          self._observers -= 1;\n          self.removeListener('update', listener);\n          self.removeListener('stop', stopper);\n\n          // Stop observing a cursor if no more observers\n          if (self._observers === 0) {\n            self._latestIds = null;\n            self._latestResult = null;\n            self._updatePromise = null;\n            self.emit('observeStopped');\n            self.db.removeListener('insert', self.maybeUpdate);\n            self.db.removeListener('update', self.maybeUpdate);\n            self.db.removeListener('remove', self.maybeUpdate);\n          }\n        }\n      }\n\n      // Start listening for updates and global stop\n      this._observers += 1;\n      this.on('update', listener);\n      this.on('stop', stopper);\n\n      // Get first result for observer or initiate\n      // update at first time\n      if (!this._updatePromise) {\n        this.update(true, true);\n      } else if (this._latestResult !== null) {\n        listener(this._latestResult);\n      }\n\n      // Wrap returned promise with useful fields\n      var cursorPromiseMixin = { stop: stopper };\n      return this._createCursorPromise(this._updatePromise, cursorPromiseMixin);\n    }\n\n    /**\n     * Stop all observers of the cursor by one call\n     * of this function.\n     * It also stops any delaied update of the cursor.\n     */\n\n  }, {\n    key: 'stopObservers',\n    value: function stopObservers() {\n      this._doUpdate.cancel();\n      this.emit('stop');\n      return this;\n    }\n\n    /**\n     * Executes an update. It is guarantee that\n     * one `_doUpdate` will be executed at one time.\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this2 = this;\n\n      var firstRun = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n      var immidiatelly = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n      if (!immidiatelly) {\n        if (this._updateDebPromise && !this._updateDebPromise.debouncePassed) {\n          this._doUpdate(firstRun);\n          return this._updatePromise;\n        } else if (this._updateDebAdded && (!this._updateDebPromise || !this._updateDebPromise.debouncePassed)) {\n          return this._updatePromise;\n        } else {\n          this._updateDebAdded = true;\n        }\n      }\n\n      this._updatePromise = this._updateQueue.add(function () {\n        if (immidiatelly) {\n          return _this2._doUpdate.func(firstRun);\n        } else {\n          _this2._updateDebAdded = true;\n          _this2._updateDebPromise = _this2._doUpdate(firstRun);\n          return _this2._updateDebPromise.then(function () {\n            _this2._updateDebAdded = false;\n            _this2._updateDebPromise = null;\n          });\n        }\n      });\n\n      return this._updatePromise;\n    }\n\n    /**\n     * Consider to update a query by given newDoc and oldDoc,\n     * received form insert/udpate/remove oparation.\n     * Should make a decision as smart as possible.\n     * (Don't update a cursor if it does not change a result\n     * of a cursor)\n     *\n     * TODO we should update _latestResult by hands in some cases\n     *      without a calling of `update` method\n     *\n     * @param  {Object} newDoc\n     * @param  {Object} oldDoc\n     */\n\n  }, {\n    key: 'maybeUpdate',\n    value: function maybeUpdate(newDoc, oldDoc) {\n      // When no newDoc and no oldDoc provided then\n      // it's a special case when no data about update\n      // available and we always need to update a cursor\n      var alwaysUpdateCursor = newDoc === null && oldDoc === null;\n\n      // When it's remove operation we just check\n      // that it's in our latest result ids list\n      var removedFromResult = alwaysUpdateCursor || !newDoc && oldDoc && (!this._latestIds || this._latestIds.has(oldDoc._id));\n\n      // When it's an update operation we check four things\n      // 1. Is a new doc or old doc matched by a query?\n      // 2. Is a new doc has different number of fields then an old doc?\n      // 3. Is a new doc not equals to an old doc?\n      var updatedInResult = removedFromResult || newDoc && oldDoc && (this._matcher.documentMatches(newDoc).result || this._matcher.documentMatches(oldDoc).result) && !_EJSON2.default.equals(newDoc, oldDoc);\n\n      // When it's an insert operation we just check\n      // it's match a query\n      var insertedInResult = updatedInResult || newDoc && !oldDoc && this._matcher.documentMatches(newDoc).result;\n\n      if (insertedInResult) {\n        return this.update();\n      }\n    }\n\n    /**\n     * DEBOUNCED\n     * Emits an update event with current result of a cursor\n     * and call this method on parent cursor if it exists\n     * and if it is not first run of update.\n     * @return {Promise}\n     */\n\n  }, {\n    key: '_propagateUpdate',\n    value: function _propagateUpdate() {\n      var firstRun = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n      var updatePromise = this.emitAsync('update', this._latestResult, firstRun);\n\n      var parentUpdatePromise = undefined;\n      if (!firstRun) {\n        parentUpdatePromise = Promise.all((0, _values3.default)((0, _map3.default)(this._parentCursors, function (v, k) {\n          if (v._propagateUpdate) {\n            return v._propagateUpdate(false);\n          }\n        })));\n      }\n\n      return updatePromise.then(function () {\n        return parentUpdatePromise;\n      });\n    }\n\n    /**\n     * DEBOUNCED\n     * Execute query and propagate result to observers.\n     * Resolved with result of execution.\n     * @param  {Boolean} firstRun\n     * @return {Promise}\n     */\n\n  }, {\n    key: '_doUpdate',\n    value: function _doUpdate() {\n      var _this3 = this;\n\n      var firstRun = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];\n\n      if (!firstRun) {\n        this.emit('cursorChanged');\n      }\n\n      return this.exec().then(function (result) {\n        _this3._updateLatestIds();\n        return _this3._propagateUpdate(firstRun).then(function () {\n          return result;\n        });\n      });\n    }\n\n    /**\n     * By a `_latestResult` update a `_latestIds` field of\n     * the object\n     */\n\n  }, {\n    key: '_updateLatestIds',\n    value: function _updateLatestIds() {\n      var idsArr = _checkTypes2.default.array(this._latestResult) ? (0, _map3.default)(this._latestResult, function (x) {\n        return x._id;\n      }) : this._latestResult && [this._latestResult._id];\n      this._latestIds = new Set(idsArr);\n    }\n\n    /**\n     * Track child cursor and stop child observer\n     * if this cusros stopped or changed.\n     * @param  {CursorPromise} cursorPromise\n     */\n\n  }, {\n    key: '_trackChildCursorPromise',\n    value: function _trackChildCursorPromise(cursorPromise) {\n      _get(Object.getPrototypeOf(CursorObservable.prototype), '_trackChildCursorPromise', this).call(this, cursorPromise);\n      if (cursorPromise.stop) {\n        this.once('cursorChanged', cursorPromise.stop);\n        this.once('observeStopped', cursorPromise.stop);\n        this.once('beforeExecute', cursorPromise.stop);\n      }\n    }\n  }], [{\n    key: 'defaultDebounce',\n    value: function defaultDebounce() {\n      if (arguments.length > 0) {\n        _defaultDebounce = arguments[0];\n      } else {\n        return _defaultDebounce;\n      }\n    }\n  }, {\n    key: 'defaultBatchSize',\n    value: function defaultBatchSize() {\n      if (arguments.length > 0) {\n        _defaultBatchSize = arguments[0];\n      } else {\n        return _defaultBatchSize;\n      }\n    }\n  }]);\n\n  return CursorObservable;\n}(_Cursor3.default);\n\nexports.CursorObservable = CursorObservable;\nexports.default = CursorObservable;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/Cursor.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Cursor = exports.PIPELINE_PROCESSORS = undefined;\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _assign2 = require('fast.js/object/assign');\n\nvar _assign3 = _interopRequireDefault(_assign2);\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _AsyncEventEmitter2 = require('./AsyncEventEmitter');\n\nvar _AsyncEventEmitter3 = _interopRequireDefault(_AsyncEventEmitter2);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _DocumentRetriver = require('./DocumentRetriver');\n\nvar _DocumentRetriver2 = _interopRequireDefault(_DocumentRetriver);\n\nvar _DocumentMatcher = require('./DocumentMatcher');\n\nvar _DocumentMatcher2 = _interopRequireDefault(_DocumentMatcher);\n\nvar _DocumentSorter = require('./DocumentSorter');\n\nvar _DocumentSorter2 = _interopRequireDefault(_DocumentSorter);\n\nvar _DocumentProjector = require('./DocumentProjector');\n\nvar _DocumentProjector2 = _interopRequireDefault(_DocumentProjector);\n\nvar _EJSON = require('./EJSON');\n\nvar _EJSON2 = _interopRequireDefault(_EJSON);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// UUID counter for all cursors\nvar _currentCursorId = 0;\n\n// Pipeline processors map\nvar PIPELINE_PROCESSORS = exports.PIPELINE_PROCESSORS = _extends({}, require('./cursor-processors/filter'), require('./cursor-processors/sortFunc'), require('./cursor-processors/map'), require('./cursor-processors/aggregate'), require('./cursor-processors/reduce'), require('./cursor-processors/join'), require('./cursor-processors/joinEach'), require('./cursor-processors/joinAll'), require('./cursor-processors/joinObj'), require('./cursor-processors/ifNotEmpty'));\n\n// Create basic cursor with pipeline methods\n\nvar BasicCursor = function (_AsyncEventEmitter) {\n  _inherits(BasicCursor, _AsyncEventEmitter);\n\n  function BasicCursor() {\n    _classCallCheck(this, BasicCursor);\n\n    return _possibleConstructorReturn(this, Object.getPrototypeOf(BasicCursor).apply(this, arguments));\n  }\n\n  return BasicCursor;\n}(_AsyncEventEmitter3.default);\n\n(0, _forEach2.default)(PIPELINE_PROCESSORS, function (v, procName) {\n  BasicCursor.prototype[procName] = v.method;\n});\n\n/**\n * Class for storing information about query\n * and executing it. It also have a sugar like\n * map/reduce, aggregation and others for making\n * fully customizable response\n */\n\nvar Cursor = function (_BasicCursor) {\n  _inherits(Cursor, _BasicCursor);\n\n  function Cursor(db) {\n    var query = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n    var options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    _classCallCheck(this, Cursor);\n\n    var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Cursor).call(this));\n\n    _this2.db = db;\n    _this2.options = options;\n    _this2._id = _currentCursorId++;\n    _this2._query = query;\n    _this2._pipeline = [];\n    _this2._latestResult = null;\n    _this2._childrenCursors = {};\n    _this2._parentCursors = {};\n    _this2._ensureMatcherSorter();\n    return _this2;\n  }\n\n  _createClass(Cursor, [{\n    key: 'skip',\n    value: function skip(_skip) {\n      (0, _invariant2.default)(_skip >= 0 || typeof _skip === 'undefined', 'skip(...): skip must be a positive number');\n\n      this._skip = _skip;\n      return this;\n    }\n  }, {\n    key: 'limit',\n    value: function limit(_limit) {\n      (0, _invariant2.default)(_limit >= 0 || typeof _limit === 'undefined', 'limit(...): limit must be a positive number');\n\n      this._limit = _limit;\n      return this;\n    }\n  }, {\n    key: 'find',\n    value: function find(query) {\n      this._query = query;\n      this._ensureMatcherSorter();\n      return this;\n    }\n  }, {\n    key: 'project',\n    value: function project(projection) {\n      if (projection) {\n        this._projector = new _DocumentProjector2.default(projection);\n      } else {\n        this._projector = null;\n      }\n      return this;\n    }\n  }, {\n    key: 'sort',\n    value: function sort(sortObj) {\n      (0, _invariant2.default)((typeof sortObj === 'undefined' ? 'undefined' : _typeof(sortObj)) === 'object' || typeof sortObj === 'undefined' || Array.isArray(sortObj), 'sort(...): argument must be an object');\n\n      this._sort = sortObj;\n      this._ensureMatcherSorter();\n      return this;\n    }\n  }, {\n    key: 'exec',\n    value: function exec() {\n      var _this3 = this;\n\n      this.emit('beforeExecute');\n      return this._createCursorPromise(this._doExecute().then(function (result) {\n        _this3._latestResult = result;\n        return result;\n      }));\n    }\n  }, {\n    key: 'then',\n    value: function then(resolve, reject) {\n      return this.exec().then(resolve, reject);\n    }\n  }, {\n    key: '_addPipeline',\n    value: function _addPipeline(type, val) {\n      (0, _invariant2.default)(type && PIPELINE_PROCESSORS[type], 'Unknown pipeline processor type %s', type);\n\n      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      this._pipeline.push({\n        type: type,\n        value: val,\n        args: args || []\n      });\n      return this;\n    }\n  }, {\n    key: '_processPipeline',\n    value: function _processPipeline(docs) {\n      var _this4 = this;\n\n      var i = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];\n\n      var pipeObj = this._pipeline[i];\n      if (!pipeObj) {\n        return Promise.resolve(docs);\n      } else {\n        return Promise.resolve(PIPELINE_PROCESSORS[pipeObj.type].process(docs, pipeObj, this)).then(function (result) {\n          if (result === '___[STOP]___') {\n            return result;\n          } else {\n            return _this4._processPipeline(result, i + 1);\n          }\n        });\n      }\n    }\n  }, {\n    key: '_doExecute',\n    value: function _doExecute() {\n      var _this5 = this;\n\n      return this._matchObjects().then(function (docs) {\n        var clonned = undefined;\n        if (_this5.options.noClone) {\n          clonned = docs;\n        } else {\n          if (!_this5._projector) {\n            clonned = (0, _map3.default)(docs, function (doc) {\n              return _EJSON2.default.clone(doc);\n            });\n          } else {\n            clonned = _this5._projector.project(docs);\n          }\n        }\n        return _this5._processPipeline(clonned);\n      });\n    }\n  }, {\n    key: '_matchObjects',\n    value: function _matchObjects() {\n      var _this6 = this;\n\n      var withFastLimit = this._limit && !this._skip && !this._sorter;\n      var retrOpts = withFastLimit ? { limit: this._limit } : {};\n      var queryFilter = function queryFilter(doc) {\n        return doc && _this6._matcher.documentMatches(doc).result;\n      };\n\n      return new _DocumentRetriver2.default(this.db).retriveForQeury(this._query, queryFilter, retrOpts).then(function (results) {\n        if (withFastLimit) {\n          return results;\n        }\n\n        if (_this6._sorter) {\n          var comparator = _this6._sorter.getComparator();\n          results.sort(comparator);\n        }\n\n        var skip = _this6._skip || 0;\n        var limit = _this6._limit || results.length;\n        return results.slice(skip, limit + skip);\n      });\n    }\n  }, {\n    key: '_ensureMatcherSorter',\n    value: function _ensureMatcherSorter() {\n      this._sorter = undefined;\n      this._matcher = new _DocumentMatcher2.default(this._query || {});\n\n      if (this._matcher.hasGeoQuery || this._sort) {\n        this._sorter = new _DocumentSorter2.default(this._sort || [], { matcher: this._matcher });\n      }\n    }\n  }, {\n    key: '_trackChildCursorPromise',\n    value: function _trackChildCursorPromise(childCursorPromise) {\n      var _this7 = this;\n\n      var childCursor = childCursorPromise.cursor;\n      this._childrenCursors[childCursor._id] = childCursor;\n      childCursor._parentCursors[this._id] = this;\n\n      this.once('beforeExecute', function () {\n        delete _this7._childrenCursors[childCursor._id];\n        delete childCursor._parentCursors[_this7._id];\n        if ((0, _keys3.default)(childCursor._parentCursors).length === 0) {\n          childCursor.emit('beforeExecute');\n        }\n      });\n    }\n  }, {\n    key: '_createCursorPromise',\n    value: function _createCursorPromise(promise) {\n      var _this8 = this;\n\n      var mixin = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      return (0, _assign3.default)({\n        cursor: this,\n        then: function then(successFn, failFn) {\n          return _this8._createCursorPromise(promise.then(successFn, failFn), mixin);\n        }\n      }, mixin);\n    }\n  }]);\n\n  return Cursor;\n}(BasicCursor);\n\nexports.Cursor = Cursor;\nexports.default = Cursor;","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/DocumentProjector.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compileProjection = compileProjection;\nexports.checkSupportedProjection = checkSupportedProjection;\nexports.projectionDetails = projectionDetails;\nexports.pathsToTree = pathsToTree;\nexports.combineImportantPathsIntoProjection = combineImportantPathsIntoProjection;\nexports.combineMatcherWithProjection = combineMatcherWithProjection;\nexports.combineSorterWithProjection = combineSorterWithProjection;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _assign2 = require('fast.js/object/assign');\n\nvar _assign3 = _interopRequireDefault(_assign2);\n\nvar _every2 = require('fast.js/array/every');\n\nvar _every3 = _interopRequireDefault(_every2);\n\nvar _filter2 = require('fast.js/array/filter');\n\nvar _filter3 = _interopRequireDefault(_filter2);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _indexOf2 = require('fast.js/array/indexOf');\n\nvar _indexOf3 = _interopRequireDefault(_indexOf2);\n\nvar _EJSON = require('./EJSON');\n\nvar _EJSON2 = _interopRequireDefault(_EJSON);\n\nvar _Document = require('./Document');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Internals\nfunction _has(obj, key) {\n  return _checkTypes2.default.object(obj) && obj.hasOwnProperty(key);\n}\n\n/**\n * A wrapper around pojection functions.\n */\n\nvar DocumentProjector = function () {\n  function DocumentProjector(fields) {\n    _classCallCheck(this, DocumentProjector);\n\n    this.fields = fields;\n    this._projector = compileProjection(fields);\n  }\n\n  _createClass(DocumentProjector, [{\n    key: 'project',\n    value: function project(docs) {\n      var _this = this;\n\n      if (_checkTypes2.default.array(docs)) {\n        return (0, _map3.default)(docs, function (doc) {\n          return _this._projector(doc);\n        });\n      } else {\n        return this._projector(docs);\n      }\n    }\n  }]);\n\n  return DocumentProjector;\n}();\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\n\nexports.default = DocumentProjector;\nfunction compileProjection(fields) {\n  checkSupportedProjection(fields);\n\n  var _idProjection = fields._id === undefined ? true : fields._id;\n  var details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  var transform = function transform(doc, ruleTree) {\n    // Special case for 'sets'\n    if (_checkTypes2.default.array(doc)) {\n      return (0, _map3.default)(doc, function (subdoc) {\n        return transform(subdoc, ruleTree);\n      });\n    }\n\n    var res = details.including ? {} : _EJSON2.default.clone(doc);\n    (0, _forEach2.default)(ruleTree, function (rule, key) {\n      if (!_has(doc, key)) {\n        return;\n      }\n      if (_checkTypes2.default.object(rule)) {\n        // For sub-objects/subsets we branch\n        if (_checkTypes2.default.object(doc[key]) || _checkTypes2.default.array(doc[key])) {\n          res[key] = transform(doc[key], rule);\n        }\n        // Otherwise we don't even touch this subfield\n      } else if (details.including) {\n          res[key] = _EJSON2.default.clone(doc[key]);\n        } else {\n          delete res[key];\n        }\n    });\n\n    return res;\n  };\n\n  return function (obj) {\n    var res = transform(obj, details.tree);\n    if (_idProjection && _has(obj, '_id')) {\n      res._id = obj._id;\n    }\n    if (!_idProjection && _has(res, '_id')) {\n      delete res._id;\n    }\n    return res;\n  };\n}\n\n// Rise an exception if fields object contains\n// some unsupported fields or values\nfunction checkSupportedProjection(fields) {\n  if (!_checkTypes2.default.object(fields) || _checkTypes2.default.array(fields)) {\n    throw Error('fields option must be an object');\n  }\n\n  (0, _forEach2.default)(fields, function (val, keyPath) {\n    var valKeys = _checkTypes2.default.object(val) && (0, _keys3.default)(val) || [];\n    if ((0, _indexOf3.default)(keyPath.split('.'), '$') >= 0) {\n      throw Error('Minimongo doesn\\'t support $ operator in projections yet.');\n    }\n    if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && ((0, _indexOf3.default)(valKeys, '$elemMatch') >= 0 || (0, _indexOf3.default)(valKeys, '$meta') >= 0 || (0, _indexOf3.default)(valKeys, '$slice') >= 0)) {\n      throw Error('Minimongo doesn\\'t support operators in projections yet.');\n    }\n    if ((0, _indexOf3.default)([1, 0, true, false], val) === -1) {\n      throw Error('Projection values should be one of 1, 0, true, or false');\n    }\n  });\n}\n\n// Traverses the keys of passed projection and constructs a tree where all\n// leaves are either all True or all False\n// @returns Object:\n//  - tree - Object - tree representation of keys involved in projection\n//  (exception for '_id' as it is a special case handled separately)\n//  - including - Boolean - 'take only certain fields' type of projection\nfunction projectionDetails(fields) {\n  // Find the non-_id keys (_id is handled specially because it is included unless\n  // explicitly excluded). Sort the keys, so that our code to detect overlaps\n  // like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n  var fieldsKeys = (0, _keys3.default)(fields).sort();\n\n  // If _id is the only field in the projection, do not remove it, since it is\n  // required to determine if this is an exclusion or exclusion. Also keep an\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\n  // inclusive and exclusive fields. If _id is not the only field in the\n  // projection and is exclusive, remove it so it can be handled later by a\n  // special case, since exclusive _id is always allowed.\n  if (fieldsKeys.length > 0 && !(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') && !((0, _indexOf3.default)(fieldsKeys, '_id') >= 0 && fields._id)) {\n    fieldsKeys = (0, _filter3.default)(fieldsKeys, function (key) {\n      return key !== '_id';\n    });\n  }\n\n  var including = null; // Unknown\n\n  (0, _forEach2.default)(fieldsKeys, function (keyPath) {\n    var rule = !!fields[keyPath];\n    if (including === null) {\n      including = rule;\n    }\n    if (including !== rule) {\n      // This error message is copied from MongoDB shell\n      throw Error('You cannot currently mix including and excluding fields.');\n    }\n  });\n\n  var projectionRulesTree = pathsToTree(fieldsKeys, function (path) {\n    return including;\n  }, function (node, path, fullPath) {\n    // Check passed projection fields' keys: If you have two rules such as\n    // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n    // that happens, there is a probability you are doing something wrong,\n    // framework should notify you about such mistake earlier on cursor\n    // compilation step than later during runtime.  Note, that real mongo\n    // doesn't do anything about it and the later rule appears in projection\n    // project, more priority it takes.\n    //\n    // Example, assume following in mongo shell:\n    // > db.coll.insert({ a: { b: 23, c: 44 } })\n    // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n    // { '_id' : ObjectId('520bfe456024608e8ef24af3'), 'a' : { 'b' : 23 } }\n    // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n    // { '_id' : ObjectId('520bfe456024608e8ef24af3'), 'a' : { 'b' : 23, 'c' : 44 } }\n    //\n    // Note, how second time the return set of keys is different.\n\n    var currentPath = fullPath;\n    var anotherPath = path;\n    throw Error('both ' + currentPath + ' and ' + anotherPath + ' found in fields option, using both of them may trigger ' + 'unexpected behavior. Did you mean to use only one of them?');\n  });\n\n  return {\n    tree: projectionRulesTree,\n    including: including\n  };\n}\n\n// paths - Array: list of mongo style paths\n// newLeafFn - Function: of form function(path) should return a scalar value to\n//                       put into list created for that path\n// conflictFn - Function: of form function(node, path, fullPath) is called\n//                        when building a tree path for 'fullPath' node on\n//                        'path' was already a leaf with a value. Must return a\n//                        conflict resolution.\n// initial tree - Optional Object: starting tree.\n// @returns - Object: tree represented as a set of nested objects\nfunction pathsToTree(paths, newLeafFn, conflictFn, tree) {\n  tree = tree || {};\n  (0, _forEach2.default)(paths, function (keyPath) {\n    var treePos = tree;\n    var pathArr = keyPath.split('.');\n\n    // use _.all just for iteration with break\n    var success = (0, _every3.default)(pathArr.slice(0, -1), function (key, idx) {\n      if (!_has(treePos, key)) {\n        treePos[key] = {};\n      } else if (!_checkTypes2.default.object(treePos[key])) {\n        treePos[key] = conflictFn(treePos[key], pathArr.slice(0, idx + 1).join('.'), keyPath);\n        // break out of loop if we are failing for this path\n        if (!_checkTypes2.default.object(treePos[key])) {\n          return false;\n        }\n      }\n\n      treePos = treePos[key];\n      return true;\n    });\n\n    if (success) {\n      var lastKey = pathArr[pathArr.length - 1];\n      if (!_has(treePos, lastKey)) {\n        treePos[lastKey] = newLeafFn(keyPath);\n      } else {\n        treePos[lastKey] = conflictFn(treePos[lastKey], keyPath, keyPath);\n      }\n    }\n  });\n\n  return tree;\n}\n\n// By given paths array and projection object returns\n// new projection object combined with paths.\nfunction combineImportantPathsIntoProjection(paths, projection) {\n  var prjDetails = projectionDetails(projection);\n  var tree = prjDetails.tree;\n  var mergedProjection = {};\n\n  // merge the paths to include\n  tree = pathsToTree(paths, function (path) {\n    return true;\n  }, function (node, path, fullPath) {\n    return true;\n  }, tree);\n  mergedProjection = treeToPaths(tree);\n  if (prjDetails.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  } else {\n    // selector is pointing at fields to include\n    // projection is pointing at fields to exclude\n    // make sure we don't exclude important paths\n    var mergedExclProjection = {};\n    (0, _forEach2.default)(mergedProjection, function (incl, path) {\n      if (!incl) {\n        mergedExclProjection[path] = false;\n      }\n    });\n\n    return mergedExclProjection;\n  }\n}\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nfunction combineMatcherWithProjection(matcher, projection) {\n  var selectorPaths = _pathsElidingNumericKeys(matcher._getPaths());\n\n  // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n  if ((0, _indexOf3.default)(selectorPaths, '') >= 0) {\n    return {};\n  }\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n}\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nfunction combineSorterWithProjection(sorter, projection) {\n  var specPaths = _pathsElidingNumericKeys(sorter._getPaths());\n  return combineImportantPathsIntoProjection(specPaths, projection);\n}\n\n// Internal utils\nvar _pathsElidingNumericKeys = function _pathsElidingNumericKeys(paths) {\n  return (0, _map3.default)(paths, function (path) {\n    return (0, _filter3.default)(path.split('.'), function (k) {\n      return !(0, _Document.isNumericKey)(k);\n    }).join('.');\n  });\n};\n\n// Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\nvar treeToPaths = function treeToPaths(tree, prefix) {\n  prefix = prefix || '';\n  var result = {};\n\n  (0, _forEach2.default)(tree, function (val, key) {\n    if (_checkTypes2.default.object(val)) {\n      (0, _assign3.default)(result, treeToPaths(val, prefix + key + '.'));\n    } else {\n      result[prefix + key] = val;\n    }\n  });\n\n  return result;\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/filter.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.filter = undefined;\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _filter2 = require('fast.js/array/filter');\n\nvar _filter3 = _interopRequireDefault(_filter2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar filter = exports.filter = {\n  method: function method(filterFn) {\n    (0, _invariant2.default)(typeof filterFn === 'function', 'filter(...): argument must be a function');\n\n    this._addPipeline('filter', filterFn);\n    return this;\n  },\n\n  process: function process(docs, pipeObj) {\n    return (0, _filter3.default)(docs, pipeObj.value);\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/sortFunc.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sortFunc = undefined;\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar sortFunc = exports.sortFunc = {\n  method: function method(sortFn) {\n    (0, _invariant2.default)(typeof sortFn === 'function', 'sortFunc(...): argument must be a function');\n\n    this._addPipeline('sortFunc', sortFn);\n    return this;\n  },\n\n  process: function process(docs, pipeObj) {\n    return docs.sort(pipeObj.value);\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/map.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.map = undefined;\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar map = exports.map = {\n  method: function method(mapperFn) {\n    (0, _invariant2.default)(typeof mapperFn === 'function', 'map(...): mapper must be a function');\n\n    this._addPipeline('map', mapperFn);\n    return this;\n  },\n\n  process: function process(docs, pipeObj) {\n    return (0, _map3.default)(docs, pipeObj.value);\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/aggregate.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.aggregate = undefined;\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar aggregate = exports.aggregate = {\n  method: function method(aggrFn) {\n    (0, _invariant2.default)(typeof aggrFn === 'function', 'aggregate(...): aggregator must be a function');\n\n    this._addPipeline('aggregate', aggrFn);\n    return this;\n  },\n\n  process: function process(docs, pipeObj) {\n    return pipeObj.value(docs);\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/reduce.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reduce = undefined;\n\nvar _reduce2 = require('fast.js/array/reduce');\n\nvar _reduce3 = _interopRequireDefault(_reduce2);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar reduce = exports.reduce = {\n  method: function method(reduceFn, initial) {\n    (0, _invariant2.default)(typeof reduceFn === 'function', 'reduce(...): reducer argument must be a function');\n\n    this._addPipeline('reduce', reduceFn, initial);\n    return this;\n  },\n\n  process: function process(docs, pipeObj) {\n    return (0, _reduce3.default)(docs, pipeObj.value, pipeObj.args[0]);\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/join.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.join = undefined;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _joinObj = require('./joinObj');\n\nvar _joinEach = require('./joinEach');\n\nvar _joinAll = require('./joinAll');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar join = exports.join = {\n  method: function method(joinFn) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    (0, _invariant2.default)(typeof joinFn === 'function' || _checkTypes2.default.object(joinFn), 'join(...): argument must be a function');\n\n    this._addPipeline('join', joinFn, options);\n    return this;\n  },\n\n  process: function process(docs, pipeObj, cursor) {\n    if (_checkTypes2.default.object(pipeObj.value)) {\n      return _joinObj.joinObj.process(docs, pipeObj, cursor);\n    } else if (_checkTypes2.default.array(docs)) {\n      return _joinEach.joinEach.process(docs, pipeObj, cursor);\n    } else {\n      return _joinAll.joinAll.process(docs, pipeObj, cursor);\n    }\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/joinObj.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinObj = undefined;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _forEach = require('fast.js/forEach');\n\nvar _forEach2 = _interopRequireDefault(_forEach);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _filter2 = require('fast.js/array/filter');\n\nvar _filter3 = _interopRequireDefault(_filter2);\n\nvar _reduce2 = require('fast.js/array/reduce');\n\nvar _reduce3 = _interopRequireDefault(_reduce2);\n\nvar _keys2 = require('fast.js/object/keys');\n\nvar _keys3 = _interopRequireDefault(_keys2);\n\nvar _Collection = require('../Collection');\n\nvar _Collection2 = _interopRequireDefault(_Collection);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _joinAll = require('./joinAll');\n\nvar _DocumentModifier = require('../DocumentModifier');\n\nvar _DocumentMatcher = require('../DocumentMatcher');\n\nvar _Document = require('../Document');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * By given list of documents make mapping of joined\n * model ids to root document and vise versa.\n * @param  {Array}  docs\n * @param  {String} key\n * @return {Object}\n */\nfunction _decomposeDocuments(docs, key) {\n  var lookupFn = (0, _DocumentMatcher.makeLookupFunction)(key);\n  var allIds = [];\n\n  var docsWrapped = (0, _map3.default)(docs, function (d) {\n    var val = lookupFn(d);\n    var joinIds = (0, _filter3.default)((0, _reduce3.default)((0, _map3.default)(val, function (x) {\n      return x.value;\n    }), function (a, b) {\n      if (_checkTypes2.default.array(b)) {\n        return [].concat(_toConsumableArray(a), _toConsumableArray(b));\n      } else {\n        return [].concat(_toConsumableArray(a), [b]);\n      }\n    }, []), function (x) {\n      return (0, _Document.selectorIsId)(x);\n    });\n\n    allIds = allIds.concat(joinIds);\n    return {\n      doc: d,\n      lookupResult: val\n    };\n  });\n\n  return { allIds: allIds, docsWrapped: docsWrapped };\n}\n\n/**\n * By given value of some key in join object return\n * an options object.\n * @param  {Object|Collection} joinValue\n * @return {Object}\n */\nfunction _getJoinOptions(key, value) {\n  if (value instanceof _Collection2.default) {\n    return { model: value, joinPath: key };\n  } else if (_checkTypes2.default.object(value)) {\n    return {\n      model: value.model,\n      joinPath: value.joinPath || key\n    };\n  } else {\n    throw new Error('Invalid join object value');\n  }\n}\n\n/**\n * By given result of joining objects restriving and root documents\n * decomposition set joining object on each root document\n * (if it is exists).\n * @param  {String} joinPath\n * @param  {Array}  res\n * @param  {Object} docsById\n * @param  {Object} childToRootMap\n */\nfunction _joinDocsWithResult(joinPath, res, docsWrapped) {\n  var resIdMap = {};\n  var initKeyparts = joinPath.split('.');\n\n  (0, _forEach2.default)(res, function (v) {\n    return resIdMap[v._id] = v;\n  });\n  (0, _forEach2.default)(docsWrapped, function (wrap) {\n    (0, _forEach2.default)(wrap.lookupResult, function (branch) {\n      if (branch.value) {\n        // `findModTarget` will modify `keyparts`. So, it should\n        // be copied each time.\n        var keyparts = initKeyparts.slice();\n        var target = (0, _DocumentModifier.findModTarget)(wrap.doc, keyparts, {\n          noCreate: false,\n          forbidArray: false,\n          arrayIndices: branch.arrayIndices\n        });\n        var field = keyparts[keyparts.length - 1];\n\n        if (_checkTypes2.default.array(branch.value)) {\n          target[field] = (0, _map3.default)(branch.value, function (id) {\n            return resIdMap[id];\n          });\n        } else {\n          target[field] = resIdMap[branch.value] || null;\n        }\n      }\n    });\n  });\n}\n\nvar joinObj = exports.joinObj = {\n  method: function method(obj) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    (0, _invariant2.default)(_checkTypes2.default.object(obj), 'joinObj(...): argument must be an object');\n\n    this._addPipeline('joinObj', obj, options);\n    return this;\n  },\n\n  process: function process(docs, pipeObj, cursor) {\n    if (!docs) {\n      return Promise.resolve(docs);\n    } else {\n      var _ret = function () {\n        var obj = pipeObj.value;\n        var options = pipeObj.args[0] || {};\n        var isObj = !_checkTypes2.default.array(docs);\n        docs = !isObj ? docs : [docs];\n\n        var joinerFn = function joinerFn(dcs) {\n          return (0, _map3.default)((0, _keys3.default)(obj), function (k) {\n            var _getJoinOptions2 = _getJoinOptions(k, obj[k]);\n\n            var model = _getJoinOptions2.model;\n            var joinPath = _getJoinOptions2.joinPath;\n\n            var _decomposeDocuments2 = _decomposeDocuments(docs, k);\n\n            var allIds = _decomposeDocuments2.allIds;\n            var docsWrapped = _decomposeDocuments2.docsWrapped;\n\n            var execFnName = options.observe ? 'observe' : 'then';\n            return model.find({ _id: { $in: allIds } })[execFnName](function (res) {\n              _joinDocsWithResult(joinPath, res, docsWrapped);\n            });\n          });\n        };\n\n        var newPipeObj = _extends({}, pipeObj, { value: joinerFn });\n        return {\n          v: _joinAll.joinAll.process(docs, newPipeObj, cursor).then(function (res) {\n            return isObj ? res[0] : res;\n          })\n        };\n      }();\n\n      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/joinAll.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinAll = undefined;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _bind2 = require('fast.js/function/bind');\n\nvar _bind3 = _interopRequireDefault(_bind2);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar joinAll = exports.joinAll = {\n  method: function method(joinFn) {\n    (0, _invariant2.default)(typeof joinFn === 'function', 'joinAll(...): argument must be a function');\n\n    this._addPipeline('joinAll', joinFn);\n    return this;\n  },\n\n  process: function process(docs, pipeObj, cursor) {\n    var i = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];\n    var len = arguments.length <= 4 || arguments[4] === undefined ? 1 : arguments[4];\n\n    var updatedFn = cursor._propagateUpdate ? (0, _bind3.default)(cursor._propagateUpdate, cursor) : function () {};\n\n    var res = pipeObj.value(docs, updatedFn, i, len);\n    res = _checkTypes2.default.array(res) ? res : [res];\n    res = (0, _map3.default)(res, function (val) {\n      var cursorPromise = undefined;\n      if (val && val.joinAll) {\n        // instanceof Cursor\n        cursorPromise = val.exec();\n      } else if (_checkTypes2.default.object(val) && val.cursor && val.then) {\n        cursorPromise = val;\n      }\n      if (cursorPromise) {\n        cursor._trackChildCursorPromise(cursorPromise);\n      }\n      return cursorPromise || val;\n    });\n\n    return Promise.all(res).then(function () {\n      return docs;\n    });\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/joinEach.js":"'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.joinEach = undefined;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nvar _map2 = require('fast.js/map');\n\nvar _map3 = _interopRequireDefault(_map2);\n\nvar _invariant = require('invariant');\n\nvar _invariant2 = _interopRequireDefault(_invariant);\n\nvar _joinAll = require('./joinAll');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar joinEach = exports.joinEach = {\n  method: function method(joinFn) {\n    (0, _invariant2.default)(typeof joinFn === 'function', 'joinEach(...): argument must be a function');\n\n    this._addPipeline('joinEach', joinFn);\n    return this;\n  },\n\n  process: function process(docs, pipeObj, cursor) {\n    if (!docs) {\n      return Promise.resolve(docs);\n    } else {\n      var _ret = function () {\n        docs = _checkTypes2.default.array(docs) ? docs : [docs];\n        var docsLength = docs.length;\n        return {\n          v: Promise.all((0, _map3.default)(docs, function (x, i) {\n            return _joinAll.joinAll.process(x, pipeObj, cursor, i, docsLength);\n          }))\n        };\n      }();\n\n      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/cursor-processors/ifNotEmpty.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ifNotEmpty = undefined;\n\nvar _checkTypes = require('check-types');\n\nvar _checkTypes2 = _interopRequireDefault(_checkTypes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ifNotEmpty = exports.ifNotEmpty = {\n  method: function method() {\n    this._addPipeline('ifNotEmpty');\n    return this;\n  },\n\n  process: function process(docs) {\n    var isEmptyRes = !_checkTypes2.default.assigned(docs) || _checkTypes2.default.array(docs) && _checkTypes2.default.emptyArray(docs) || _checkTypes2.default.object(docs) && _checkTypes2.default.emptyObject(docs);\n    return isEmptyRes ? '___[STOP]___' : docs;\n  }\n};","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/debounce.js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = debounce;\n/**\n * Debounce with updetable wait time and force\n * execution on some number of calls (batch execution)\n * Return promise that resolved with result of execution.\n * Promise cerated on each new execution (on idle).\n * @param  {Function} func\n * @param  {Number} wait\n * @param  {Number} batchSize\n * @return {Promise}\n */\nfunction debounce(func, wait, batchSize) {\n  var timeout = null;\n  var callsCount = 0;\n  var promise = null;\n  var doNotResolve = true;\n  var _maybeResolve = null;\n\n  var debouncer = function debouncer() {\n    var context = this;\n    var args = arguments;\n\n    if (!promise) {\n      promise = new Promise(function (resolve, reject) {\n        _maybeResolve = function maybeResolve() {\n          if (doNotResolve) {\n            timeout = setTimeout(_maybeResolve, wait);\n            doNotResolve = false;\n          } else {\n            resolve(func.apply(context, args));\n            promise = null;\n            callsCount = 0;\n            timeout = null;\n            doNotResolve = true;\n            _maybeResolve = null;\n          }\n        };\n        _maybeResolve();\n      });\n    } else {\n      var callNow = batchSize && callsCount >= batchSize;\n      doNotResolve = !callNow;\n\n      if (callNow && _maybeResolve) {\n        var returnPromise = promise;\n        returnPromise.debouncePassed = true;\n        clearTimeout(timeout);\n        _maybeResolve();\n        callsCount += 1;\n        return returnPromise;\n      }\n    }\n\n    callsCount += 1;\n    return promise;\n  };\n\n  var updateBatchSize = function updateBatchSize(newBatchSize) {\n    batchSize = newBatchSize;\n  };\n  var updateWait = function updateWait(newWait) {\n    wait = newWait;\n  };\n  var cancel = function cancel() {\n    clearTimeout(timeout);\n  };\n\n  debouncer.updateBatchSize = updateBatchSize;\n  debouncer.updateWait = updateWait;\n  debouncer.cancel = cancel;\n  debouncer.func = func;\n  return debouncer;\n}","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/dist/ShortIdGenerator.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (modelName) {\n  var nextSeed = _Random2.default.default().hexString(20);\n  var sequenceSeed = [nextSeed, '/collection/' + modelName];\n  return {\n    value: _Random2.default.createWithSeeds.apply(null, sequenceSeed).id(17),\n    seed: nextSeed\n  };\n};\n\nvar _Random = require('./Random');\n\nvar _Random2 = _interopRequireDefault(_Random);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/babelhook.js":"require(\"babel-register\")();","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/gulpfile.js":"'use strict';\n\nvar requireDir = require('require-dir');\nrequireDir('./gulp/tasks', { recurse: true });","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/polyfills.js":"if (typeof window !== 'undefined') {\n  window.Symbol = require(\"core-js/es6/symbol\");\n  window.Promise = require(\"core-js/es6/promise\");\n  window.Set = require(\"core-js/es6/set\");\n  window.Map = require(\"core-js/es6/map\");\n} else {\n  global.Symbol = require(\"core-js/es6/symbol\");\n  global.Promise = require(\"core-js/es6/promise\");\n  global.Set = require(\"core-js/es6/set\");\n  global.Map = require(\"core-js/es6/map\");\n}","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/gulp/config.js":"'use strict';\n\nmodule.exports = {\n  src: 'lib/**/*',\n  dist: 'dist',\n  build: 'build',\n\n  browser: {\n    bundleName: 'marsdb.js',\n    bundleMinName: 'marsdb.min.js',\n    bundlePolyfillsName: 'marsdb.polyfills.js',\n    entry: 'index.js',\n    entryTests: 'browser_tests.js',\n    entryPolyfills: 'polyfills.js',\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/AsyncEventEmitter.js":"import EventEmitter from 'eventemitter3';\n\n\n/**\n * Extension of a regular EventEmitter that provides a method\n * that returns a Promise then resolved when all listeners of the event\n * will be resolved.\n */\n/* istanbul ignore next */\nexport default class AsyncEventEmitter extends EventEmitter {\n\n  /**\n   * Emit an event and return a Promise that will be resolved\n   * when all listeren's Promises will be resolved.\n   * @param  {String} event\n   * @return {Promise}\n   */\n  emitAsync(event, a1, a2, a3, a4, a5) {\n    const prefix = EventEmitter.prefixed;\n    const evt = prefix ? prefix + event : event;\n\n    if (!this._events || !this._events[evt]) {\n      return Promise.resolve();\n    }\n\n    let i;\n    const listeners = this._events[evt];\n    const len = arguments.length;\n    let args;\n\n    if ('function' === typeof listeners.fn) {\n      if (listeners.once) {\n        this.removeListener(event, listeners.fn, undefined, true);\n      }\n\n      switch (len) {\n        case 1: return Promise.resolve(listeners.fn.call(listeners.context));\n        case 2: return Promise.resolve(listeners.fn.call(listeners.context, a1));\n        case 3: return Promise.resolve(listeners.fn.call(listeners.context, a1, a2));\n        case 4: return Promise.resolve(listeners.fn.call(listeners.context, a1, a2, a3));\n        case 5: return Promise.resolve(listeners.fn.call(listeners.context, a1, a2, a3, a4));\n        case 6: return Promise.resolve(listeners.fn.call(listeners.context, a1, a2, a3, a4, a5));\n      }\n\n      for (i = 1, args = new Array(len -1); i < len; i++) {\n        args[i - 1] = arguments[i];\n      }\n\n      return Promise.resolve(listeners.fn.apply(listeners.context, args));\n    } else {\n      const promises = [];\n      const length = listeners.length;\n      let j;\n\n      for (i = 0; i < length; i++) {\n        if (listeners[i].once) {\n          this.removeListener(event, listeners[i].fn, undefined, true);\n        }\n\n        switch (len) {\n          case 1: promises.push(Promise.resolve(listeners[i].fn.call(listeners[i].context))); break;\n          case 2: promises.push(Promise.resolve(listeners[i].fn.call(listeners[i].context, a1))); break;\n          case 3: promises.push(Promise.resolve(listeners[i].fn.call(listeners[i].context, a1, a2))); break;\n          default:\n            if (!args) {\n              for (j = 1, args = new Array(len -1); j < len; j++) {\n                args[j - 1] = arguments[j];\n              }\n            }\n            promises.push(Promise.resolve(listeners[i].fn.apply(listeners[i].context, args)));\n        }\n      }\n\n      return Promise.all(promises);\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/Base64.js":"/**\n * Based on Meteor's Base64 package.\n * Rewrite with ES6 and better formated for passing\n * linter\n */\nvar BASE_64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nvar BASE_64_VALS = {};\n\n(function setupBase64Vals() {\n  for (let j = 0; j < BASE_64_CHARS.length; j++) {\n    BASE_64_VALS[BASE_64_CHARS.charAt(j)] = j;\n  }\n})();\n\nvar getChar = function(val) {\n  return BASE_64_CHARS.charAt(val);\n};\n\nvar getVal = function(ch) {\n  if (ch === '=') {\n    return -1;\n  }\n  return BASE_64_VALS[ch];\n};\n\n// Base 64 encoding\nexport class Base64 {\n  encode(array) {\n    if (typeof array === 'string') {\n      var str = array;\n      array = this.newBinary(str.length);\n      for (let i = 0; i < str.length; i++) {\n        var ch = str.charCodeAt(i);\n        if (ch > 0xFF) {\n          throw new Error(\n            'Not ascii. Base64.encode can only take ascii strings.');\n        }\n        array[i] = ch;\n      }\n    }\n\n    var answer = [];\n    var a = null;\n    var b = null;\n    var c = null;\n    var d = null;\n    for (let i = 0; i < array.length; i++) {\n      switch (i % 3) {\n        case 0:\n          a = (array[i] >> 2) & 0x3F;\n          b = (array[i] & 0x03) << 4;\n          break;\n        case 1:\n          b |= (array[i] >> 4) & 0xF;\n          c = (array[i] & 0xF) << 2;\n          break;\n        case 2:\n          c |= (array[i] >> 6) & 0x03;\n          d = array[i] & 0x3F;\n          answer.push(getChar(a));\n          answer.push(getChar(b));\n          answer.push(getChar(c));\n          answer.push(getChar(d));\n          a = null;\n          b = null;\n          c = null;\n          d = null;\n          break;\n      }\n    }\n    if (a != null) {\n      answer.push(getChar(a));\n      answer.push(getChar(b));\n      if (c == null) {\n        answer.push('=');\n      } else {\n        answer.push(getChar(c));\n      }\n      if (d == null) {\n        answer.push('=');\n      }\n    }\n    return answer.join('');\n  }\n\n  decode(str) {\n    var len = Math.floor((str.length*3)/4);\n    if (str.charAt(str.length - 1) == '=') {\n      len--;\n      if (str.charAt(str.length - 2) == '=') {\n        len--;\n      }\n    }\n    var arr = this.newBinary(len);\n\n    var one = null;\n    var two = null;\n    var three = null;\n\n    var j = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      var v = getVal(c);\n      switch (i % 4) {\n        case 0:\n          if (v < 0) {\n            throw new Error('invalid base64 string');\n          }\n          one = v << 2;\n          break;\n        case 1:\n          if (v < 0) {\n            throw new Error('invalid base64 string');\n          }\n          one |= (v >> 4);\n          arr[j++] = one;\n          two = (v & 0x0F) << 4;\n          break;\n        case 2:\n          if (v >= 0) {\n            two |= (v >> 2);\n            arr[j++] = two;\n            three = (v & 0x03) << 6;\n          }\n          break;\n        case 3:\n          if (v >= 0) {\n            arr[j++] = three | v;\n          }\n          break;\n      }\n    }\n    return arr;\n  }\n\n  newBinary(len) {\n    if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\n      var ret = [];\n      for (let i = 0; i < len; i++) {\n        ret.push(0);\n      }\n      ret.$Uint8ArrayPolyfill = true;\n      return ret;\n    }\n    return new Uint8Array(new ArrayBuffer(len));\n  }\n}\n\nexport default new Base64();\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/CollectionDelegate.js":"import _map from 'fast.js/map';\nimport DocumentModifier from './DocumentModifier';\n\n\n/**\n * Default collection delegate for working with a\n * normal MarsDB approach – within a browser.\n */\nexport class CollectionDelegate {\n  constructor(db) {\n    this.db = db;\n  }\n\n  insert(doc, options = {}, randomId) {\n    return this.db.indexManager.indexDocument(doc).then(() =>\n      this.db.storageManager.persist(doc._id, doc).then(() =>\n        doc._id\n      )\n    );\n  }\n\n  remove(query, {sort = {_id: 1}, multi = false}) {\n    return this.find(query, {noClone: true})\n      .sort(sort).then((docs) => {\n        if (docs.length > 1 && !multi) {\n          docs = [docs[0]];\n        }\n        const removeStorgePromises = _map(docs, d =>\n          this.db.storageManager.delete(d._id)\n        );\n        const removeIndexPromises = _map(docs, d =>\n          this.db.indexManager.deindexDocument(d)\n        );\n        return Promise.all([\n          ...removeStorgePromises,\n          ...removeIndexPromises,\n        ]).then(() => docs);\n      });\n  }\n\n  update(query, modifier, {sort = {_id: 1}, multi = false, upsert = false}) {\n    return this.find(query, {noClone: true})\n      .sort(sort).then((docs) => {\n        if (docs.length > 1 && !multi) {\n          docs = [docs[0]];\n        }\n        return new DocumentModifier(query)\n          .modify(docs, modifier, { upsert });\n      }).then(({original, updated}) => {\n        const updateStorgePromises = _map(updated, d =>\n          this.db.storageManager.persist(d._id, d)\n        );\n        const updateIndexPromises = _map(updated, (d, i) =>\n          this.db.indexManager.reindexDocument(original[i], d)\n        );\n        return Promise.all([\n          ...updateStorgePromises,\n          ...updateIndexPromises,\n        ]).then(() => ({\n          modified: updated.length,\n          original: original,\n          updated: updated,\n        }));\n      });\n  }\n\n  find(query, options = {}) {\n    const cursorClass = this.db.cursorClass;\n    return new cursorClass(this.db, query, options);\n  }\n\n  findOne(query, options = {}) {\n    return this.find(query, options)\n      .aggregate(docs => docs[0])\n      .limit(1);\n  }\n\n  count(query, options = {}) {\n    options.noClone = true;\n    return this.find(query, options)\n      .aggregate((docs) => docs.length);\n  }\n\n  ids(query, options = {}) {\n    options.noClone = true;\n    return this.find(query, options)\n      .map((doc) => doc._id);\n  }\n}\n\nexport default CollectionDelegate;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/CollectionIndex.js":"import invariant from 'invariant';\n\n\nexport class CollectionIndex {\n  constructor(options = {}) {\n    invariant(\n      options.fieldName,\n      'CollectionIndex(...): you must specify a \"feildName\" option'\n    );\n    invariant(\n      !Array.isArray(options.fieldName),\n      'CollectionIndex(...): compound index is not supported yet'\n    );\n\n    this.fieldName = options.fieldName;\n    this.unique = options.unique || false;\n    this.sparse = options.sparse || false;\n\n    this.reset();\n  }\n\n  reset() {\n    // TODO\n  }\n\n  insert(doc) {\n    // TODO\n  }\n\n  remove(doc) {\n    // TODO\n  }\n\n  update(oldDoc, newDoc) {\n    // TODO\n  }\n\n  getMatching(value) {\n    // TODO\n  }\n\n  getBetweenBounds(query) {\n    // TODO\n  }\n\n  getAll(options) {\n    // TODO\n  }\n}\n\nexport default CollectionIndex;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/Collection.js":"import _map from 'fast.js/map';\nimport _each from 'fast.js/forEach';\nimport _check from 'check-types';\nimport EventEmitter from './AsyncEventEmitter';\nimport IndexManager from './IndexManager';\nimport StorageManager from './StorageManager';\nimport CollectionDelegate from './CollectionDelegate';\nimport CursorObservable from './CursorObservable';\nimport ShortIdGenerator from './ShortIdGenerator';\nimport EJSON from './EJSON';\n\n\n// Defaults\nlet _defaultCursor = CursorObservable;\nlet _defaultDelegate = CollectionDelegate;\nlet _defaultStorageManager = StorageManager;\nlet _defaultIndexManager = IndexManager;\nlet _defaultIdGenerator = ShortIdGenerator;\n\n\n// Startup all init dependent functions on\n// the second execution cycle\nlet _startedUp = false;\nlet _startUpQueue = [];\nlet _startUpId = 0;\n\n// Internals\nexport function _resetStartup(waitMs = 0) {\n  _startUpId += 1;\n  _startUpQueue = [];\n  _startedUp = false;\n  const currStartId = _startUpId;\n  setTimeout(() => {\n    if (currStartId === _startUpId) {\n      _startedUp = true;\n      _each(_startUpQueue, fn => fn());\n      _startUpQueue = [];\n    }\n  }, waitMs);\n}\n\nexport function _warnIfAlreadyStarted() {\n  if (_startedUp) {\n    console.warn('You are trying to change some default of the Collection,' +\n      'but all collections is already initialized. It may be happened ' +\n      'because you are trying to configure Collection not at first ' +\n      'execution cycle of main script. Please consider to move all ' +\n      'configuration to first execution cycle.');\n  }\n}\n\n// Initiate startup\n_resetStartup();\n\n/**\n * Core class of the database.\n * It delegates almost all it's methods to managers\n * and emits events for live queries and other cuctomisation.\n */\nexport class Collection extends EventEmitter {\n  constructor(name, options = {}) {\n    super();\n    this.options = options;\n    this._modelName = name;\n\n    // Shorthand for defining in-memory collection\n    if (options.inMemory) {\n      options.cursorClass = options.cursorClass || CursorObservable;\n      options.delegate = options.delegate || CollectionDelegate;\n      options.storageManager = options.storageManager || StorageManager;\n      options.indexManager = options.indexManager || IndexManager;\n      options.idGenerator = options.idGenerator || ShortIdGenerator;\n    }\n\n    // Initialize collection only after configuration done\n    Collection.startup(() => this._lazyInitCollection());\n  }\n\n  get modelName() {\n    return this._modelName;\n  }\n  get indexes() {\n    this._lazyInitCollection();\n    return this.indexManager.indexes;\n  }\n  get storage() {\n    this._lazyInitCollection();\n    return this.storageManager;\n  }\n\n  /**\n   * Factory for creating an object of the model\n   * @param  {String|Object} raw\n   * @return {Object}\n   */\n  create(raw) {\n    return _check.string(raw) ? EJSON.parse(raw) : raw;\n  }\n\n  /**\n   * Insert a document into the model and\n   * emit `synd:insert` event (if not quiet).\n   * @param  {Object} doc\n   * @param  {Boolean} quiet\n   * @return {Promise}\n   */\n  insert(doc, options = {}) {\n    this._lazyInitCollection();\n    const randomId = this.idGenerator(this.modelName);\n    doc = this.create(doc);\n    doc._id = doc._id || randomId.value;\n\n    this.emit('beforeInsert', doc, randomId);\n    if (!options.quiet) {\n      this.emit('sync:insert', doc, randomId);\n    }\n    return this.delegate.insert(doc, options, randomId).then((docId) => {\n      this.emit('insert', doc, null, randomId);\n      return docId;\n    });\n  }\n\n  /**\n   * Just a sugar for mulpitle inserts. Wrap all inserts\n   * with a single Promise and return it.\n   * @param  {Array} docs\n   * @param  {Object} options\n   * @return {Promise}\n   */\n  insertAll(docs, options = {}) {\n    return Promise.all(\n      _map(docs, d => this.insert(d, options))\n    );\n  }\n\n  /**\n   * Remove an object (or objects with options.multi)\n   * from the model.\n   * @param  {Object} query\n   * @param  {Object} options\n   * @param  {Boolean} quiet\n   * @return {Promise}\n   */\n  remove(query, options = {}) {\n    this._lazyInitCollection();\n\n    this.emit('beforeRemove', query, options);\n    if (!options.quiet) {\n      this.emit('sync:remove', query, options);\n    }\n    return this.delegate.remove(query, options).then((removedDocs) => {\n      _each(removedDocs, d => this.emit('remove', null, d));\n      return removedDocs;\n    });\n  }\n\n  /**\n   * Remove an object (or objects with options.multi)\n   * from the model.\n   * NOTE: `upsert` is not supported, only `multi`\n   * @param  {Object} query\n   * @param  {Object} options\n   * @param  {Boolean} quiet\n   * @return {Promise}\n   */\n  update(query, modifier, options = {}) {\n    this._lazyInitCollection();\n\n    this.emit('beforeUpdate', query, modifier, options);\n    if (!options.quiet) {\n      this.emit('sync:update', query, modifier, options);\n    }\n    return this.delegate.update(query, modifier, options).then(res => {\n      _each(res.updated, (d, i) => {\n        this.emit('update', d, res.original[i]);\n      });\n      return res;\n    });\n  }\n\n  /**\n   * Make a cursor with given query and return.\n   * By default all documents clonned before passed\n   * to pipeline functions. By setting `options.noClone`\n   * to `true` clonning may be disabled (for your own risk)\n   * @param  {Object} query\n   * @param  {Number} options.noClone\n   * @return {CursorObservable}\n   */\n  find(query, options = {}) {\n    this._lazyInitCollection();\n    return this.delegate.find(query, options);\n  }\n\n  /**\n   * Finds one object by given query and sort object.\n   * Return a promise that resolved with a document object\n   * or with undefined if no object found.\n   * @param  {Object} query\n   * @param  {Object} sortObj\n   * @return {CursorObservable}\n   */\n  findOne(query, options = {}) {\n    this._lazyInitCollection();\n    return this.delegate.findOne(query, options);\n  }\n\n  /**\n   * Returns a number of matched by query objects. It's\n   * based on `ids` function and uses only indexes.\n   * In this case it's much more faster then doing\n   * `find().length`, because it does not going to the\n   * storage.\n   * @param  {Object} query\n   * @return {CursorObservable}\n   */\n  count(query, options = {}) {\n    this._lazyInitCollection();\n    return this.delegate.count(query, options);\n  }\n\n  /**\n   * Return a list of ids by given query. Uses only\n   * indexes.\n   * @param  {Object} query\n   * @return {CursorObservable}\n   */\n  ids(query, options = {}) {\n    this._lazyInitCollection();\n    return this.delegate.ids(query, options);\n  }\n\n  /**\n   * Initialize collection managers by stored options. It is\n   * used for solving execution order problem of Collection\n   * configuration functions.\n   */\n  _lazyInitCollection() {\n    if (!this._initialized) {\n      this._initialized = true;\n      const options = this.options;\n      const storageManagerClass = options.storageManager || _defaultStorageManager;\n      const delegateClass = options.delegate || _defaultDelegate;\n      const indexManagerClass = options.indexManager || _defaultIndexManager;\n      this.idGenerator = options.idGenerator || _defaultIdGenerator;\n      this.cursorClass = options.cursorClass || _defaultCursor;\n      this.indexManager = new indexManagerClass(this, options);\n      this.storageManager = new storageManagerClass(this, options);\n      this.delegate = new delegateClass(this, options);\n    }\n  }\n\n  /**\n   * Wihout arguments it returns current default storage manager.\n   * If arguments provided, then first argument will be set as default\n   * storage manager and all collections, who uses default storage manager,\n   * will be upgraded to a new strage manager.\n   * @return {undefined|Class}\n   */\n  static defaultCursor() {\n    if (arguments.length > 0) {\n      _warnIfAlreadyStarted();\n      _defaultCursor = arguments[0];\n    } else {\n      return _defaultCursor;\n    }\n  }\n\n  /**\n   * Wihout arguments it returns current default storage manager.\n   * If arguments provided, then first argument will be set as default\n   * storage manager and all collections, who uses default storage manager,\n   * will be upgraded to a new strage manager.\n   * @return {undefined|Class}\n   */\n  static defaultStorageManager() {\n    if (arguments.length > 0) {\n      _warnIfAlreadyStarted();\n      _defaultStorageManager = arguments[0];\n    } else {\n      return _defaultStorageManager;\n    }\n  }\n\n  /**\n   * Wihout arguments it returns current default id generator.\n   * If arguments provided, then first argument will be set as default\n   * id generator and all collections, who uses default id generator,\n   * will be upgraded to a new id generator.\n   * @return {undefined|Class}\n   */\n  static defaultIdGenerator() {\n    if (arguments.length > 0) {\n      _warnIfAlreadyStarted();\n      _defaultIdGenerator = arguments[0];\n    } else {\n      return _defaultIdGenerator;\n    }\n  }\n\n  /**\n   * Wihout arguments it returns current default delegate class.\n   * If arguments provided, then first argument will be set as default\n   * delegate and all collections, who uses default delegate,\n   * will be upgraded to a new delegate.\n   * @return {undefined|Class}\n   */\n  static defaultDelegate() {\n    if (arguments.length > 0) {\n      _warnIfAlreadyStarted();\n      _defaultDelegate = arguments[0];\n    } else {\n      return _defaultDelegate;\n    }\n  }\n\n  /**\n   * Wihout arguments it returns current default index manager class.\n   * If arguments provided, then first argument will be set as default\n   * index manager and all collections, who uses default index manager,\n   * will be upgraded to a new index manager.\n   * @return {undefined|Class}\n   */\n  static defaultIndexManager() {\n    if (arguments.length > 0) {\n      _warnIfAlreadyStarted();\n      _defaultIndexManager = arguments[0];\n    } else {\n      return _defaultIndexManager;\n    }\n  }\n\n  /**\n   * Execute some function after current execution cycle. For using fully\n   * configured collection.\n   * @param  {Function} fn\n   */\n  static startup(fn) {\n    if (_startedUp) {\n      fn();\n    } else {\n      _startUpQueue.push(fn);\n    }\n  }\n}\n\nexport default Collection;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/Cursor.js":"import _each from 'fast.js/forEach';\nimport _assign from 'fast.js/object/assign';\nimport _keys from 'fast.js/object/keys';\nimport _map from 'fast.js/map';\nimport AsyncEventEmitter from './AsyncEventEmitter';\nimport invariant from 'invariant';\nimport DocumentRetriver from './DocumentRetriver';\nimport DocumentMatcher from './DocumentMatcher';\nimport DocumentSorter from './DocumentSorter';\nimport DocumentProjector from './DocumentProjector';\nimport EJSON from './EJSON';\n\n\n// UUID counter for all cursors\nlet _currentCursorId = 0;\n\n// Pipeline processors map\nexport const PIPELINE_PROCESSORS = {\n  ...require('./cursor-processors/filter'),\n  ...require('./cursor-processors/sortFunc'),\n  ...require('./cursor-processors/map'),\n  ...require('./cursor-processors/aggregate'),\n  ...require('./cursor-processors/reduce'),\n  ...require('./cursor-processors/join'),\n  ...require('./cursor-processors/joinEach'),\n  ...require('./cursor-processors/joinAll'),\n  ...require('./cursor-processors/joinObj'),\n  ...require('./cursor-processors/ifNotEmpty'),\n};\n\n// Create basic cursor with pipeline methods\nclass BasicCursor extends AsyncEventEmitter {}\n_each(PIPELINE_PROCESSORS, (v, procName) => {\n  BasicCursor.prototype[procName] = v.method;\n});n\n\n\n/**\n * Class for storing information about query\n * and executing it. It also have a sugar like\n * map/reduce, aggregation and others for making\n * fully customizable response\n */\nexport class Cursor extends BasicCursor {\n  constructor(db, query = {}, options = {}) {\n    super();\n    this.db = db;\n    this.options = options;\n    this._id = _currentCursorId++;\n    this._query = query;\n    this._pipeline = [];\n    this._latestResult = null;\n    this._childrenCursors = {};\n    this._parentCursors = {};\n    this._ensureMatcherSorter();\n  }\n\n  skip(skip) {\n    invariant(\n      skip >= 0 || typeof skip === 'undefined',\n      'skip(...): skip must be a positive number'\n    );\n\n    this._skip = skip;\n    return this;\n  }\n\n  limit(limit) {\n    invariant(\n      limit >= 0 || typeof limit === 'undefined',\n      'limit(...): limit must be a positive number'\n    );\n\n    this._limit = limit;\n    return this;\n  }\n\n  find(query) {\n    this._query = query;\n    this._ensureMatcherSorter();\n    return this;\n  }\n\n  project(projection) {\n    if (projection) {\n      this._projector = new DocumentProjector(projection);\n    } else {\n      this._projector = null;\n    }\n    return this;\n  }\n\n  sort(sortObj) {\n    invariant(\n      typeof sortObj === 'object' || typeof sortObj === 'undefined' || Array.isArray(sortObj),\n      'sort(...): argument must be an object'\n    );\n\n    this._sort = sortObj;\n    this._ensureMatcherSorter();\n    return this;\n  }\n\n  exec() {\n    this.emit('beforeExecute');\n    return this._createCursorPromise(\n      this._doExecute().then((result) => {\n        this._latestResult = result;\n        return result;\n      })\n    );\n  }\n\n  then(resolve, reject) {\n    return this.exec().then(resolve, reject);\n  }\n\n  _addPipeline(type, val, ...args) {\n    invariant(\n      type && PIPELINE_PROCESSORS[type],\n      'Unknown pipeline processor type %s',\n      type\n    );\n\n    this._pipeline.push({\n      type: type,\n      value: val,\n      args: args || [],\n    });\n    return this;\n  }\n\n  _processPipeline(docs, i = 0) {\n    const pipeObj = this._pipeline[i];\n    if (!pipeObj) {\n      return Promise.resolve(docs);\n    } else {\n      return Promise.resolve(\n        PIPELINE_PROCESSORS[pipeObj.type].process(\n          docs, pipeObj, this\n        )\n      ).then((result) => {\n        if (result === '___[STOP]___') {\n          return result;\n        } else {\n          return this._processPipeline(result, i + 1);\n        }\n      });\n    }\n  }\n\n  _doExecute() {\n    return this._matchObjects()\n      .then(docs => {\n        let clonned;\n        if (this.options.noClone) {\n          clonned = docs;\n        } else {\n          if (!this._projector) {\n            clonned = _map(docs, doc => EJSON.clone(doc));\n          } else {\n            clonned = this._projector.project(docs);\n          }\n        }\n        return this._processPipeline(clonned);\n      });\n  }\n\n  _matchObjects() {\n    const withFastLimit = this._limit && !this._skip && !this._sorter;\n    const retrOpts = withFastLimit ? { limit: this._limit } : {};\n    const queryFilter = (doc) => {\n      return doc && this._matcher.documentMatches(doc).result;\n    };\n\n    return new DocumentRetriver(this.db)\n      .retriveForQeury(this._query, queryFilter, retrOpts)\n      .then((results) => {\n        if (withFastLimit) {\n          return results;\n        }\n\n        if (this._sorter) {\n          const comparator = this._sorter.getComparator();\n          results.sort(comparator);\n        }\n\n        const skip = this._skip || 0;\n        const limit = this._limit || results.length;\n        return results.slice(skip, limit + skip);\n      }\n    );\n  }\n\n  _ensureMatcherSorter() {\n    this._sorter = undefined;\n    this._matcher = new DocumentMatcher(this._query || {});\n\n    if (this._matcher.hasGeoQuery || this._sort) {\n      this._sorter = new DocumentSorter(\n        this._sort || [], { matcher: this._matcher });\n    }\n  }\n\n  _trackChildCursorPromise(childCursorPromise) {\n    const childCursor = childCursorPromise.cursor;\n    this._childrenCursors[childCursor._id] = childCursor;\n    childCursor._parentCursors[this._id] = this;\n\n    this.once('beforeExecute', () => {\n      delete this._childrenCursors[childCursor._id];\n      delete childCursor._parentCursors[this._id];\n      if (_keys(childCursor._parentCursors).length === 0) {\n        childCursor.emit('beforeExecute');\n      }\n    });\n  }\n\n  _createCursorPromise(promise, mixin = {}) {\n    return _assign({\n      cursor: this,\n      then: (successFn, failFn) => {\n        return this._createCursorPromise(\n          promise.then(successFn, failFn),\n          mixin\n        );\n      },\n    }, mixin);\n  }\n}\n\nexport default Cursor;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/CursorObservable.js":"import _bind from 'fast.js/function/bind';\nimport _check from 'check-types';\nimport _values from 'fast.js/object/values';\nimport _map from 'fast.js/map';\nimport Cursor from './Cursor';\nimport EJSON from './EJSON';\nimport PromiseQueue from './PromiseQueue';\nimport debounce from './debounce';\n\n\n// Defaults\nlet _defaultDebounce = 1000 / 60;\nlet _defaultBatchSize = 10;\n\n/**\n * Observable cursor is used for making request auto-updatable\n * after some changes is happen in a database.\n */\nexport class CursorObservable extends Cursor {\n  constructor(db, query, options) {\n    super(db, query, options);\n    this.maybeUpdate = _bind(this.maybeUpdate, this);\n    this._observers = 0;\n    this._updateQueue = new PromiseQueue(1);\n    this._propagateUpdate = debounce(_bind(this._propagateUpdate, this), 0, 0);\n    this._doUpdate = debounce(\n      _bind(this._doUpdate, this),\n      _defaultDebounce,\n      _defaultBatchSize\n    );\n  }\n\n  static defaultDebounce() {\n    if (arguments.length > 0) {\n      _defaultDebounce = arguments[0];\n    } else {\n      return _defaultDebounce;\n    }\n  }\n\n  static defaultBatchSize() {\n    if (arguments.length > 0) {\n      _defaultBatchSize = arguments[0];\n    } else {\n      return _defaultBatchSize;\n    }\n  }\n\n  /**\n   * Change a batch size of updater.\n   * Btach size is a number of changes must be happen\n   * in debounce interval to force execute debounced\n   * function (update a result, in our case)\n   *\n   * @param  {Number} batchSize\n   * @return {CursorObservable}\n   */\n  batchSize(batchSize) {\n    this._doUpdate.updateBatchSize(batchSize);\n    return this;\n  }\n\n  /**\n   * Change debounce wait time of the updater\n   * @param  {Number} waitTime\n   * @return {CursorObservable}\n   */\n  debounce(waitTime) {\n    this._doUpdate.updateWait(waitTime);\n    return this;\n  }\n\n  /**\n   * Observe changes of the cursor.\n   * It returns a Stopper – Promise with `stop` function.\n   * It is been resolved when first result of cursor is ready and\n   * after first observe listener call.\n   *\n   * @param  {Function}\n   * @param  {Object} options\n   * @return {Stopper}\n   */\n  observe(listener, options = {}) {\n    // Make possible to obbserver w/o callback\n    listener = listener || function() {};\n\n    // Start observing when no observers created\n    if (this._observers <= 0) {\n      this.db.on('insert', this.maybeUpdate);\n      this.db.on('update', this.maybeUpdate);\n      this.db.on('remove', this.maybeUpdate);\n    }\n\n    // Create observe stopper for current listeners\n    let running = true;\n    const self = this;\n    function stopper() {\n      if (running) {\n        running = false;\n        self._observers -= 1;\n        self.removeListener('update', listener);\n        self.removeListener('stop', stopper);\n\n        // Stop observing a cursor if no more observers\n        if (self._observers === 0) {\n          self._latestIds = null;\n          self._latestResult = null;\n          self._updatePromise = null;\n          self.emit('observeStopped');\n          self.db.removeListener('insert', self.maybeUpdate);\n          self.db.removeListener('update', self.maybeUpdate);\n          self.db.removeListener('remove', self.maybeUpdate);\n        }\n      }\n    }\n\n    // Start listening for updates and global stop\n    this._observers += 1;\n    this.on('update', listener);\n    this.on('stop', stopper);\n\n    // Get first result for observer or initiate\n    // update at first time\n    if (!this._updatePromise) {\n      this.update(true, true);\n    } else if (this._latestResult !== null) {\n      listener(this._latestResult);\n    }\n\n    // Wrap returned promise with useful fields\n    const cursorPromiseMixin = { stop: stopper };\n    return this._createCursorPromise(\n      this._updatePromise, cursorPromiseMixin\n    );\n  }\n\n  /**\n   * Stop all observers of the cursor by one call\n   * of this function.\n   * It also stops any delaied update of the cursor.\n   */\n  stopObservers() {\n    this._doUpdate.cancel();\n    this.emit('stop');\n    return this;\n  }\n\n  /**\n   * Executes an update. It is guarantee that\n   * one `_doUpdate` will be executed at one time.\n   * @return {Promise}\n   */\n  update(firstRun = false, immidiatelly = false) {\n    if (!immidiatelly) {\n      if (this._updateDebPromise && !this._updateDebPromise.debouncePassed) {\n        this._doUpdate(firstRun);\n        return this._updatePromise;\n      } else if (\n        this._updateDebAdded &&\n        (!this._updateDebPromise || !this._updateDebPromise.debouncePassed)\n      ) {\n        return this._updatePromise;\n      } else {\n        this._updateDebAdded = true;\n      }\n    }\n\n    this._updatePromise = this._updateQueue.add(() => {\n      if (immidiatelly) {\n        return this._doUpdate.func(firstRun);\n      } else {\n        this._updateDebAdded = true;\n        this._updateDebPromise = this._doUpdate(firstRun);\n        return this._updateDebPromise.then(() => {\n          this._updateDebAdded = false;\n          this._updateDebPromise = null;\n        });\n      }\n    });\n\n    return this._updatePromise;\n  }\n\n  /**\n   * Consider to update a query by given newDoc and oldDoc,\n   * received form insert/udpate/remove oparation.\n   * Should make a decision as smart as possible.\n   * (Don't update a cursor if it does not change a result\n   * of a cursor)\n   *\n   * TODO we should update _latestResult by hands in some cases\n   *      without a calling of `update` method\n   *\n   * @param  {Object} newDoc\n   * @param  {Object} oldDoc\n   */\n  maybeUpdate(newDoc, oldDoc) {\n    // When no newDoc and no oldDoc provided then\n    // it's a special case when no data about update\n    // available and we always need to update a cursor\n    const alwaysUpdateCursor = newDoc === null && oldDoc === null;\n\n    // When it's remove operation we just check\n    // that it's in our latest result ids list\n    const removedFromResult = alwaysUpdateCursor || (\n      !newDoc && oldDoc &&\n      (!this._latestIds || this._latestIds.has(oldDoc._id))\n    );\n\n    // When it's an update operation we check four things\n    // 1. Is a new doc or old doc matched by a query?\n    // 2. Is a new doc has different number of fields then an old doc?\n    // 3. Is a new doc not equals to an old doc?\n    const updatedInResult = removedFromResult || (newDoc && oldDoc && (\n        this._matcher.documentMatches(newDoc).result ||\n        this._matcher.documentMatches(oldDoc).result\n      ) && !EJSON.equals(newDoc, oldDoc)\n    );\n\n    // When it's an insert operation we just check\n    // it's match a query\n    const insertedInResult = updatedInResult || (newDoc && !oldDoc && (\n      this._matcher.documentMatches(newDoc).result\n    ));\n\n    if (insertedInResult) {\n      return this.update();\n    }\n  }\n\n  /**\n   * DEBOUNCED\n   * Emits an update event with current result of a cursor\n   * and call this method on parent cursor if it exists\n   * and if it is not first run of update.\n   * @return {Promise}\n   */\n  _propagateUpdate(firstRun = false) {\n    const updatePromise = this.emitAsync(\n      'update', this._latestResult, firstRun\n    );\n\n    let parentUpdatePromise;\n    if (!firstRun) {\n      parentUpdatePromise = Promise.all(\n        _values(_map(this._parentCursors, (v, k) => {\n          if (v._propagateUpdate) {\n            return v._propagateUpdate(false);\n          }\n        }))\n      );\n    }\n\n    return updatePromise.then(() => parentUpdatePromise);\n  }\n\n  /**\n   * DEBOUNCED\n   * Execute query and propagate result to observers.\n   * Resolved with result of execution.\n   * @param  {Boolean} firstRun\n   * @return {Promise}\n   */\n  _doUpdate(firstRun = false) {\n    if (!firstRun) {\n      this.emit('cursorChanged');\n    }\n\n    return this.exec().then((result) => {\n      this._updateLatestIds();\n      return this._propagateUpdate(firstRun)\n        .then(() => result);\n    });\n  }\n\n  /**\n   * By a `_latestResult` update a `_latestIds` field of\n   * the object\n   */\n  _updateLatestIds() {\n    const idsArr = _check.array(this._latestResult)\n      ? _map(this._latestResult, x => x._id)\n      : this._latestResult && [this._latestResult._id];\n    this._latestIds = new Set(idsArr);\n  }\n\n  /**\n   * Track child cursor and stop child observer\n   * if this cusros stopped or changed.\n   * @param  {CursorPromise} cursorPromise\n   */\n  _trackChildCursorPromise(cursorPromise) {\n    super._trackChildCursorPromise(cursorPromise);\n    if (cursorPromise.stop) {\n      this.once('cursorChanged', cursorPromise.stop);\n      this.once('observeStopped', cursorPromise.stop);\n      this.once('beforeExecute', cursorPromise.stop);\n    }\n  }\n}\n\nexport default CursorObservable;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/debounce.js":"/**\n * Debounce with updetable wait time and force\n * execution on some number of calls (batch execution)\n * Return promise that resolved with result of execution.\n * Promise cerated on each new execution (on idle).\n * @param  {Function} func\n * @param  {Number} wait\n * @param  {Number} batchSize\n * @return {Promise}\n */\nexport default function debounce(func, wait, batchSize) {\n  var timeout = null;\n  var callsCount = 0;\n  var promise = null;\n  var doNotResolve = true;\n  var maybeResolve = null;\n\n  const debouncer = function() {\n    const context = this;\n    const args = arguments;\n\n    if (!promise) {\n      promise = new Promise((resolve, reject) => {\n        maybeResolve = () => {\n          if (doNotResolve) {\n            timeout = setTimeout(maybeResolve, wait);\n            doNotResolve = false;\n          } else {\n            resolve(func.apply(context, args));\n            promise = null;\n            callsCount = 0;\n            timeout = null;\n            doNotResolve = true;\n            maybeResolve = null;\n          }\n        };\n        maybeResolve();\n      });\n    } else {\n      const callNow = batchSize && callsCount >= batchSize;\n      doNotResolve = !callNow;\n\n      if (callNow && maybeResolve) {\n        const returnPromise = promise;\n        returnPromise.debouncePassed = true;\n        clearTimeout(timeout);\n        maybeResolve();\n        callsCount += 1;\n        return returnPromise;\n      }\n    }\n\n    callsCount += 1;\n    return promise;\n  };\n\n\n  const updateBatchSize = function(newBatchSize) {\n    batchSize = newBatchSize;\n  };\n  const updateWait = function(newWait) {\n    wait = newWait;\n  };\n  const cancel = function() {\n    clearTimeout(timeout);\n  };\n\n  debouncer.updateBatchSize = updateBatchSize;\n  debouncer.updateWait = updateWait;\n  debouncer.cancel = cancel;\n  debouncer.func = func;\n  return debouncer;\n}\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/Document.js":"import _check from 'check-types';\nimport _each from 'fast.js/forEach';\nimport _keys from 'fast.js/object/keys';\nimport EJSON from './EJSON';\n\n\n/**\n * Return true if given selector is an\n * object id type (string or number)\n * @param  {Mixed} selector\n * @return {Boolean}\n */\nexport function selectorIsId(selector) {\n  return (\n    _check.string(selector) ||\n    _check.number(selector)\n  );\n}\n\nexport function selectorIsIdPerhapsAsObject(selector) {\n  return (\n    selectorIsId(selector) ||\n    (selector && _check.object(selector) &&\n     selector._id && selectorIsId(selector._id) &&\n     _keys(selector).length === 1)\n  );\n}\n\nexport function isArray(x) {\n  return _check.array(x) && !EJSON.isBinary(x);\n}\n\nexport function isPlainObject(x) {\n  return x && MongoTypeComp._type(x) === 3;\n}\n\nexport function isIndexable(x) {\n  return isArray(x) || isPlainObject(x);\n}\n\n// Returns true if this is an object with at least one key and all keys begin\n// with $.  Unless inconsistentOK is set, throws if some keys begin with $ and\n// others don't.\nexport function isOperatorObject(valueSelector, inconsistentOK) {\n  if (!isPlainObject(valueSelector)) {\n    return false;\n  }\n\n  var theseAreOperators = undefined;\n  _each(valueSelector, function(value, selKey) {\n    var thisIsOperator = selKey.substr(0, 1) === '$';\n    if (theseAreOperators === undefined) {\n      theseAreOperators = thisIsOperator;\n    } else if (theseAreOperators !== thisIsOperator) {\n      if (!inconsistentOK) {\n        throw new Error('Inconsistent operator: ' +\n                        JSON.stringify(valueSelector));\n      }\n      theseAreOperators = false;\n    }\n  });\n  return !!theseAreOperators;  // {} has no operators\n}\n\n\n// string can be converted to integer\nexport function isNumericKey(s) {\n  return /^[0-9]+$/.test(s);\n}\n\n// helpers used by compiled selector code\nexport const MongoTypeComp = {\n  // XXX for _all and _in, consider building 'inquery' at compile time..\n\n  _type: function(v) {\n    if (typeof v === 'number') {\n      return 1;\n    } else if (typeof v === 'string') {\n      return 2;\n    } else if (typeof v === 'boolean') {\n      return 8;\n    } else if (isArray(v)) {\n      return 4;\n    } else if (v === null) {\n      return 10;\n    } else if (v instanceof RegExp) {\n      // note that typeof(/x/) === 'object'\n      return 11;\n    } else if (typeof v === 'function') {\n      return 13;\n    } else if (v instanceof Date) {\n      return 9;\n    } else if (EJSON.isBinary(v)) {\n      return 5;\n    }\n    return 3; // object\n\n    // XXX support some/all of these:\n    // 14, symbol\n    // 15, javascript code with scope\n    // 16, 18: 32-bit/64-bit integer\n    // 17, timestamp\n    // 255, minkey\n    // 127, maxkey\n  },\n\n  // deep equality test: use for literal document and array matches\n  _equal: function(a, b) {\n    return EJSON.equals(a, b, {keyOrderSensitive: true});\n  },\n\n  // maps a type code to a value that can be used to sort values of\n  // different types\n  _typeorder: function(t) {\n    // http://www.mongodb.org/display/DOCS/What+is+the+Compare+Order+for+BSON+Types\n    // XXX what is the correct sort position for Javascript code?\n    // ('100' in the matrix below)\n    // XXX minkey/maxkey\n    return [-1,  // (not a type)\n            1,   // number\n            2,   // string\n            3,   // object\n            4,   // array\n            5,   // binary\n            -1,  // deprecated\n            6,   // ObjectID\n            7,   // bool\n            8,   // Date\n            0,   // null\n            9,   // RegExp\n            -1,  // deprecated\n            100, // JS code\n            2,   // deprecated (symbol)\n            100, // JS code\n            1,   // 32-bit int\n            8,   // Mongo timestamp\n            1,   // 64-bit int\n           ][t];\n  },\n\n  // compare two values of unknown type according to BSON ordering\n  // semantics. (as an extension, consider 'undefined' to be less than\n  // any other value.) return negative if a is less, positive if b is\n  // less, or 0 if equal\n  _cmp: function(a, b) {\n    if (a === undefined) {\n      return b === undefined ? 0 : -1;\n    }\n    if (b === undefined) {\n      return 1;\n    }\n    var ta = MongoTypeComp._type(a);\n    var tb = MongoTypeComp._type(b);\n    var oa = MongoTypeComp._typeorder(ta);\n    var ob = MongoTypeComp._typeorder(tb);\n    if (oa !== ob) {\n      return oa < ob ? -1 : 1;\n    }\n    if (ta !== tb) {\n      // XXX need to implement this if we implement Symbol or integers, or\n      // Timestamp\n      throw Error('Missing type coercion logic in _cmp');\n    }\n    if (ta === 7) { // ObjectID\n      // Convert to string.\n      ta = tb = 2;\n      a = a.toHexString();\n      b = b.toHexString();\n    }\n    if (ta === 9) { // Date\n      // Convert to millis.\n      ta = tb = 1;\n      a = a.getTime();\n      b = b.getTime();\n    }\n\n    if (ta === 1) { // double\n      return a - b;\n    }\n    if (tb === 2) { // string\n      return a < b ? -1 : (a === b ? 0 : 1);\n    }\n    if (ta === 3) { // Object\n      // this could be much more efficient in the expected case ...\n      var to_array = function(obj) {\n        var ret = [];\n        for (var key in obj) {\n          ret.push(key);\n          ret.push(obj[key]);\n        }\n        return ret;\n      };\n      return MongoTypeComp._cmp(to_array(a), to_array(b));\n    }\n    if (ta === 4) { // Array\n      for (var i = 0; ; i++) {\n        if (i === a.length) {\n          return (i === b.length) ? 0 : -1;\n        }\n        if (i === b.length) {\n          return 1;\n        }\n        var s = MongoTypeComp._cmp(a[i], b[i]);\n        if (s !== 0) {\n          return s;\n        }\n      }\n    }\n    if (ta === 5) { // binary\n      // Surprisingly, a small binary blob is always less than a large one in\n      // Mongo.\n      if (a.length !== b.length) {\n        return a.length - b.length;\n      }\n      for (i = 0; i < a.length; i++) {\n        if (a[i] < b[i]) {\n          return -1;\n        }\n        if (a[i] > b[i]) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n    if (ta === 8) { // boolean\n      if (a) {\n        return b ? 0 : 1;\n      }\n      return b ? -1 : 0;\n    }\n    if (ta === 10) { // null\n      return 0;\n    }\n    if (ta === 11) { // regexp\n      throw Error('Sorting not supported on regular expression'); // XXX\n    }\n    // 13: javascript code\n    // 14: symbol\n    // 15: javascript code with scope\n    // 16: 32-bit integer\n    // 17: timestamp\n    // 18: 64-bit integer\n    // 255: minkey\n    // 127: maxkey\n    if (ta === 13) { // javascript code\n      throw Error('Sorting not supported on Javascript code'); // XXX\n    }\n    throw Error('Unknown type to sort');\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/DocumentMatcher.js":"import _check from 'check-types';\nimport _each from 'fast.js/forEach';\nimport _keys from 'fast.js/object/keys';\nimport _map from 'fast.js/map';\nimport _some from 'fast.js/array/some';\nimport _every from 'fast.js/array/every';\nimport _indexOf from 'fast.js/array/indexOf';\nimport GeoJSON from 'geojson-utils';\nimport EJSON from './EJSON';\nimport {selectorIsId, isArray, isPlainObject,\n  isIndexable, isOperatorObject, isNumericKey,\n  MongoTypeComp} from './Document';\n\n\n// The minimongo selector compiler!\n\n// Terminology:\n//  - a 'selector' is the EJSON object representing a selector\n//  - a 'matcher' is its compiled form (whether a full Minimongo.Matcher\n//    object or one of the component lambdas that matches parts of it)\n//  - a 'result object' is an object with a 'result' field and maybe\n//    distance and arrayIndices.\n//  - a 'branched value' is an object with a 'value' field and maybe\n//    'dontIterate' and 'arrayIndices'.\n//  - a 'document' is a top-level object that can be stored in a collection.\n//  - a 'lookup function' is a function that takes in a document and returns\n//    an array of 'branched values'.\n//  - a 'branched matcher' maps from an array of branched values to a result\n//    object.\n//  - an 'element matcher' maps from a single value to a bool.\n\n// Main entry point.\n//   var matcher = new Minimongo.Matcher({a: {$gt: 5}});\n//   if (matcher.documentMatches({a: 7})) ...\nexport class DocumentMatcher {\n  constructor(selector) {\n    // A set (object mapping string -> *) of all of the document paths looked\n    // at by the selector. Also includes the empty string if it may look at any\n    // path (eg, $where).\n    this._paths = {};\n    // Set to true if compilation finds a $near.\n    this._hasGeoQuery = false;\n    // Set to true if compilation finds a $where.\n    this._hasWhere = false;\n    // Set to false if compilation finds anything other than a simple equality or\n    // one or more of '$gt', '$gte', '$lt', '$lte', '$ne', '$in', '$nin' used with\n    // scalars as operands.\n    this._isSimple = true;\n    // Set to a dummy document which always matches this Matcher. Or set to null\n    // if such document is too hard to find.\n    this._matchingDocument = undefined;\n    // A clone of the original selector. It may just be a function if the user\n    // passed in a function; otherwise is definitely an object (eg, IDs are\n    // translated into {_id: ID} first. Used by canBecomeTrueByModifier and\n    // Sorter._useWithMatcher.\n    this._selector = null;\n    this._docMatcher = this._compileSelector(selector);\n  }\n\n  documentMatches(doc) {\n    if (!doc || typeof doc !== 'object') {\n      throw Error('documentMatches needs a document');\n    }\n    return this._docMatcher(doc);\n  }\n\n  get hasGeoQuery() {\n    return this._hasGeoQuery;\n  }\n  get hasWhere() {\n    return this._hasWhere;\n  }\n  get isSimple() {\n    return this._isSimple;\n  }\n\n  // Given a selector, return a function that takes one argument, a\n  // document. It returns a result object.\n  _compileSelector(selector) {\n    // you can pass a literal function instead of a selector\n    if (selector instanceof Function) {\n      this._isSimple = false;\n      this._selector = selector;\n      this._recordPathUsed('');\n      return function(doc) {\n        return {result: !!selector.call(doc)};\n      };\n    }\n\n    // shorthand -- scalars match _id\n    if (selectorIsId(selector)) {\n      this._selector = {_id: selector};\n      this._recordPathUsed('_id');\n      return function(doc) {\n        return {result: EJSON.equals(doc._id, selector)};\n      };\n    }\n\n    // protect against dangerous selectors.  falsey and {_id: falsey} are both\n    // likely programmer error, and not what you want, particularly for\n    // destructive operations.\n    if (!selector || (('_id' in selector) && !selector._id)) {\n      this._isSimple = false;\n      return nothingMatcher;\n    }\n\n    // Top level can't be an array or true or binary.\n    if (\n      typeof(selector) === 'boolean' || isArray(selector) ||\n      EJSON.isBinary(selector)\n    ) {\n      throw new Error('Invalid selector: ' + selector);\n    }\n\n    this._selector = EJSON.clone(selector);\n    return compileDocumentSelector(selector, this, {isRoot: true});\n  }\n\n  _recordPathUsed(path) {\n    this._paths[path] = true;\n  }\n\n  // Returns a list of key paths the given selector is looking for. It includes\n  // the empty string if there is a $where.\n  _getPaths() {\n    return _check.object(this._paths)\n      ? _keys(this._paths) : null;\n  }\n}\n\nexport default DocumentMatcher;\n\n// Takes in a selector that could match a full document (eg, the original\n// selector). Returns a function mapping document->result object.\n//\n// matcher is the Matcher object we are compiling.\n//\n// If this is the root document selector (ie, not wrapped in $and or the like),\n// then isRoot is true. (This is used by $near.)\nvar compileDocumentSelector = function(docSelector, matcher, options = {}) {\n  var docMatchers = [];\n  _each(docSelector, function(subSelector, key) {\n    if (key.substr(0, 1) === '$') {\n      // Outer operators are either logical operators (they recurse back into\n      // this function), or $where.\n      if (!LOGICAL_OPERATORS.hasOwnProperty(key)) {\n        throw new Error('Unrecognized logical operator: ' + key);\n      }\n      matcher._isSimple = false;\n      docMatchers.push(LOGICAL_OPERATORS[key](\n        subSelector, matcher, options.inElemMatch\n      ));\n    } else {\n      // Record this path, but only if we aren't in an elemMatcher, since in an\n      // elemMatch this is a path inside an object in an array, not in the doc\n      // root.\n      if (!options.inElemMatch) {\n        matcher._recordPathUsed(key);\n      }\n      var lookUpByIndex = makeLookupFunction(key);\n      var valueMatcher =\n        compileValueSelector(subSelector, matcher, options.isRoot);\n      docMatchers.push(function(doc) {\n        var branchValues = lookUpByIndex(doc);\n        return valueMatcher(branchValues);\n      });\n    }\n  });\n\n  return andDocumentMatchers(docMatchers);\n};\n\n// Takes in a selector that could match a key-indexed value in a document; eg,\n// {$gt: 5, $lt: 9}, or a regular expression, or any non-expression object (to\n// indicate equality).  Returns a branched matcher: a function mapping\n// [branched value]->result object.\nvar compileValueSelector = function(valueSelector, matcher, isRoot) {\n  if (valueSelector instanceof RegExp) {\n    matcher._isSimple = false;\n    return convertElementMatcherToBranchedMatcher(\n      regexpElementMatcher(valueSelector));\n  } else if (isOperatorObject(valueSelector)) {\n    return operatorBranchedMatcher(valueSelector, matcher, isRoot);\n  } else {\n    return convertElementMatcherToBranchedMatcher(\n      equalityElementMatcher(valueSelector));\n  }\n};\n\n// Given an element matcher (which evaluates a single value), returns a branched\n// value (which evaluates the element matcher on all the branches and returns a\n// more structured return value possibly including arrayIndices).\nvar convertElementMatcherToBranchedMatcher = function(\n    elementMatcher, options = {}) {\n  return function(branches) {\n    var expanded = branches;\n    if (!options.dontExpandLeafArrays) {\n      expanded = expandArraysInBranches(\n        branches, options.dontIncludeLeafArrays);\n    }\n    var ret = {};\n    ret.result = _some(expanded, function(element) {\n      var matched = elementMatcher(element.value);\n\n      // Special case for $elemMatch: it means 'true, and use this as an array\n      // index if I didn't already have one'.\n      if (typeof matched === 'number') {\n        // XXX This code dates from when we only stored a single array index\n        // (for the outermost array). Should we be also including deeper array\n        // indices from the $elemMatch match?\n        if (!element.arrayIndices) {\n          element.arrayIndices = [matched];\n        }\n        matched = true;\n      }\n\n      // If some element matched, and it's tagged with array indices, include\n      // those indices in our result object.\n      if (matched && element.arrayIndices) {\n        ret.arrayIndices = element.arrayIndices;\n      }\n\n      return matched;\n    });\n    return ret;\n  };\n};\n\n// Takes a RegExp object and returns an element matcher.\nexport function regexpElementMatcher(regexp) {\n  return function(value) {\n    if (value instanceof RegExp) {\n      // Comparing two regexps means seeing if the regexps are identical\n      // (really!). Underscore knows how.\n      return String(value) === String(regexp);\n    }\n    // Regexps only work against strings.\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    // Reset regexp's state to avoid inconsistent matching for objects with the\n    // same value on consecutive calls of regexp.test. This happens only if the\n    // regexp has the 'g' flag. Also note that ES6 introduces a new flag 'y' for\n    // which we should *not* change the lastIndex but MongoDB doesn't support\n    // either of these flags.\n    regexp.lastIndex = 0;\n\n    return regexp.test(value);\n  };\n}\n\n// Takes something that is not an operator object and returns an element matcher\n// for equality with that thing.\nexport function equalityElementMatcher(elementSelector) {\n  if (isOperatorObject(elementSelector)) {\n    throw Error('Can\\'t create equalityValueSelector for operator object');\n  }\n\n  // Special-case: null and undefined are equal (if you got undefined in there\n  // somewhere, or if you got it due to some branch being non-existent in the\n  // weird special case), even though they aren't with EJSON.equals.\n  if (elementSelector == null) {  // undefined or null\n    return function(value) {\n      return value == null;  // undefined or null\n    };\n  }\n\n  return function(value) {\n    return MongoTypeComp._equal(elementSelector, value);\n  };\n}\n\n// Takes an operator object (an object with $ keys) and returns a branched\n// matcher for it.\nvar operatorBranchedMatcher = function(valueSelector, matcher, isRoot) {\n  // Each valueSelector works separately on the various branches.  So one\n  // operator can match one branch and another can match another branch.  This\n  // is OK.\n\n  var operatorMatchers = [];\n  _each(valueSelector, function(operand, operator) {\n    // XXX we should actually implement $eq, which is new in 2.6\n    var simpleRange = _indexOf(['$lt', '$lte', '$gt', '$gte'], operator) >= 0 &&\n      _check.number(operand);\n    var simpleInequality = operator === '$ne' && !_check.object(operand);\n    var simpleInclusion = _indexOf(['$in', '$nin'], operator) >= 0 &&\n      _check.array(operand) && !_some(operand, _check.object);\n\n    if (! (operator === '$eq' || simpleRange ||\n           simpleInclusion || simpleInequality)) {\n      matcher._isSimple = false;\n    }\n\n    if (VALUE_OPERATORS.hasOwnProperty(operator)) {\n      operatorMatchers.push(\n        VALUE_OPERATORS[operator](operand, valueSelector, matcher, isRoot));\n    } else if (ELEMENT_OPERATORS.hasOwnProperty(operator)) {\n      var options = ELEMENT_OPERATORS[operator];\n      operatorMatchers.push(\n        convertElementMatcherToBranchedMatcher(\n          options.compileElementSelector(\n            operand, valueSelector, matcher),\n          options));\n    } else {\n      throw new Error('Unrecognized operator: ' + operator);\n    }\n  });\n\n  return andBranchedMatchers(operatorMatchers);\n};\n\nvar compileArrayOfDocumentSelectors = function(\n    selectors, matcher, inElemMatch) {\n  if (!isArray(selectors) || _check.emptyArray(selectors)) {\n    throw Error('$and/$or/$nor must be nonempty array');\n  }\n  return _map(selectors, function(subSelector) {\n    if (!isPlainObject(subSelector)) {\n      throw Error('$or/$and/$nor entries need to be full objects');\n    }\n    return compileDocumentSelector(\n      subSelector, matcher, {inElemMatch: inElemMatch});\n  });\n};\n\n// Operators that appear at the top level of a document selector.\nvar LOGICAL_OPERATORS = {\n  $and: function(subSelector, matcher, inElemMatch) {\n    var matchers = compileArrayOfDocumentSelectors(\n      subSelector, matcher, inElemMatch);\n    return andDocumentMatchers(matchers);\n  },\n\n  $or: function(subSelector, matcher, inElemMatch) {\n    var matchers = compileArrayOfDocumentSelectors(\n      subSelector, matcher, inElemMatch);\n\n    // Special case: if there is only one matcher, use it directly, *preserving*\n    // any arrayIndices it returns.\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n\n    return function(doc) {\n      var result = _some(matchers, function(f) {\n        return f(doc).result;\n      });\n      // $or does NOT set arrayIndices when it has multiple\n      // sub-expressions. (Tested against MongoDB.)\n      return {result: result};\n    };\n  },\n\n  $nor: function(subSelector, matcher, inElemMatch) {\n    var matchers = compileArrayOfDocumentSelectors(\n      subSelector, matcher, inElemMatch);\n    return function(doc) {\n      var result = _every(matchers, function(f) {\n        return !f(doc).result;\n      });\n      // Never set arrayIndices, because we only match if nothing in particular\n      // 'matched' (and because this is consistent with MongoDB).\n      return {result: result};\n    };\n  },\n\n  $where: function(selectorValue, matcher) {\n    // Record that *any* path may be used.\n    matcher._recordPathUsed('');\n    matcher._hasWhere = true;\n    if (!(selectorValue instanceof Function)) {\n      // XXX MongoDB seems to have more complex logic to decide where or or not\n      // to add 'return'; not sure exactly what it is.\n      selectorValue = Function('obj', 'return ' + selectorValue); //eslint-disable-line no-new-func\n    }\n    return function(doc) {\n      // We make the document available as both `this` and `obj`.\n      // XXX not sure what we should do if this throws\n      return {result: selectorValue.call(doc, doc)};\n    };\n  },\n\n  // This is just used as a comment in the query (in MongoDB, it also ends up in\n  // query logs); it has no effect on the actual selection.\n  $comment: function() {\n    return function() {\n      return {result: true};\n    };\n  },\n};\n\n// Returns a branched matcher that matches iff the given matcher does not.\n// Note that this implicitly 'deMorganizes' the wrapped function.  ie, it\n// means that ALL branch values need to fail to match innerBranchedMatcher.\nvar invertBranchedMatcher = function(branchedMatcher) {\n  return function(branchValues) {\n    var invertMe = branchedMatcher(branchValues);\n    // We explicitly choose to strip arrayIndices here: it doesn't make sense to\n    // say 'update the array element that does not match something', at least\n    // in mongo-land.\n    return {result: !invertMe.result};\n  };\n};\n\n// Operators that (unlike LOGICAL_OPERATORS) pertain to individual paths in a\n// document, but (unlike ELEMENT_OPERATORS) do not have a simple definition as\n// 'match each branched value independently and combine with\n// convertElementMatcherToBranchedMatcher'.\nvar VALUE_OPERATORS = {\n  $not: function(operand, valueSelector, matcher) {\n    return invertBranchedMatcher(compileValueSelector(operand, matcher));\n  },\n  $ne: function(operand) {\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(\n      equalityElementMatcher(operand)));\n  },\n  $nin: function(operand) {\n    return invertBranchedMatcher(convertElementMatcherToBranchedMatcher(\n      ELEMENT_OPERATORS.$in.compileElementSelector(operand)));\n  },\n  $exists: function(operand) {\n    var exists = convertElementMatcherToBranchedMatcher(function(value) {\n      return value !== undefined;\n    });\n    return operand ? exists : invertBranchedMatcher(exists);\n  },\n  // $options just provides options for $regex; its logic is inside $regex\n  $options: function(operand, valueSelector) {\n    if (\n      !_check.object(valueSelector) ||\n      !valueSelector.hasOwnProperty('$regex')\n    ) {\n      throw Error('$options needs a $regex');\n    }\n    return everythingMatcher;\n  },\n  // $maxDistance is basically an argument to $near\n  $maxDistance: function(operand, valueSelector) {\n    if (!valueSelector.$near) {\n      throw Error('$maxDistance needs a $near');\n    }\n    return everythingMatcher;\n  },\n  $all: function(operand, valueSelector, matcher) {\n    if (!isArray(operand)) {\n      throw Error('$all requires array');\n    }\n    // Not sure why, but this seems to be what MongoDB does.\n    if (_check.emptyArray(operand)) {\n      return nothingMatcher;\n    }\n\n    var branchedMatchers = [];\n    _each(operand, function(criterion) {\n      // XXX handle $all/$elemMatch combination\n      if (isOperatorObject(criterion)) {\n        throw Error('no $ expressions in $all');\n      }\n      // This is always a regexp or equality selector.\n      branchedMatchers.push(compileValueSelector(criterion, matcher));\n    });\n    // andBranchedMatchers does NOT require all selectors to return true on the\n    // SAME branch.\n    return andBranchedMatchers(branchedMatchers);\n  },\n  $near: function(operand, valueSelector, matcher, isRoot) {\n    if (!isRoot) {\n      throw Error('$near can\\'t be inside another $ operator');\n    }\n    matcher._hasGeoQuery = true;\n\n    // There are two kinds of geodata in MongoDB: coordinate pairs and\n    // GeoJSON. They use different distance metrics, too. GeoJSON queries are\n    // marked with a $geometry property.\n\n    var maxDistance, point, distance;\n    if (isPlainObject(operand) && operand.hasOwnProperty('$geometry')) {\n      // GeoJSON '2dsphere' mode.\n      maxDistance = operand.$maxDistance;\n      point = operand.$geometry;\n      distance = function(value) {\n        // XXX: for now, we don't calculate the actual distance between, say,\n        // polygon and circle. If people care about this use-case it will get\n        // a priority.\n        if (!value || !value.type) {\n          return null;\n        }\n        if (value.type === 'Point') {\n          return GeoJSON.pointDistance(point, value);\n        } else {\n          return GeoJSON.geometryWithinRadius(value, point, maxDistance)\n            ? 0 : maxDistance + 1;\n        }\n      };\n    } else {\n      maxDistance = valueSelector.$maxDistance;\n      if (!isArray(operand) && !isPlainObject(operand)) {\n        throw Error('$near argument must be coordinate pair or GeoJSON');\n      }\n      point = pointToArray(operand);\n      distance = function(value) {\n        if (!isArray(value) && !isPlainObject(value)) {\n          return null;\n        }\n        return distanceCoordinatePairs(point, value);\n      };\n    }\n\n    return function(branchedValues) {\n      // There might be multiple points in the document that match the given\n      // field. Only one of them needs to be within $maxDistance, but we need to\n      // evaluate all of them and use the nearest one for the implicit sort\n      // specifier. (That's why we can't just use ELEMENT_OPERATORS here.)\n      //\n      // Note: This differs from MongoDB's implementation, where a document will\n      // actually show up *multiple times* in the result set, with one entry for\n      // each within-$maxDistance branching point.\n      branchedValues = expandArraysInBranches(branchedValues);\n      var result = {result: false};\n      _each(branchedValues, function(branch) {\n        var curDistance = distance(branch.value);\n        // Skip branches that aren't real points or are too far away.\n        if (curDistance === null || curDistance > maxDistance) {\n          return;\n        }\n        // Skip anything that's a tie.\n        if (result.distance !== undefined && result.distance <= curDistance) {\n          return;\n        }\n        result.result = true;\n        result.distance = curDistance;\n        if (!branch.arrayIndices) {\n          delete result.arrayIndices;\n        } else {\n          result.arrayIndices = branch.arrayIndices;\n        }\n      });\n      return result;\n    };\n  },\n};\n\n// Helpers for $near.\nvar distanceCoordinatePairs = function(a, b) {\n  a = pointToArray(a);\n  b = pointToArray(b);\n  var x = a[0] - b[0];\n  var y = a[1] - b[1];\n  if (!_check.number(x) || !_check.number(y)) {\n    return null;\n  }\n  return Math.sqrt(x * x + y * y);\n};\n\n// Makes sure we get 2 elements array and assume the first one to be x and\n// the second one to y no matter what user passes.\n// In case user passes { lon: x, lat: y } returns [x, y]\nvar pointToArray = function(point) {\n  return _map(point, x => x);\n};\n\n// Helper for $lt/$gt/$lte/$gte.\nvar makeInequality = function(cmpValueComparator) {\n  return {\n    compileElementSelector: function(operand) {\n      // Arrays never compare false with non-arrays for any inequality.\n      // XXX This was behavior we observed in pre-release MongoDB 2.5, but\n      //     it seems to have been reverted.\n      //     See https://jira.mongodb.org/browse/SERVER-11444\n      if (isArray(operand)) {\n        return function() {\n          return false;\n        };\n      }\n\n      // Special case: consider undefined and null the same (so true with\n      // $gte/$lte).\n      if (operand === undefined) {\n        operand = null;\n      }\n\n      var operandType = MongoTypeComp._type(operand);\n\n      return function(value) {\n        if (value === undefined) {\n          value = null;\n        }\n        // Comparisons are never true among things of different type (except\n        // null vs undefined).\n        if (MongoTypeComp._type(value) !== operandType) {\n          return false;\n        }\n        return cmpValueComparator(MongoTypeComp._cmp(value, operand));\n      };\n    },\n  };\n};\n\n// Each element selector contains:\n//  - compileElementSelector, a function with args:\n//    - operand - the 'right hand side' of the operator\n//    - valueSelector - the 'context' for the operator (so that $regex can find\n//      $options)\n//    - matcher - the Matcher this is going into (so that $elemMatch can compile\n//      more things)\n//    returning a function mapping a single value to bool.\n//  - dontExpandLeafArrays, a bool which prevents expandArraysInBranches from\n//    being called\n//  - dontIncludeLeafArrays, a bool which causes an argument to be passed to\n//    expandArraysInBranches if it is called\nexport var ELEMENT_OPERATORS = {\n  $lt: makeInequality(function(cmpValue) {\n    return cmpValue < 0;\n  }),\n  $gt: makeInequality(function(cmpValue) {\n    return cmpValue > 0;\n  }),\n  $lte: makeInequality(function(cmpValue) {\n    return cmpValue <= 0;\n  }),\n  $gte: makeInequality(function(cmpValue) {\n    return cmpValue >= 0;\n  }),\n  $mod: {\n    compileElementSelector: function(operand) {\n      if (!(isArray(operand) && operand.length === 2\n            && typeof(operand[0]) === 'number'\n            && typeof(operand[1]) === 'number')) {\n        throw Error('argument to $mod must be an array of two numbers');\n      }\n      // XXX could require to be ints or round or something\n      var divisor = operand[0];\n      var remainder = operand[1];\n      return function(value) {\n        return typeof value === 'number' && value % divisor === remainder;\n      };\n    },\n  },\n  $in: {\n    compileElementSelector: function(operand) {\n      if (!isArray(operand)) {\n        throw Error('$in needs an array');\n      }\n\n      var elementMatchers = [];\n      _each(operand, function(option) {\n        if (option instanceof RegExp) {\n          elementMatchers.push(regexpElementMatcher(option));\n        } else if (isOperatorObject(option)) {\n          throw Error('cannot nest $ under $in');\n        } else {\n          elementMatchers.push(equalityElementMatcher(option));\n        }\n      });\n\n      return function(value) {\n        // Allow {a: {$in: [null]}} to match when 'a' does not exist.\n        if (value === undefined) {\n          value = null;\n        }\n        return _some(elementMatchers, function(e) {\n          return e(value);\n        });\n      };\n    },\n  },\n  $size: {\n    // {a: [[5, 5]]} must match {a: {$size: 1}} but not {a: {$size: 2}}, so we\n    // don't want to consider the element [5,5] in the leaf array [[5,5]] as a\n    // possible value.\n    dontExpandLeafArrays: true,\n    compileElementSelector: function(operand) {\n      if (typeof operand === 'string') {\n        // Don't ask me why, but by experimentation, this seems to be what Mongo\n        // does.\n        operand = 0;\n      } else if (typeof operand !== 'number') {\n        throw Error('$size needs a number');\n      }\n      return function(value) {\n        return isArray(value) && value.length === operand;\n      };\n    },\n  },\n  $type: {\n    // {a: [5]} must not match {a: {$type: 4}} (4 means array), but it should\n    // match {a: {$type: 1}} (1 means number), and {a: [[5]]} must match {$a:\n    // {$type: 4}}. Thus, when we see a leaf array, we *should* expand it but\n    // should *not* include it itself.\n    dontIncludeLeafArrays: true,\n    compileElementSelector: function(operand) {\n      if (typeof operand !== 'number') {\n        throw Error('$type needs a number');\n      }\n      return function(value) {\n        return value !== undefined\n          && MongoTypeComp._type(value) === operand;\n      };\n    },\n  },\n  $regex: {\n    compileElementSelector: function(operand, valueSelector) {\n      if (!(typeof operand === 'string' || operand instanceof RegExp)) {\n        throw Error('$regex has to be a string or RegExp');\n      }\n\n      var regexp;\n      if (valueSelector.$options !== undefined) {\n        // Options passed in $options (even the empty string) always overrides\n        // options in the RegExp object itself. (See also\n        // Mongo.Collection._rewriteSelector.)\n\n        // Be clear that we only support the JS-supported options, not extended\n        // ones (eg, Mongo supports x and s). Ideally we would implement x and s\n        // by transforming the regexp, but not today...\n        if (/[^gim]/.test(valueSelector.$options)) {\n          throw new Error('Only the i, m, and g regexp options are supported');\n        }\n\n        var regexSource = operand instanceof RegExp ? operand.source : operand;\n        regexp = new RegExp(regexSource, valueSelector.$options);\n      } else if (operand instanceof RegExp) {\n        regexp = operand;\n      } else {\n        regexp = new RegExp(operand);\n      }\n      return regexpElementMatcher(regexp);\n    },\n  },\n  $elemMatch: {\n    dontExpandLeafArrays: true,\n    compileElementSelector: function(operand, valueSelector, matcher) {\n      if (!isPlainObject(operand)) {\n        throw Error('$elemMatch need an object');\n      }\n\n      var subMatcher, isDocMatcher;\n      if (isOperatorObject(operand, true)) {\n        subMatcher = compileValueSelector(operand, matcher);\n        isDocMatcher = false;\n      } else {\n        // This is NOT the same as compileValueSelector(operand), and not just\n        // because of the slightly different calling convention.\n        // {$elemMatch: {x: 3}} means 'an element has a field x:3', not\n        // 'consists only of a field x:3'. Also, regexps and sub-$ are allowed.\n        subMatcher = compileDocumentSelector(operand, matcher,\n                                             {inElemMatch: true});\n        isDocMatcher = true;\n      }\n\n      return function(value) {\n        if (!isArray(value)) {\n          return false;\n        }\n        for (var i = 0; i < value.length; ++i) {\n          var arrayElement = value[i];\n          var arg;\n          if (isDocMatcher) {\n            // We can only match {$elemMatch: {b: 3}} against objects.\n            // (We can also match against arrays, if there's numeric indices,\n            // eg {$elemMatch: {'0.b': 3}} or {$elemMatch: {0: 3}}.)\n            if (!isPlainObject(arrayElement) && !isArray(arrayElement)) {\n              return false;\n            }\n            arg = arrayElement;\n          } else {\n            // dontIterate ensures that {a: {$elemMatch: {$gt: 5}}} matches\n            // {a: [8]} but not {a: [[8]]}\n            arg = [{value: arrayElement, dontIterate: true}];\n          }\n          // XXX support $near in $elemMatch by propagating $distance?\n          if (subMatcher(arg).result) {\n            return i;   // specially understood to mean 'use as arrayIndices'\n          }\n        }\n        return false;\n      };\n    },\n  },\n};\n\n// makeLookupFunction(key) returns a lookup function.\n//\n// A lookup function takes in a document and returns an array of matching\n// branches.  If no arrays are found while looking up the key, this array will\n// have exactly one branches (possibly 'undefined', if some segment of the key\n// was not found).\n//\n// If arrays are found in the middle, this can have more than one element, since\n// we 'branch'. When we 'branch', if there are more key segments to look up,\n// then we only pursue branches that are plain objects (not arrays or scalars).\n// This means we can actually end up with no branches!\n//\n// We do *NOT* branch on arrays that are found at the end (ie, at the last\n// dotted member of the key). We just return that array; if you want to\n// effectively 'branch' over the array's values, post-process the lookup\n// function with expandArraysInBranches.\n//\n// Each branch is an object with keys:\n//  - value: the value at the branch\n//  - dontIterate: an optional bool; if true, it means that 'value' is an array\n//    that expandArraysInBranches should NOT expand. This specifically happens\n//    when there is a numeric index in the key, and ensures the\n//    perhaps-surprising MongoDB behavior where {'a.0': 5} does NOT\n//    match {a: [[5]]}.\n//  - arrayIndices: if any array indexing was done during lookup (either due to\n//    explicit numeric indices or implicit branching), this will be an array of\n//    the array indices used, from outermost to innermost; it is falsey or\n//    absent if no array index is used. If an explicit numeric index is used,\n//    the index will be followed in arrayIndices by the string 'x'.\n//\n//    Note: arrayIndices is used for two purposes. First, it is used to\n//    implement the '$' modifier feature, which only ever looks at its first\n//    element.\n//\n//    Second, it is used for sort key generation, which needs to be able to tell\n//    the difference between different paths. Moreover, it needs to\n//    differentiate between explicit and implicit branching, which is why\n//    there's the somewhat hacky 'x' entry: this means that explicit and\n//    implicit array lookups will have different full arrayIndices paths. (That\n//    code only requires that different paths have different arrayIndices; it\n//    doesn't actually 'parse' arrayIndices. As an alternative, arrayIndices\n//    could contain objects with flags like 'implicit', but I think that only\n//    makes the code surrounding them more complex.)\n//\n//    (By the way, this field ends up getting passed around a lot without\n//    cloning, so never mutate any arrayIndices field/var in this package!)\n//\n//\n// At the top level, you may only pass in a plain object or array.\n//\n// See the test 'minimongo - lookup' for some examples of what lookup functions\n// return.\nexport function makeLookupFunction(key, options) {\n  options = options || {};\n  var parts = key.split('.');\n  var firstPart = parts.length ? parts[0] : '';\n  var firstPartIsNumeric = isNumericKey(firstPart);\n  var nextPartIsNumeric = parts.length >= 2 && isNumericKey(parts[1]);\n  var lookupRest;\n  if (parts.length > 1) {\n    lookupRest = makeLookupFunction(parts.slice(1).join('.'));\n  }\n\n  var omitUnnecessaryFields = function(retVal) {\n    if (!retVal.dontIterate) {\n      delete retVal.dontIterate;\n    }\n    if (retVal.arrayIndices && !retVal.arrayIndices.length) {\n      delete retVal.arrayIndices;\n    }\n    return retVal;\n  };\n\n  // Doc will always be a plain object or an array.\n  // apply an explicit numeric index, an array.\n  return function(doc, arrayIndices) {\n    if (!arrayIndices) {\n      arrayIndices = [];\n    }\n\n    if (isArray(doc)) {\n      // If we're being asked to do an invalid lookup into an array (non-integer\n      // or out-of-bounds), return no results (which is different from returning\n      // a single undefined result, in that `null` equality checks won't match).\n      if (!(firstPartIsNumeric && firstPart < doc.length)) {\n        return [];\n      }\n\n      // Remember that we used this array index. Include an 'x' to indicate that\n      // the previous index came from being considered as an explicit array\n      // index (not branching).\n      arrayIndices = arrayIndices.concat(+firstPart, 'x');\n    }\n\n    // Do our first lookup.\n    var firstLevel = doc[firstPart];\n\n    // If there is no deeper to dig, return what we found.\n    //\n    // If what we found is an array, most value selectors will choose to treat\n    // the elements of the array as matchable values in their own right, but\n    // that's done outside of the lookup function. (Exceptions to this are $size\n    // and stuff relating to $elemMatch.  eg, {a: {$size: 2}} does not match {a:\n    // [[1, 2]]}.)\n    //\n    // That said, if we just did an *explicit* array lookup (on doc) to find\n    // firstLevel, and firstLevel is an array too, we do NOT want value\n    // selectors to iterate over it.  eg, {'a.0': 5} does not match {a: [[5]]}.\n    // So in that case, we mark the return value as 'don't iterate'.\n    if (!lookupRest) {\n      return [omitUnnecessaryFields({\n        value: firstLevel,\n        dontIterate: isArray(doc) && isArray(firstLevel),\n        arrayIndices: arrayIndices})];\n    }\n\n    // We need to dig deeper.  But if we can't, because what we've found is not\n    // an array or plain object, we're done. If we just did a numeric index into\n    // an array, we return nothing here (this is a change in Mongo 2.5 from\n    // Mongo 2.4, where {'a.0.b': null} stopped matching {a: [5]}). Otherwise,\n    // return a single `undefined` (which can, for example, match via equality\n    // with `null`).\n    if (!isIndexable(firstLevel)) {\n      if (isArray(doc)) {\n        return [];\n      }\n      return [omitUnnecessaryFields({\n        value: undefined,\n        arrayIndices: arrayIndices,\n      })];\n    }\n\n    var result = [];\n    var appendToResult = function(more) {\n      Array.prototype.push.apply(result, more);\n    };\n\n    // Dig deeper: look up the rest of the parts on whatever we've found.\n    // (lookupRest is smart enough to not try to do invalid lookups into\n    // firstLevel if it's an array.)\n    appendToResult(lookupRest(firstLevel, arrayIndices));\n\n    // If we found an array, then in *addition* to potentially treating the next\n    // part as a literal integer lookup, we should also 'branch': try to look up\n    // the rest of the parts on each array element in parallel.\n    //\n    // In this case, we *only* dig deeper into array elements that are plain\n    // objects. (Recall that we only got this far if we have further to dig.)\n    // This makes sense: we certainly don't dig deeper into non-indexable\n    // objects. And it would be weird to dig into an array: it's simpler to have\n    // a rule that explicit integer indexes only apply to an outer array, not to\n    // an array you find after a branching search.\n    //\n    // In the special case of a numeric part in a *sort selector* (not a query\n    // selector), we skip the branching: we ONLY allow the numeric part to mean\n    // 'look up this index' in that case, not 'also look up this index in all\n    // the elements of the array'.\n    if (isArray(firstLevel) && !(nextPartIsNumeric && options.forSort)) {\n      _each(firstLevel, function(branch, arrayIndex) {\n        if (isPlainObject(branch)) {\n          appendToResult(lookupRest(\n            branch,\n            arrayIndices.concat(arrayIndex)));\n        }\n      });\n    }\n\n    return result;\n  };\n}\n\nexport function expandArraysInBranches(branches, skipTheArrays) {\n  var branchesOut = [];\n  _each(branches, function(branch) {\n    var thisIsArray = isArray(branch.value);\n    // We include the branch itself, *UNLESS* we it's an array that we're going\n    // to iterate and we're told to skip arrays.  (That's right, we include some\n    // arrays even skipTheArrays is true: these are arrays that were found via\n    // explicit numerical indices.)\n    if (!(skipTheArrays && thisIsArray && !branch.dontIterate)) {\n      branchesOut.push({\n        value: branch.value,\n        arrayIndices: branch.arrayIndices,\n      });\n    }\n    if (thisIsArray && !branch.dontIterate) {\n      _each(branch.value, function(leaf, i) {\n        branchesOut.push({\n          value: leaf,\n          arrayIndices: (branch.arrayIndices || []).concat(i),\n        });\n      });\n    }\n  });\n  return branchesOut;\n}\n\nvar nothingMatcher = function(docOrBranchedValues) {\n  return {result: false};\n};\n\nvar everythingMatcher = function(docOrBranchedValues) {\n  return {result: true};\n};\n\n\n// NB: We are cheating and using this function to implement 'AND' for both\n// 'document matchers' and 'branched matchers'. They both return result objects\n// but the argument is different: for the former it's a whole doc, whereas for\n// the latter it's an array of 'branched values'.\nvar andSomeMatchers = function(subMatchers) {\n  if (subMatchers.length === 0) {\n    return everythingMatcher;\n  }\n  if (subMatchers.length === 1) {\n    return subMatchers[0];\n  }\n\n  return function(docOrBranches) {\n    var ret = {};\n    ret.result = _every(subMatchers, function(f) {\n      var subResult = f(docOrBranches);\n      // Copy a 'distance' number out of the first sub-matcher that has\n      // one. Yes, this means that if there are multiple $near fields in a\n      // query, something arbitrary happens; this appears to be consistent with\n      // Mongo.\n      if (subResult.result && subResult.distance !== undefined\n          && ret.distance === undefined) {\n        ret.distance = subResult.distance;\n      }\n      // Similarly, propagate arrayIndices from sub-matchers... but to match\n      // MongoDB behavior, this time the *last* sub-matcher with arrayIndices\n      // wins.\n      if (subResult.result && subResult.arrayIndices) {\n        ret.arrayIndices = subResult.arrayIndices;\n      }\n      return subResult.result;\n    });\n\n    // If we didn't actually match, forget any extra metadata we came up with.\n    if (!ret.result) {\n      delete ret.distance;\n      delete ret.arrayIndices;\n    }\n    return ret;\n  };\n};\n\nvar andDocumentMatchers = andSomeMatchers;\nvar andBranchedMatchers = andSomeMatchers;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/DocumentModifier.js":"import _check from 'check-types';\nimport _assign from 'fast.js/object/assign';\nimport _each from 'fast.js/forEach';\nimport _every from 'fast.js/array/every';\nimport EJSON from './EJSON';\nimport Random from './Random';\nimport DocumentMatcher from './DocumentMatcher';\nimport DocumentSorter from './DocumentSorter';\nimport {isPlainObject, isIndexable, isOperatorObject,\n  isNumericKey, MongoTypeComp} from './Document';\n\n\nexport class DocumentModifier {\n  constructor(query = {}) {\n    this._query = query;\n    this._matcher = new DocumentMatcher(query);\n  }\n\n  modify(docs, mod = {}, options = {}) {\n    const oldResults = [];\n    const newResults = [];\n\n    // Regular update\n    _each(docs, (d) => {\n      const match = this._matcher.documentMatches(d);\n      if (match.result) {\n        const matchOpts = _assign(\n          {arrayIndices: match.arrayIndices},\n          options\n        );\n        const newDoc = this._modifyDocument(d, mod, matchOpts);\n        newResults.push(newDoc);\n        oldResults.push(d);\n      }\n    });\n\n    // Upsert update\n    if (!newResults.length && options.upsert) {\n      let newDoc = documentBySelector(this._query);\n      newDoc._id = newDoc._id || Random.default().id(17);\n      newDoc = this._modifyDocument(newDoc, mod, {isInsert: true});\n      newResults.push(newDoc);\n      oldResults.push(null);\n    }\n\n    return {\n      updated: newResults,\n      original: oldResults,\n    };\n  }\n\n  // XXX need a strategy for passing the binding of $ into this\n  // function, from the compiled selector\n  //\n  // maybe just {key.up.to.just.before.dollarsign: array_index}\n  //\n  // XXX atomicity: if one modification fails, do we roll back the whole\n  // change?\n  //\n  // options:\n  //   - isInsert is set when _modify is being called to compute the document to\n  //     insert as part of an upsert operation. We use this primarily to figure\n  //     out when to set the fields in $setOnInsert, if present.\n  _modifyDocument(doc, mod, options = {}) {\n    if (!isPlainObject(mod)) {\n      throw new Error('Modifier must be an object');\n    }\n\n    // Make sure the caller can't mutate our data structures.\n    mod = EJSON.clone(mod);\n    var isModifier = isOperatorObject(mod);\n    var newDoc;\n\n    if (!isModifier) {\n      if (!options.isInsert && mod._id && !EJSON.equals(doc._id, mod._id)) {\n        throw new Error('Cannot change the _id of a document');\n      }\n\n      // replace the whole document\n      for (var k in mod) {\n        if (/\\./.test(k)) {\n          throw new Error(\n            'When replacing document, field name may not contain \\'.\\'');\n        }\n      }\n      newDoc = mod;\n      newDoc._id = doc._id;\n    } else {\n      // apply modifiers to the doc.\n      newDoc = EJSON.clone(doc);\n\n      _each(mod, function(operand, op) {\n        var modFunc = MODIFIERS[op];\n        // Treat $setOnInsert as $set if this is an insert.\n        if (options.isInsert && op === '$setOnInsert') {\n          modFunc = MODIFIERS.$set;\n        }\n        if (!modFunc) {\n          throw new Error('Invalid modifier specified ' + op);\n        }\n        _each(operand, function(arg, keypath) {\n          if (keypath === '') {\n            throw new Error('An empty update path is not valid.');\n          }\n          if (keypath === '_id' && !options.isInsert) {\n            throw new Error('Mod on _id not allowed for update.');\n          }\n\n          var keyparts = keypath.split('.');\n\n          if (! _every(keyparts, x => x)) {\n            throw new Error(\n              'The update path \\'' + keypath +\n                '\\' contains an empty field name, which is not allowed.');\n          }\n\n          var target = findModTarget(newDoc, keyparts, {\n            noCreate: NO_CREATE_MODIFIERS[op],\n            forbidArray: (op === '$rename'),\n            arrayIndices: options.arrayIndices,\n          });\n          var field = keyparts.pop();\n          modFunc(target, field, arg, keypath, newDoc);\n        });\n      });\n    }\n\n    return newDoc;\n  }\n}\n\nexport default DocumentModifier;\n\n\n// by given selector returns an object that should\n// be used for upsert operation\nvar documentBySelector = function(selector) {\n  var selectorDoc = {};\n\n  if (!_check.object(selector)) {\n    selector = {_id: selector};\n  }\n\n  _each(selector, (v, k) => {\n    if (k.substr(0, 1) !== '$' && !isOperatorObject(v, true)) {\n      const keyparts = k.split('.');\n      const modTarget = findModTarget(selectorDoc, keyparts);\n      if (modTarget) {\n        modTarget[keyparts[keyparts.length - 1]] = v;\n      }\n    }\n  });\n\n  return selectorDoc;\n};\n\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nexport const findModTarget = function(doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = (i === keyparts.length - 1);\n    var keypart = keyparts[i];\n    var indexable = isIndexable(doc);\n    if (!indexable) {\n      if (options.noCreate) {\n        return undefined;\n      }\n      var e = new Error(\n        'cannot use the part \\'' + keypart + '\\' to traverse ' + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (doc instanceof Array) {\n      if (options.forbidArray) {\n        return null;\n      }\n      if (keypart === '$') {\n        if (usedArrayIndex) {\n          throw new Error('Too many positional (i.e. \\'$\\') elements');\n        }\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw new Error('The positional operator did not find the ' +\n                               'match needed from the query');\n        }\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart, 10);\n      } else {\n        if (options.noCreate) {\n          return undefined;\n        }\n        throw new Error(\n          'can\\'t append to array using string field name ['\n                    + keypart + ']');\n      }\n      if (last) {\n        // handle 'a.01'\n        keyparts[i] = keypart;\n      }\n      if (options.noCreate && keypart >= doc.length) {\n        return undefined;\n      }\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n      if (!last) {\n        if (doc.length === keypart) {\n          doc.push({});\n        } else if (typeof doc[keypart] !== 'object') {\n          throw new Error('can\\'t modify field \\'' + keyparts[i + 1] +\n                      '\\' of list value ' + JSON.stringify(doc[keypart]));\n        }\n      }\n    } else {\n      if (keypart.length && keypart.substr(0, 1) === '$') {\n        throw new Error('can\\'t set field named ' + keypart);\n      }\n      if (!(keypart in doc)) {\n        if (options.noCreate) {\n          return undefined;\n        }\n        if (!last) {\n          doc[keypart] = {};\n        }\n      }\n    }\n\n    if (last) {\n      return doc;\n    }\n    doc = doc[keypart];\n  }\n\n  // notreached\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true,\n};\n\nvar MODIFIERS = {\n  $inc: function(target, field, arg) {\n    if (typeof arg !== 'number') {\n      throw new Error('Modifier $inc allowed for numbers only');\n    }\n    if (field in target) {\n      if (typeof target[field] !== 'number') {\n        throw new Error('Cannot apply $inc modifier to non-number');\n      }\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function(target, field, arg) {\n    if (!_check.object(target) && !_check.array(target)) {\n      const e = new Error('Cannot set property on non-object field');\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (target === null) {\n      const e = new Error('Cannot set property on null');\n      e.setPropertyError = true;\n      throw e;\n    }\n    target[field] = arg;\n  },\n  $setOnInsert: function(target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset: function(target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) {\n          target[field] = null;\n        }\n      } else {\n        delete target[field];\n      }\n    }\n  },\n  $push: function(target, field, arg) {\n    if (target[field] === undefined) {\n      target[field] = [];\n    }\n    if (!(target[field] instanceof Array)) {\n      throw new Error('Cannot apply $push modifier to non-array');\n    }\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      target[field].push(arg);\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array)) {\n      throw new Error('$each must be an array');\n    }\n\n    // Parse $position\n    var position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== 'number') {\n        throw new Error('$position must be a numeric value');\n      }\n      // XXX should check to make sure integer\n      if (arg.$position < 0) {\n        throw new Error('$position in $push must be zero or positive');\n      }\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    var slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== 'number') {\n        throw new Error('$slice must be a numeric value');\n      }\n      // XXX should check to make sure integer\n      if (arg.$slice > 0) {\n        throw new Error('$slice in $push must be zero or negative');\n      }\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    var sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined) {\n        throw new Error('$sort requires $slice to be present');\n      }\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new DocumentSorter(arg.$sort).getComparator();\n      for (var i = 0; i < toPush.length; i++) {\n        if (MongoTypeComp._type(toPush[i]) !== 3) {\n          throw new Error('$push like modifiers using $sort ' +\n                      'require all elements to be objects');\n        }\n      }\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      for (let j = 0; j < toPush.length; j++) {\n        target[field].push(toPush[j]);\n      }\n    } else {\n      var spliceArguments = [position, 0];\n      for (let j = 0; j < toPush.length; j++) {\n        spliceArguments.push(toPush[j]);\n      }\n      Array.prototype.splice.apply(target[field], spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction) {\n      target[field].sort(sortFunction);\n    }\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0) {\n        target[field] = [];  // differs from Array.slice!\n      } else {\n        target[field] = target[field].slice(slice);\n      }\n    }\n  },\n  $pushAll: function(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw new Error('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n    var x = target[field];\n    if (x === undefined) {\n      target[field] = arg;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $pushAll modifier to non-array');\n    } else {\n      for (var i = 0; i < arg.length; i++) {\n        x.push(arg[i]);\n      }\n    }\n  },\n  $addToSet: function(target, field, arg) {\n    var isEach = false;\n    if (typeof arg === 'object') {\n      //check if first key is '$each'\n      for (var k in arg) {\n        if (k === '$each') {\n          isEach = true;\n        }\n        break;\n      }\n    }\n    var values = isEach ? arg.$each : [arg];\n    var x = target[field];\n    if (x === undefined) {\n      target[field] = values;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $addToSet modifier to non-array');\n    } else {\n      _each(values, function(value) {\n        for (let i = 0; i < x.length; i++) {\n          if (MongoTypeComp._equal(value, x[i])) {\n            return;\n          }\n        }\n        x.push(value);\n      });\n    }\n  },\n  $pop: function(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n    var x = target[field];\n    if (x === undefined) {\n      return;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $pop modifier to non-array');\n    } else {\n      if (typeof arg === 'number' && arg < 0) {\n        x.splice(0, 1);\n      } else {\n        x.pop();\n      }\n    }\n  },\n  $pull: function(target, field, arg) {\n    if (target === undefined) {\n      return;\n    }\n    var x = target[field];\n    if (x === undefined) {\n      return;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $pull/pullAll modifier to non-array');\n    } else {\n      var out = [];\n      if (arg != null && typeof arg === 'object' && !(arg instanceof Array)) {\n        // XXX would be much nicer to compile this once, rather than\n        // for each document we modify.. but usually we're not\n        // modifying that many documents, so we'll let it slide for\n        // now\n\n        // XXX Minimongo.Matcher isn't up for the job, because we need\n        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n        // like {$gt: 4} is not normally a complete selector.\n        // same issue as $elemMatch possibly?\n        var matcher = new DocumentMatcher(arg);\n        for (let i = 0; i < x.length; i++) {\n          if (!matcher.documentMatches(x[i]).result) {\n            out.push(x[i]);\n          }\n        }\n      } else {\n        for (let i = 0; i < x.length; i++) {\n          if (!MongoTypeComp._equal(x[i], arg)) {\n            out.push(x[i]);\n          }\n        }\n      }\n      target[field] = out;\n    }\n  },\n  $pullAll: function(target, field, arg) {\n    if (!(typeof arg === 'object' && arg instanceof Array)) {\n      throw new Error('Modifier $pushAll/pullAll allowed for arrays only');\n    }\n    if (target === undefined) {\n      return;\n    }\n    var x = target[field];\n    if (x === undefined) {\n      return;\n    } else if (!(x instanceof Array)) {\n      throw new Error('Cannot apply $pull/pullAll modifier to non-array');\n    } else {\n      var out = [];\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n        for (var j = 0; j < arg.length; j++) {\n          if (MongoTypeComp._equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n        if (!exclude) {\n          out.push(x[i]);\n        }\n      }\n      target[field] = out;\n    }\n  },\n  $rename: function(target, field, arg, keypath, doc) {\n    if (keypath === arg) {\n      // no idea why mongo has this restriction..\n      throw new Error('$rename source must differ from target');\n    }\n    if (target === null) {\n      throw new Error('$rename source field invalid');\n    }\n    if (typeof arg !== 'string') {\n      throw new Error('$rename target must be a string');\n    }\n    if (target === undefined) {\n      return;\n    }\n    var v = target[field];\n    delete target[field];\n\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {forbidArray: true});\n    if (target2 === null) {\n      throw new Error('$rename target field invalid');\n    }\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function(target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw new Error('$bit is not supported');\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/DocumentProjector.js":"import _check from 'check-types';\nimport _each from 'fast.js/forEach';\nimport _keys from 'fast.js/object/keys';\nimport _assign from 'fast.js/object/assign';\nimport _every from 'fast.js/array/every';\nimport _filter from 'fast.js/array/filter';\nimport _map from 'fast.js/map';\nimport _indexOf from 'fast.js/array/indexOf';\nimport EJSON from './EJSON';\nimport { isNumericKey } from './Document';\n\n\n// Internals\nfunction _has(obj, key) {\n  return _check.object(obj) && obj.hasOwnProperty(key);\n}\n\n\n/**\n * A wrapper around pojection functions.\n */\nexport default class DocumentProjector {\n  constructor(fields) {\n    this.fields = fields;\n    this._projector = compileProjection(fields);\n  }\n\n  project(docs) {\n    if (_check.array(docs)) {\n      return _map(docs, (doc) => this._projector(doc));\n    } else {\n      return this._projector(docs);\n    }\n  }\n}\n\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nexport function compileProjection(fields) {\n  checkSupportedProjection(fields);\n\n  var _idProjection = fields._id === undefined ? true : fields._id;\n  var details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  var transform = (doc, ruleTree) => {\n    // Special case for 'sets'\n    if (_check.array(doc)) {\n      return _map(doc, (subdoc) => transform(subdoc, ruleTree));\n    }\n\n    var res = details.including ? {} : EJSON.clone(doc);\n    _each(ruleTree, (rule, key) => {\n      if (!_has(doc, key)) {\n        return;\n      }\n      if (_check.object(rule)) {\n        // For sub-objects/subsets we branch\n        if (_check.object(doc[key]) || _check.array(doc[key])) {\n          res[key] = transform(doc[key], rule);\n        }\n        // Otherwise we don't even touch this subfield\n      } else if (details.including) {\n        res[key] = EJSON.clone(doc[key]);\n      } else {\n        delete res[key];\n      }\n    });\n\n    return res;\n  };\n\n  return (obj) => {\n    var res = transform(obj, details.tree);\n    if (_idProjection && _has(obj, '_id')) {\n      res._id = obj._id;\n    }\n    if (!_idProjection && _has(res, '_id')) {\n      delete res._id;\n    }\n    return res;\n  };\n}\n\n\n// Rise an exception if fields object contains\n// some unsupported fields or values\nexport function checkSupportedProjection(fields) {\n  if (!_check.object(fields) || _check.array(fields)) {\n    throw Error('fields option must be an object');\n  }\n\n  _each(fields, (val, keyPath) => {\n    const valKeys = (_check.object(val) && _keys(val)) || [];\n    if (_indexOf(keyPath.split('.'), '$') >= 0) {\n      throw Error('Minimongo doesn\\'t support $ operator in projections yet.');\n    }\n    if (typeof val === 'object' && (\n        _indexOf(valKeys, '$elemMatch') >= 0 ||\n        _indexOf(valKeys, '$meta') >= 0 ||\n        _indexOf(valKeys, '$slice') >= 0\n        )\n    ) {\n      throw Error('Minimongo doesn\\'t support operators in projections yet.');\n    }\n    if (_indexOf([1, 0, true, false], val) === -1) {\n      throw Error('Projection values should be one of 1, 0, true, or false');\n    }\n  });\n}\n\n\n// Traverses the keys of passed projection and constructs a tree where all\n// leaves are either all True or all False\n// @returns Object:\n//  - tree - Object - tree representation of keys involved in projection\n//  (exception for '_id' as it is a special case handled separately)\n//  - including - Boolean - 'take only certain fields' type of projection\nexport function projectionDetails(fields) {\n  // Find the non-_id keys (_id is handled specially because it is included unless\n  // explicitly excluded). Sort the keys, so that our code to detect overlaps\n  // like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n  var fieldsKeys = _keys(fields).sort();\n\n  // If _id is the only field in the projection, do not remove it, since it is\n  // required to determine if this is an exclusion or exclusion. Also keep an\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\n  // inclusive and exclusive fields. If _id is not the only field in the\n  // projection and is exclusive, remove it so it can be handled later by a\n  // special case, since exclusive _id is always allowed.\n  if (\n    fieldsKeys.length > 0 &&\n    !(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') &&\n    !(_indexOf(fieldsKeys, '_id') >= 0 && fields._id)\n  ) {\n    fieldsKeys = _filter(fieldsKeys, (key) => key !== '_id');\n  }\n\n  var including = null; // Unknown\n\n  _each(fieldsKeys, (keyPath) => {\n    var rule = !!fields[keyPath];\n    if (including === null) {\n      including = rule;\n    }\n    if (including !== rule) {\n      // This error message is copied from MongoDB shell\n      throw Error('You cannot currently mix including and excluding fields.');\n    }\n  });\n\n  var projectionRulesTree = pathsToTree(\n    fieldsKeys,\n    (path) => including,\n    (node, path, fullPath) => {\n      // Check passed projection fields' keys: If you have two rules such as\n      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n      // that happens, there is a probability you are doing something wrong,\n      // framework should notify you about such mistake earlier on cursor\n      // compilation step than later during runtime.  Note, that real mongo\n      // doesn't do anything about it and the later rule appears in projection\n      // project, more priority it takes.\n      //\n      // Example, assume following in mongo shell:\n      // > db.coll.insert({ a: { b: 23, c: 44 } })\n      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n      // { '_id' : ObjectId('520bfe456024608e8ef24af3'), 'a' : { 'b' : 23 } }\n      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n      // { '_id' : ObjectId('520bfe456024608e8ef24af3'), 'a' : { 'b' : 23, 'c' : 44 } }\n      //\n      // Note, how second time the return set of keys is different.\n\n      var currentPath = fullPath;\n      var anotherPath = path;\n      throw Error('both ' + currentPath + ' and ' + anotherPath +\n                  ' found in fields option, using both of them may trigger ' +\n                  'unexpected behavior. Did you mean to use only one of them?');\n    });\n\n  return {\n    tree: projectionRulesTree,\n    including: including,\n  };\n}\n\n\n// paths - Array: list of mongo style paths\n// newLeafFn - Function: of form function(path) should return a scalar value to\n//                       put into list created for that path\n// conflictFn - Function: of form function(node, path, fullPath) is called\n//                        when building a tree path for 'fullPath' node on\n//                        'path' was already a leaf with a value. Must return a\n//                        conflict resolution.\n// initial tree - Optional Object: starting tree.\n// @returns - Object: tree represented as a set of nested objects\nexport function pathsToTree(paths, newLeafFn, conflictFn, tree) {\n  tree = tree || {};\n  _each(paths, (keyPath) => {\n    var treePos = tree;\n    var pathArr = keyPath.split('.');\n\n    // use _.all just for iteration with break\n    var success = _every(pathArr.slice(0, -1), (key, idx) => {\n      if (!_has(treePos, key)) {\n        treePos[key] = {};\n      } else if (!_check.object(treePos[key])) {\n        treePos[key] = conflictFn(\n          treePos[key],\n          pathArr.slice(0, idx + 1).join('.'),\n          keyPath\n        );\n        // break out of loop if we are failing for this path\n        if (!_check.object(treePos[key])) {\n          return false;\n        }\n      }\n\n      treePos = treePos[key];\n      return true;\n    });\n\n    if (success) {\n      var lastKey = pathArr[pathArr.length - 1];\n      if (!_has(treePos, lastKey)) {\n        treePos[lastKey] = newLeafFn(keyPath);\n      } else {\n        treePos[lastKey] = conflictFn(treePos[lastKey], keyPath, keyPath);\n      }\n    }\n  });\n\n  return tree;\n}\n\n\n// By given paths array and projection object returns\n// new projection object combined with paths.\nexport function combineImportantPathsIntoProjection(paths, projection) {\n  var prjDetails = projectionDetails(projection);\n  var tree = prjDetails.tree;\n  var mergedProjection = {};\n\n  // merge the paths to include\n  tree = pathsToTree(\n    paths,\n    (path) => true,\n    (node, path, fullPath) => true,\n    tree\n  );\n  mergedProjection = treeToPaths(tree);\n  if (prjDetails.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  } else {\n    // selector is pointing at fields to include\n    // projection is pointing at fields to exclude\n    // make sure we don't exclude important paths\n    var mergedExclProjection = {};\n    _each(mergedProjection, (incl, path) => {\n      if (!incl) {\n        mergedExclProjection[path] = false;\n      }\n    });\n\n    return mergedExclProjection;\n  }\n}\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nexport function combineMatcherWithProjection(matcher, projection) {\n  var selectorPaths = _pathsElidingNumericKeys(matcher._getPaths());\n\n  // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n  if (_indexOf(selectorPaths, '') >= 0) {\n    return {};\n  }\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n}\n\n// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nexport function combineSorterWithProjection(sorter, projection) {\n  var specPaths = _pathsElidingNumericKeys(sorter._getPaths());\n  return combineImportantPathsIntoProjection(specPaths, projection);\n}\n\n\n// Internal utils\nconst _pathsElidingNumericKeys = (paths) => {\n  return _map(paths, (path) =>\n    _filter(path.split('.'), (k) => !isNumericKey(k)).join('.')\n  );\n};\n\n// Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\nconst treeToPaths = (tree, prefix) => {\n  prefix = prefix || '';\n  var result = {};\n\n  _each(tree, (val, key) => {\n    if (_check.object(val)) {\n      _assign(result, treeToPaths(val, prefix + key + '.'));\n    } else {\n      result[prefix + key] = val;\n    }\n  });\n\n  return result;\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/DocumentRetriver.js":"import _check from 'check-types';\nimport _map from 'fast.js/map';\nimport _filter from 'fast.js/array/filter';\nimport {selectorIsId, selectorIsIdPerhapsAsObject} from './Document';\n\n\n// Internals\nconst DEFAULT_QUERY_FILTER = () => true;\n\n/**\n * Class for getting data objects by given list of ids.\n * Promises based. It makes requests asyncronousle by\n * getting request frame from database.\n * It's not use caches, because it's a task of store.\n * It just retrives content by 'get' method.\n */\nexport class DocumentRetriver {\n  constructor(db) {\n    this.db = db;\n  }\n\n  /**\n   * Retrive an optimal superset of documents\n   * by given query based on _id field of the query\n   *\n   * TODO: there is a place for indexes\n   *\n   * @param  {Object} query\n   * @return {Promise}\n   */\n  retriveForQeury(query, queryFilter = DEFAULT_QUERY_FILTER, options = {}) {\n    // Try to get list of ids\n    let selectorIds;\n    if (selectorIsId(query)) {\n      // fast path for scalar query\n      selectorIds = [query];\n    } else if (selectorIsIdPerhapsAsObject(query)) {\n      // also do the fast path for { _id: idString }\n      selectorIds = [query._id];\n    } else if (\n      _check.object(query) && query.hasOwnProperty('_id') &&\n      _check.object(query._id) && query._id.hasOwnProperty('$in') &&\n      _check.array(query._id.$in)\n    ) {\n      // and finally fast path for multiple ids\n      // selected by $in operator\n      selectorIds = query._id.$in;\n    }\n\n    // Retrive optimally\n    if (_check.array(selectorIds) && selectorIds.length > 0) {\n      return this.retriveIds(queryFilter, selectorIds, options);\n    } else {\n      return this.retriveAll(queryFilter, options);\n    }\n  }\n\n  /**\n   * Rterive all ids given in constructor.\n   * If some id is not retrived (retrived qith error),\n   * then returned promise will be rejected with that error.\n   * @return {Promise}\n   */\n  retriveAll(queryFilter = DEFAULT_QUERY_FILTER, options = {}) {\n    const limit = options.limit || +Infinity;\n    const result = [];\n    let stopped = false;\n\n    return new Promise((resolve, reject) => {\n      const stream = this.db.storage.createReadStream();\n\n      stream.on('data', (data) => {\n        // After deleting of an item some storages\n        // may return an undefined for a few times.\n        // We need to check it there.\n        if (!stopped && data.value) {\n          const doc = this.db.create(data.value);\n          if (result.length < limit && queryFilter(doc)) {\n            result.push(doc);\n          }\n          // Limit the result if storage supports it\n          if (result.length === limit && stream.pause) {\n            stream.pause();\n            resolve(result);\n            stopped = true;\n          }\n        }\n      })\n      .on('end', () => !stopped && resolve(result));\n    });\n  }\n\n  /**\n   * Rterive all ids given in constructor.\n   * If some id is not retrived (retrived qith error),\n   * then returned promise will be rejected with that error.\n   * @return {Promise}\n   */\n  retriveIds(queryFilter = DEFAULT_QUERY_FILTER, ids = [], options = {}) {\n    const uniqIds = _filter(ids, (id, i) => ids.indexOf(id) === i);\n    const retrPromises = _map(uniqIds, id => this.retriveOne(id));\n    const limit = options.limit || +Infinity;\n\n    return Promise.all(retrPromises).then((res) => {\n      const filteredRes = [];\n\n      for (let i = 0; i < res.length; i++) {\n        const doc = res[i];\n        if (doc && queryFilter(doc)) {\n          filteredRes.push(doc);\n          if (filteredRes.length === limit) {\n            break;\n          }\n        }\n      }\n\n      return filteredRes;\n    });\n  }\n\n  /**\n   * Retrive one document by given id\n   * @param  {String} id\n   * @return {Promise}\n   */\n  retriveOne(id) {\n    return this.db.storage.get(id).then((buf) => this.db.create(buf));\n  }\n}\n\nexport default DocumentRetriver;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/DocumentSorter.js":"import _check from 'check-types';\nimport _each from 'fast.js/forEach';\nimport _every from 'fast.js/array/every';\nimport _map from 'fast.js/map';\nimport _indexOf from 'fast.js/array/indexOf';\nimport _keys from 'fast.js/object/keys';\nimport DocumentMatcher from './DocumentMatcher';\nimport {isOperatorObject, MongoTypeComp} from './Document';\nimport {makeLookupFunction, expandArraysInBranches,\n  equalityElementMatcher, regexpElementMatcher,\n  ELEMENT_OPERATORS} from './DocumentMatcher';\n\n\n// Give a sort spec, which can be in any of these forms:\n//   {'key1': 1, 'key2': -1}\n//   [['key1', 'asc'], ['key2', 'desc']]\n//   ['key1', ['key2', 'desc']]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\n\nexport class DocumentSorter {\n  constructor(spec, options = {}) {\n    this._sortSpecParts = [];\n\n    var addSpecPart = (path, ascending) => {\n      if (!path) {\n        throw Error('sort keys must be non-empty');\n      }\n      if (path.charAt(0) === '$') {\n        throw Error('unsupported sort key: ' + path);\n      }\n      this._sortSpecParts.push({\n        path: path,\n        lookup: makeLookupFunction(path, {forSort: true}),\n        ascending: ascending,\n      });\n    };\n\n    if (spec instanceof Array) {\n      for (var i = 0; i < spec.length; i++) {\n        if (typeof spec[i] === 'string') {\n          addSpecPart(spec[i], true);\n        } else {\n          addSpecPart(spec[i][0], spec[i][1] !== 'desc');\n        }\n      }\n    } else if (typeof spec === 'object') {\n      _each(spec, function(value, key) {\n        addSpecPart(key, value >= 0);\n      });\n    } else {\n      throw Error('Bad sort specification: ' + JSON.stringify(spec));\n    }\n\n    // To implement affectedByModifier, we piggy-back on top of Matcher's\n    // affectedByModifier code; we create a selector that is affected by the same\n    // modifiers as this sort order. This is only implemented on the server.\n    if (this.affectedByModifier) {\n      var selector = {};\n      _each(this._sortSpecParts, function(nextSpec) {\n        selector[nextSpec.path] = 1;\n      });\n      this._selectorForAffectedByModifier = new DocumentMatcher(selector);\n    }\n\n    this._keyComparator = composeComparators(\n      _map(this._sortSpecParts, (nextSpec, j) => {\n        return this._keyFieldComparator(j);\n      }));\n\n    // If you specify a matcher for this Sorter, _keyFilter may be set to a\n    // function which selects whether or not a given 'sort key' (tuple of values\n    // for the different sort spec fields) is compatible with the selector.\n    this._keyFilter = null;\n    if (options.matcher) {\n      this._useWithMatcher(options.matcher);\n    }\n  }\n\n  getComparator(options) {\n    // If we have no distances, just use the comparator from the source\n    // specification (which defaults to 'everything is equal'.\n    if (!options || !options.distances) {\n      return this._getBaseComparator();\n    }\n\n    var distances = options.distances;\n\n    // Return a comparator which first tries the sort specification, and if that\n    // says 'it's equal', breaks ties using $near distances.\n    return composeComparators([this._getBaseComparator(), function(a, b) {\n      if (!distances.has(a._id)) {\n        throw Error('Missing distance for ' + a._id);\n      }\n      if (!distances.has(b._id)) {\n        throw Error('Missing distance for ' + b._id);\n      }\n      return distances.get(a._id) - distances.get(b._id);\n    }]);\n  }\n\n  _getPaths() {\n    return _map(this._sortSpecParts, x => x.path);\n  }\n\n  // Finds the minimum key from the doc, according to the sort specs.  (We say\n  // 'minimum' here but this is with respect to the sort spec, so 'descending'\n  // sort fields mean we're finding the max for that field.)\n  //\n  // Note that this is NOT 'find the minimum value of the first field, the\n  // minimum value of the second field, etc'... it's 'choose the\n  // lexicographically minimum value of the key vector, allowing only keys which\n  // you can find along the same paths'.  ie, for a doc {a: [{x: 0, y: 5}, {x:\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n  _getMinKeyFromDoc(doc) {\n    var minKey = null;\n\n    this._generateKeysFromDoc(doc, (key) => {\n      if (!this._keyCompatibleWithSelector(key)) {\n        return;\n      }\n\n      if (minKey === null) {\n        minKey = key;\n        return;\n      }\n      if (this._compareKeys(key, minKey) < 0) {\n        minKey = key;\n      }\n    });\n\n    // This could happen if our key filter somehow filters out all the keys even\n    // though somehow the selector matches.\n    if (minKey === null) {\n      throw Error('sort selector found no keys in doc?');\n    }\n    return minKey;\n  }\n\n  _keyCompatibleWithSelector(key) {\n    return !this._keyFilter || this._keyFilter(key);\n  }\n\n  // Iterates over each possible 'key' from doc (ie, over each branch), calling\n  // 'cb' with the key.\n  _generateKeysFromDoc(doc, cb) {\n    if (this._sortSpecParts.length === 0) {\n      throw new Error('can\\'t generate keys without a spec');\n    }\n\n    // maps index -> ({'' -> value} or {path -> value})\n    var valuesByIndexAndPath = [];\n\n    var pathFromIndices = function(indices) {\n      return indices.join(',') + ',';\n    };\n\n    var knownPaths = null;\n\n    _each(this._sortSpecParts, function(spec, whichField) {\n      // Expand any leaf arrays that we find, and ignore those arrays\n      // themselves.  (We never sort based on an array itself.)\n      var branches = expandArraysInBranches(spec.lookup(doc), true);\n\n      // If there are no values for a key (eg, key goes to an empty array),\n      // pretend we found one null value.\n      if (!branches.length) {\n        branches = [{value: null}];\n      }\n\n      var usedPaths = false;\n      valuesByIndexAndPath[whichField] = {};\n      _each(branches, function(branch) {\n        if (!branch.arrayIndices) {\n          // If there are no array indices for a branch, then it must be the\n          // only branch, because the only thing that produces multiple branches\n          // is the use of arrays.\n          if (branches.length > 1) {\n            throw Error('multiple branches but no array used?');\n          }\n          valuesByIndexAndPath[whichField][''] = branch.value;\n          return;\n        }\n\n        usedPaths = true;\n        var path = pathFromIndices(branch.arrayIndices);\n        if (valuesByIndexAndPath[whichField].hasOwnProperty(path)) {\n          throw Error('duplicate path: ' + path);\n        }\n        valuesByIndexAndPath[whichField][path] = branch.value;\n\n        // If two sort fields both go into arrays, they have to go into the\n        // exact same arrays and we have to find the same paths.  This is\n        // roughly the same condition that makes MongoDB throw this strange\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\n        // b:1} then a and b cannot both be arrays.\n        //\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\n        // #NestedArraySort\n        // XXX achieve full compatibility here\n        if (knownPaths && !knownPaths.hasOwnProperty(path)) {\n          throw Error('cannot index parallel arrays');\n        }\n      });\n\n      if (knownPaths) {\n        // Similarly to above, paths must match everywhere, unless this is a\n        // non-array field.\n        if (!valuesByIndexAndPath[whichField].hasOwnProperty('') &&\n            _keys(knownPaths).length !== _keys(valuesByIndexAndPath[whichField]).length) {\n          throw Error('cannot index parallel arrays!');\n        }\n      } else if (usedPaths) {\n        knownPaths = {};\n        _each(valuesByIndexAndPath[whichField], function(x, path) {\n          knownPaths[path] = true;\n        });\n      }\n    });\n\n    if (!knownPaths) {\n      // Easy case: no use of arrays.\n      var soleKey = _map(valuesByIndexAndPath, function(values) {\n        if (!values.hasOwnProperty('')) {\n          throw Error('no value in sole key case?');\n        }\n        return values[''];\n      });\n      cb(soleKey);\n      return;\n    }\n\n    _each(knownPaths, function(x, path) {\n      var key = _map(valuesByIndexAndPath, function(values) {\n        if (values.hasOwnProperty('')) {\n          return values[''];\n        }\n        if (!values.hasOwnProperty(path)) {\n          throw Error('missing path?');\n        }\n        return values[path];\n      });\n      cb(key);\n    });\n  }\n\n  // Takes in two keys: arrays whose lengths match the number of spec\n  // parts. Returns negative, 0, or positive based on using the sort spec to\n  // compare fields.\n  _compareKeys(key1, key2) {\n    if (key1.length !== this._sortSpecParts.length ||\n        key2.length !== this._sortSpecParts.length) {\n      throw Error('Key has wrong length');\n    }\n\n    return this._keyComparator(key1, key2);\n  }\n\n  // Given an index 'i', returns a comparator that compares two key arrays based\n  // on field 'i'.\n  _keyFieldComparator(i) {\n    var invert = !this._sortSpecParts[i].ascending;\n    return function(key1, key2) {\n      var compare = MongoTypeComp._cmp(key1[i], key2[i]);\n      if (invert) {\n        compare = -compare;\n      }\n      return compare;\n    };\n  }\n\n  // Returns a comparator that represents the sort specification (but not\n  // including a possible geoquery distance tie-breaker).\n  _getBaseComparator() {\n    // If we're only sorting on geoquery distance and no specs, just say\n    // everything is equal.\n    if (!this._sortSpecParts.length) {\n      return function(doc1, doc2) {\n        return 0;\n      };\n    }\n\n    return (doc1, doc2) => {\n      var key1 = this._getMinKeyFromDoc(doc1);\n      var key2 = this._getMinKeyFromDoc(doc2);\n      return this._compareKeys(key1, key2);\n    };\n  }\n\n  // In MongoDB, if you have documents\n  //    {_id: 'x', a: [1, 10]} and\n  //    {_id: 'y', a: [5, 15]},\n  // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).\n  // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not\n  // match the selector, and 5 comes before 10).\n  //\n  // The way this works is pretty subtle!  For example, if the documents\n  // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and\n  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),\n  // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and\n  //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})\n  // both follow this rule (y before x).  (ie, you do have to apply this\n  // through $elemMatch.)\n  //\n  // So if you pass a matcher to this sorter's constructor, we will attempt to\n  // skip sort keys that don't match the selector. The logic here is pretty\n  // subtle and undocumented; we've gotten as close as we can figure out based\n  // on our understanding of Mongo's behavior.\n  _useWithMatcher(matcher) {\n    if (this._keyFilter) {\n      throw Error('called _useWithMatcher twice?');\n    }\n\n    // If we are only sorting by distance, then we're not going to bother to\n    // build a key filter.\n    // XXX figure out how geoqueries interact with this stuff\n    if (_check.emptyArray(this._sortSpecParts)) {\n      return;\n    }\n\n    var selector = matcher._selector;\n\n    // If the user just passed a literal function to find(), then we can't get a\n    // key filter from it.\n    if (selector instanceof Function || !selector) {\n      return;\n    }\n\n    var constraintsByPath = {};\n    _each(this._sortSpecParts, function(spec, i) {\n      constraintsByPath[spec.path] = [];\n    });\n\n    _each(selector, function(subSelector, key) {\n      // XXX support $and and $or\n\n      var constraints = constraintsByPath[key];\n      if (!constraints) {\n        return;\n      }\n\n      // XXX it looks like the real MongoDB implementation isn't 'does the\n      // regexp match' but 'does the value fall into a range named by the\n      // literal prefix of the regexp', ie 'foo' in /^foo(bar|baz)+/  But\n      // 'does the regexp match' is a good approximation.\n      if (subSelector instanceof RegExp) {\n        // As far as we can tell, using either of the options that both we and\n        // MongoDB support ('i' and 'm') disables use of the key filter. This\n        // makes sense: MongoDB mostly appears to be calculating ranges of an\n        // index to use, which means it only cares about regexps that match\n        // one range (with a literal prefix), and both 'i' and 'm' prevent the\n        // literal prefix of the regexp from actually meaning one range.\n        if (subSelector.ignoreCase || subSelector.multiline) {\n          return;\n        }\n        constraints.push(regexpElementMatcher(subSelector));\n        return;\n      }\n\n      if (isOperatorObject(subSelector)) {\n        _each(subSelector, function(operand, operator) {\n          if (_indexOf(['$lt', '$lte', '$gt', '$gte'], operator) >= 0) {\n            // XXX this depends on us knowing that these operators don't use any\n            // of the arguments to compileElementSelector other than operand.\n            constraints.push(\n              ELEMENT_OPERATORS[operator].compileElementSelector(operand));\n          }\n\n          // See comments in the RegExp block above.\n          if (operator === '$regex' && !subSelector.$options) {\n            constraints.push(\n              ELEMENT_OPERATORS.$regex.compileElementSelector(\n                operand, subSelector));\n          }\n\n          // XXX support {$exists: true}, $mod, $type, $in, $elemMatch\n        });\n        return;\n      }\n\n      // OK, it's an equality thing.\n      constraints.push(equalityElementMatcher(subSelector));\n    });\n\n    // It appears that the first sort field is treated differently from the\n    // others; we shouldn't create a key filter unless the first sort field is\n    // restricted, though after that point we can restrict the other sort fields\n    // or not as we wish.\n    const currConstraint = constraintsByPath[this._sortSpecParts[0].path];\n    if (!_check.assigned(currConstraint) || _check.emptyArray(currConstraint)) {\n      return;\n    }\n\n    this._keyFilter = function(key) {\n      return _every(this._sortSpecParts, function(specPart, index) {\n        return _every(constraintsByPath[specPart.path], function(f) {\n          return f(key[index]);\n        });\n      });\n    };\n  }\n}\n\nexport default DocumentSorter;\n\n// Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\nvar composeComparators = function(comparatorArray) {\n  return function(a, b) {\n    for (var i = 0; i < comparatorArray.length; ++i) {\n      var compare = comparatorArray[i](a, b);\n      if (compare !== 0) {\n        return compare;\n      }\n    }\n    return 0;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/EJSON.js":"/**\n * Based on Meteor's EJSON package.\n * Rewrite with ES6 and better formated for passing\n * linter\n */\nimport Base64 from './Base64';\nimport _some from 'fast.js/array/some';\nimport _check from 'check-types';\nimport _keys from 'fast.js/object/keys';\nimport _each from 'fast.js/forEach';\n\n\n// Internal utils\nfunction _isNaN(val) {\n  return typeof val === 'number' && val != +val;\n}\nfunction _has(obj, key) {\n  return _check.object(obj) && obj.hasOwnProperty(key);\n}\nfunction _isInfOrNan(val) {\n  return _isNaN(val) || val === Infinity || val === -Infinity;\n}\nfunction _isArguments(val) {\n  return (\n    !!val && typeof val == 'object' &&\n    Object.prototype.hasOwnProperty.call(val, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(val, 'callee')\n  );\n}\n\n\nexport class EJSON {\n  // @ngInject\n  constructor() {\n    this._setupBuiltinConverters();\n    this._customTypes = {};\n  }\n\n  /**\n   * @summary Add a custom type, using a method of your choice to get to and\n   * from a basic JSON-able representation.  The factory argument\n   * is a function of JSON-able --> your object\n   * The type you add must have:\n   * - A toJSONValue() method, so that Meteor can serialize it\n   * - a typeName() method, to show how to look it up in our type table.\n   * It is okay if these methods are monkey-patched on.\n   * EJSON.clone will use toJSONValue and the given factory to produce\n   * a clone, but you may specify a method clone() that will be used instead.\n   * Similarly, EJSON.equals will use toJSONValue to make comparisons,\n   * but you may provide a method equals() instead.\n   * @locus Anywhere\n   * @param {String} name A tag for your custom type; must be unique among custom data types defined in your project, and must match the result of your type's `typeName` method.\n   * @param {Function} factory A function that deserializes a JSON-compatible value into an instance of your type.  This should match the serialization performed by your type's `toJSONValue` method.\n   */\n  addType(name, factory) {\n    if (_has(this._customTypes, name)) {\n      throw new Error('Type ' + name + ' already present');\n    }\n    this._customTypes[name] = factory;\n  }\n\n  /**\n   * @summary Serialize an EJSON-compatible value into its plain JSON representation.\n   * @locus Anywhere\n   * @param {EJSON} val A value to serialize to plain JSON.\n   */\n  toJSONValue(item) {\n    var changed = this._toJSONValueHelper(item);\n    if (changed !== undefined) {\n      return changed;\n    }\n    if (typeof item === 'object') {\n      item = this.clone(item);\n      this._adjustTypesToJSONValue(item);\n    }\n    return item;\n  }\n\n  /**\n   * @summary Deserialize an EJSON value from its plain JSON representation.\n   * @locus Anywhere\n   * @param {JSONCompatible} val A value to deserialize into EJSON.\n   */\n  fromJSONValue(item) {\n    var changed = this._fromJSONValueHelper(item);\n    if (changed === item && typeof item === 'object') {\n      item = this.clone(item);\n      this._adjustTypesFromJSONValue(item);\n      return item;\n    } else {\n      return changed;\n    }\n  }\n\n  /**\n   * @summary Serialize a value to a string.\n   * For EJSON values, the serialization fully represents the value. For non-EJSON values, serializes the same way as `JSON.stringify`.\n   * @locus Anywhere\n   * @param {EJSON} val A value to stringify.\n   */\n  stringify(item) {\n    var json = this.toJSONValue(item);\n    return JSON.stringify(json);\n  }\n\n  /**\n   * @summary Parse a string into an EJSON value. Throws an error if the string is not valid EJSON.\n   * @locus Anywhere\n   * @param {String} str A string to parse into an EJSON value.\n   */\n  parse(item) {\n    if (typeof item !== 'string') {\n      throw new Error('EJSON.parse argument should be a string');\n    }\n    return this.fromJSONValue(JSON.parse(item));\n  }\n\n  /**\n   * @summary Returns true if `x` is a buffer of binary data, as returned from [`EJSON.newBinary`](#ejson_new_binary).\n   * @param {Object} x The variable to check.\n   * @locus Anywhere\n   */\n  isBinary(obj) {\n    return !!((typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array) ||\n      (obj && obj.$Uint8ArrayPolyfill));\n  }\n\n  /**\n   * @summary Return true if `a` and `b` are equal to each other.  Return false otherwise.  Uses the `equals` method on `a` if present, otherwise performs a deep comparison.\n   * @locus Anywhere\n   * @param {EJSON} a\n   * @param {EJSON} b\n   * @param {Object} [options]\n   * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order, if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}` is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The default is `false`.\n   */\n  equals(a, b, options) {\n    var i;\n    var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n    if (a === b) {\n      return true;\n    }\n    if (_isNaN(a) && _isNaN(b)) {\n      return true; // This differs from the IEEE spec for NaN equality, b/c we don't want\n                   // anything ever with a NaN to be poisoned from becoming equal to anything.\n    }\n    if (!a || !b) { // if either one is falsy, they'd have to be === to be equal\n      return false;\n    }\n    if (!(typeof a === 'object' && typeof b === 'object')) {\n      return false;\n    }\n    if (a instanceof Date && b instanceof Date) {\n      return a.valueOf() === b.valueOf();\n    }\n    if (this.isBinary(a) && this.isBinary(b)) {\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (typeof (a.equals) === 'function') {\n      return a.equals(b, options);\n    }\n    if (typeof (b.equals) === 'function') {\n      return b.equals(a, options);\n    }\n    if (a instanceof Array) {\n      if (!(b instanceof Array)) {\n        return false;\n      }\n      if (a.length !== b.length) {\n        return false;\n      }\n      for (i = 0; i < a.length; i++) {\n        if (!this.equals(a[i], b[i], options)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    // fallback for custom types that don't implement their own equals\n    switch (this._isCustomType(a) + this._isCustomType(b)) {\n      case 1: return false;\n      case 2: return this.equals(this.toJSONValue(a), this.toJSONValue(b));\n    }\n    // fall back to structural equality of objects\n    var ret;\n    if (keyOrderSensitive) {\n      var bKeys = _keys(b);\n      i = 0;\n      ret = _keys(a).every((x) => {\n        if (i >= bKeys.length) {\n          return false;\n        }\n        if (x !== bKeys[i]) {\n          return false;\n        }\n        if (!this.equals(a[x], b[bKeys[i]], options)) {\n          return false;\n        }\n        i++;\n        return true;\n      });\n      return ret && i === bKeys.length;\n    } else {\n      i = 0;\n      ret = _keys(a).every((key) => {\n        if (!_has(b, key)) {\n          return false;\n        }\n        if (!this.equals(a[key], b[key], options)) {\n          return false;\n        }\n        i++;\n        return true;\n      });\n      return ret && _keys(b).length === i;\n    }\n  }\n\n  /**\n   * @summary Return a deep copy of `val`.\n   * @locus Anywhere\n   * @param {EJSON} val A value to copy.\n   */\n  clone(v) {\n    var ret;\n    if (typeof v !== 'object') {\n      return v;\n    }\n    if (v === null) {\n      return null; // null has typeof 'object'\n    }\n    if (v instanceof Date) {\n      return new Date(v.getTime());\n    }\n    // RegExps are not really EJSON elements (eg we don't define a serialization\n    // for them), but they're immutable anyway, so we can support them in clone.\n    if (v instanceof RegExp) {\n      return v;\n    }\n    if (this.isBinary(v)) {\n      ret = Base64.newBinary(v.length);\n      for (let i = 0; i < v.length; i++) {\n        ret[i] = v[i];\n      }\n      return ret;\n    }\n\n    if (_check.array(v) || _isArguments(v)) {\n      ret = [];\n      for (let i = 0; i < v.length; i++) {\n        ret[i] = this.clone(v[i]);\n      }\n      return ret;\n    }\n    // handle general user-defined typed Objects if they have a clone method\n    if (typeof v.clone === 'function') {\n      return v.clone();\n    }\n    // handle other custom types\n    if (this._isCustomType(v)) {\n      return this.fromJSONValue(this.clone(this.toJSONValue(v)), true);\n    }\n    // handle other objects\n    ret = {};\n    _each(v, (val, key) => {\n      ret[key] = this.clone(val);\n    });\n    return ret;\n  }\n\n  newBinary(len) {\n    return Base64.newBinary(len);\n  }\n\n  _setupBuiltinConverters() {\n    this._builtinConverters = [\n      { // Date\n        matchJSONValue: (obj) => {\n          return _has(obj, '$date') &&\n            _keys(obj).length === 1;\n        },\n        matchObject: (obj) => {\n          return obj instanceof Date;\n        },\n        toJSONValue: (obj) => {\n          return {$date: obj.getTime()};\n        },\n        fromJSONValue: (obj) => {\n          return new Date(obj.$date);\n        },\n      },\n      { // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n        // which we match.)\n        matchJSONValue: (obj) => {\n          return _has(obj, '$InfNaN') &&\n            _keys(obj).length === 1;\n        },\n        matchObject: _isInfOrNan,\n        toJSONValue: (obj) => {\n          var sign;\n          if (_isNaN(obj)) {\n            sign = 0;\n          } else if (obj === Infinity) {\n            sign = 1;\n          } else {\n            sign = -1;\n          }\n          return {$InfNaN: sign};\n        },\n        fromJSONValue: (obj) => {\n          return obj.$InfNaN/0;\n        },\n      },\n      { // Binary\n        matchJSONValue: (obj) => {\n          return _has(obj, '$binary') &&\n            _keys(obj).length === 1;\n        },\n        matchObject: (obj) => {\n          return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array ||\n            (obj && _has(obj, '$Uint8ArrayPolyfill'));\n        },\n        toJSONValue: (obj) => {\n          return {$binary: Base64.encode(obj)};\n        },\n        fromJSONValue: (obj) => {\n          return Base64.decode(obj.$binary);\n        },\n      },\n      { // Escaping one level\n        matchJSONValue: (obj) => {\n          return _has(obj, '$escape') &&\n            _keys(obj).length === 1;\n        },\n        matchObject: (obj) => {\n          if (\n            !_check.assigned(obj) || _check.emptyObject(obj) ||\n            (_check.object(obj) && _keys(obj).length > 2)\n          ) {\n            return false;\n          }\n          return _some(this._builtinConverters, (converter) => {\n            return converter.matchJSONValue(obj);\n          });\n        },\n        toJSONValue: (obj) => {\n          var newObj = {};\n          _each(obj, (val, key) => {\n            newObj[key] = this.toJSONValue(val);\n          });\n          return {$escape: newObj};\n        },\n        fromJSONValue: (obj) => {\n          var newObj = {};\n          _each(obj.$escape, (val, key) => {\n            newObj[key] = this.fromJSONValue(val);\n          });\n          return newObj;\n        },\n      },\n      { // Custom\n        matchJSONValue: (obj) => {\n          return _has(obj, '$type') &&\n            _has(obj, '$value') &&\n            _keys(obj).length === 2;\n        },\n        matchObject: (obj) => {\n          return this._isCustomType(obj);\n        },\n        toJSONValue: (obj) => {\n          var jsonValue = obj.toJSONValue();\n          return {$type: obj.typeName(), $value: jsonValue};\n        },\n        fromJSONValue: (obj) => {\n          var typeName = obj.$type;\n          if (!_has(this._customTypes, typeName)) {\n            throw new Error('Custom EJSON type ' + typeName + ' is not defined');\n          }\n          var converter = this._customTypes[typeName];\n          return converter(obj.$value);\n        },\n      },\n    ];\n  }\n\n  _isCustomType(obj) {\n    return obj &&\n      typeof obj.toJSONValue === 'function' &&\n      typeof obj.typeName === 'function' &&\n      _has(this._customTypes, obj.typeName());\n  }\n\n  /**\n   * For both arrays and objects, in-place modification.\n   */\n  _adjustTypesToJSONValue(obj) {\n    // Is it an atom that we need to adjust?\n    if (obj === null) {\n      return null;\n    }\n    var maybeChanged = this._toJSONValueHelper(obj);\n    if (maybeChanged !== undefined) {\n      return maybeChanged;\n    }\n\n    // Other atoms are unchanged.\n    if (typeof obj !== 'object') {\n      return obj;\n    }\n\n    // Iterate over array or object structure.\n    _each(obj, (value, key) => {\n      if (typeof value !== 'object' && value !== undefined &&\n        !_isInfOrNan(value)) {\n        return;\n      }\n\n      var changed = this._toJSONValueHelper(value);\n      if (changed) {\n        obj[key] = changed;\n        return;\n      }\n      // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n      this._adjustTypesToJSONValue(value);\n    });\n    return obj;\n  }\n\n  /**\n   * Either return the JSON-compatible version of the argument, or undefined\n   * (if the item isn't itself replaceable, but maybe some fields in it are)\n   */\n  _toJSONValueHelper(item) {\n    for (var i = 0; i < this._builtinConverters.length; i++) {\n      var converter = this._builtinConverters[i];\n      if (converter.matchObject(item)) {\n        return converter.toJSONValue(item);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * For both arrays and objects. Tries its best to just\n   * use the object you hand it, but may return something\n   * different if the object you hand it itself needs changing.\n   */\n  _adjustTypesFromJSONValue(obj) {\n    if (obj === null) {\n      return null;\n    }\n    var maybeChanged = this._fromJSONValueHelper(obj);\n    if (maybeChanged !== obj) {\n      return maybeChanged;\n    }\n\n    // Other atoms are unchanged.\n    if (typeof obj !== 'object') {\n      return obj;\n    }\n\n    _each(obj, (value, key) => {\n      if (typeof value === 'object') {\n        var changed = this._fromJSONValueHelper(value);\n        if (value !== changed) {\n          obj[key] = changed;\n          return;\n        }\n        // if we get here, value is an object but not adjustable\n        // at this level.  recurse.\n        this._adjustTypesFromJSONValue(value);\n      }\n    });\n    return obj;\n  }\n\n  /**\n   * Either return the argument changed to have the non-json\n   * rep of itself (the Object version) or the argument itself.\n   * DOES NOT RECURSE.  For actually getting the fully-changed value,\n   * use EJSON.fromJSONValue\n   */\n  _fromJSONValueHelper(value) {\n    if (typeof value === 'object' && value !== null) {\n      if (_keys(value).length <= 2 &&\n          _keys(value).every(function(k) {\n            return typeof k === 'string' && k.substr(0, 1) === '$';\n          })) {\n        for (var i = 0; i < this._builtinConverters.length; i++) {\n          var converter = this._builtinConverters[i];\n          if (converter.matchJSONValue(value)) {\n            return converter.fromJSONValue(value);\n          }\n        }\n      }\n    }\n    return value;\n  }\n}\n\nexport default new EJSON();\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/IndexManager.js":"import _bind from 'fast.js/function/bind';\nimport _keys from 'fast.js/object/keys';\nimport _each from 'fast.js/forEach';\nimport _map from 'fast.js/map';\nimport invariant from 'invariant';\nimport PromiseQueue from './PromiseQueue';\nimport CollectionIndex from './CollectionIndex';\nimport DocumentRetriver from './DocumentRetriver';\n\n\n/**\n * Manager for controlling a list of indexes\n * for some model. Building indexes is promise\n * based.\n * By default it creates an index for `_id` field.\n */\n/* istanbul ignore next */\nexport class IndexManager {\n  constructor(db, options = {}) {\n    this.db = db;\n    this.indexes = {};\n    this._queue = new PromiseQueue(options.concurrency || 2);\n\n    // By default ensure index by _id field\n    this.ensureIndex({\n      fieldName: '_id',\n      unique: true,\n    });\n  }\n\n  /**\n   * Check index existance for given `options.fieldName` and\n   * if index not exists it creates new one.\n   * Always return a promise that resolved only when\n   * index succesfully created, built and ready for working with.\n   * If `options.forceRebuild` provided and equals to true then\n   * existing index will be rebuilt, otherwise existing index\n   * don't touched.\n   *\n   * @param  {Object} options.fieldName     name of the field for indexing\n   * @param  {Object} options.forceRebuild  rebuild index if it exists\n   * @return {Promise}\n   */\n  ensureIndex(options) {\n    invariant(\n      options && options.fieldName,\n      'You must specify a fieldName in options object'\n    );\n\n    const key = options.fieldName;\n    if (!this.indexes[key]) {\n      this.indexes[key] = new CollectionIndex(options);\n      return this.buildIndex(key);\n    } else if (this.indexes[key].buildPromise) {\n      return this.indexes[key].buildPromise;\n    } else if (options && options.forceRebuild) {\n      return this.buildIndex(key);\n    } else {\n      return Promise.resolve();\n    }\n  }\n\n  /**\n   * Buld an existing index (ensured) and return a\n   * promise that will be resolved only when index successfully\n   * built for all documents in the storage.\n   * @param  {String} key\n   * @return {Promise}\n   */\n  buildIndex(key) {\n    invariant(\n      this.indexes[key],\n      'Index with key `%s` does not ensured yet',\n      key\n    );\n\n    const cleanup = () => this.indexes[key].buildPromise = null;\n    const buildPromise = this._queue.add(\n      _bind(this._doBuildIndex, this, key)\n    ).then(cleanup, cleanup);\n\n    this.indexes[key].buildPromise = buildPromise;\n    return buildPromise;\n  }\n\n  /**\n   * Schedule a task for each index in the\n   * manager. Return promise that will be resolved\n   * when all indexes is successfully built.\n   * @return {Promise}\n   */\n  buildAllIndexes() {\n    return Promise.all(\n      _map(this.indexes, (v, k) => {\n        return this.ensureIndex({\n          fieldName: k,\n          forceRebuild: true,\n        });\n      })\n    );\n  }\n\n  /**\n   * Remove an index\n   * @param  {String} key\n   * @return {Promise}\n   */\n  removeIndex(key) {\n    return this._queue.add(() => {\n      delete this.indexes[key];\n    });\n  }\n\n  /**\n   * Add a document to all indexes\n   * @param  {Object} doc\n   * @return {Promise}\n   */\n  indexDocument(doc) {\n    return this._queue.add(() => {\n      const keys = _keys(this.indexes);\n      let failingIndex = null;\n      try {\n        _each(keys, (k, i) => {\n          failingIndex = i;\n          this.indexes[k].insert(doc);\n        });\n      } catch (e) {\n        _each(keys.slice(0, failingIndex), (k) => {\n          this.indexes[k].remove(doc);\n        });\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Update all indexes with new version of\n   * the document\n   * @param  {Object} oldDoc\n   * @param  {Object} newDoc\n   * @return {Promise}\n   */\n  reindexDocument(oldDoc, newDoc) {\n    return this._queue.add(() => {\n      const keys = _keys(this.indexes);\n      let failingIndex = null;\n      try {\n        _each(keys, (k, i) => {\n          failingIndex = i;\n          this.indexes[k].update(oldDoc, newDoc);\n        });\n      } catch (e) {\n        _each(keys.slice(0, failingIndex), (k) => {\n          this.indexes[k].revertUpdate(oldDoc, newDoc);\n        });\n        throw e;\n      }\n    });\n  }\n\n  /**\n   * Remove document from all indexes\n   * @param  {Object} doc\n   * @return {Promise}\n   */\n  deindexDocument(doc) {\n    return this._queue.add(() => {\n      const keys = _keys(this.indexes);\n      _each(keys, (k) => {\n        this.indexes[k].remove(doc);\n      });\n    });\n  }\n\n  /**\n   * Build an existing index with reseting first\n   * @param  {String} key\n   * @return {Promise}\n   */\n  _doBuildIndex(key) {\n    // Get and reset index\n    const index = this.indexes[key];\n    index.reset();\n\n    // Loop through all doucments in the storage\n    const errors = [];\n    return new DocumentRetriver(this.db)\n    .retriveAll().then((docs) => {\n      _each(docs, doc => {\n        try {\n          index.insert(doc);\n        } catch (e) {\n          errors.push([e, doc]);\n        }\n      });\n\n      if (errors.length > 0) {\n        throw new Error('Index build failed with errors: ', errors);\n      }\n    });\n  }\n}\n\nexport default IndexManager;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/PromiseQueue.js":"import _try from 'fast.js/function/try';\nimport Deque from 'double-ended-queue';\n\n\n/**\n * It limits concurrently executed promises\n *\n * @param {Number} [maxPendingPromises=Infinity] max number of concurrently executed promises\n * @param {Number} [maxQueuedPromises=Infinity]  max number of queued promises\n * @constructor\n */\nexport default class PromiseQueue {\n  constructor(maxPendingPromises = Infinity, maxQueuedPromises = Infinity) {\n    this.pendingPromises = 0;\n    this.maxPendingPromises = maxPendingPromises;\n    this.maxQueuedPromises = maxQueuedPromises;\n    this.queue = new Deque();\n    this.length = 0;\n  }\n\n  /**\n   * Pause queue processing\n   */\n  pause() {\n    this._paused = true;\n  }\n\n  /**\n   * Resume queue processing\n   */\n  unpause() {\n    this._paused = false;\n    this._dequeue();\n  }\n\n  /**\n   * Adds new promise generator in the queue\n   * @param {Function} promiseGenerator\n   */\n  add(promiseGenerator, unshift = false) {\n    return new Promise((resolve, reject) => {\n      if (this.length >= this.maxQueuedPromises) {\n        reject(new Error('Queue limit reached'));\n      } else {\n        const queueItem = {\n          promiseGenerator: promiseGenerator,\n          resolve: resolve,\n          reject: reject,\n        };\n\n        if (!unshift) {\n          this.queue.push(queueItem);\n        } else {\n          this.queue.unshift(queueItem);\n        }\n\n        this.length += 1;\n        this._dequeue();\n      }\n    });\n  }\n\n  /**\n   * Internal queue processor. Starts processing of\n   * the next queued function\n   * @return {Boolean}\n   */\n  _dequeue() {\n    if (this._paused || this.pendingPromises >= this.maxPendingPromises) {\n      return false;\n    }\n\n    const item = this.queue.shift();\n    if (!item) {\n      return false;\n    }\n\n    const result = _try(() => {\n      this.pendingPromises++;\n      return Promise.resolve()\n      .then(() => item.promiseGenerator())\n      .then(\n        (value) => {\n          this.length--;\n          this.pendingPromises--;\n          item.resolve(value);\n          this._dequeue();\n        },\n        (err) => {\n          this.length--;\n          this.pendingPromises--;\n          item.reject(err);\n          this._dequeue();\n        }\n      );\n    });\n\n    if (result instanceof Error) {\n      this.length--;\n      this.pendingPromises--;\n      item.reject(result);\n      this._dequeue();\n    }\n\n    return true;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/Random.js":"import _try from 'fast.js/function/try';\nimport invariant from 'invariant';\n\n\n// Intarnals\nlet _defaultRandomGenerator;\nconst RANDOM_GENERATOR_TYPE = {\n  NODE_CRYPTO: 'NODE_CRYPTO',\n  BROWSER_CRYPTO: 'BROWSER_CRYPTO',\n  ALEA: 'ALEA',\n};\nconst UNMISTAKABLE_CHARS = '23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz';\nconst BASE64_CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n  '0123456789-_';\n\n// see http://baagoe.org/en/wiki/Better_random_numbers_for_javascript\n// for a full discussion and Alea implementation.\nconst Alea = function() {\n  function Mash() {\n    var n = 0xefc8249d;\n\n    var mash = function(data) {\n      data = data.toString();\n      for (var i = 0; i < data.length; i++) {\n        n += data.charCodeAt(i);\n        var h = 0.02519603282416938 * n;\n        n = h >>> 0;\n        h -= n;\n        h *= n;\n        n = h >>> 0;\n        h -= n;\n        n += h * 0x100000000; // 2^32\n      }\n      return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n    };\n\n    mash.version = 'Mash 0.9';\n    return mash;\n  }\n\n  return (function(args) {\n    var s0 = 0;\n    var s1 = 0;\n    var s2 = 0;\n    var c = 1;\n\n    if (args.length == 0) {\n      args = [+new Date()];\n    }\n    var mash = Mash();\n    s0 = mash(' ');\n    s1 = mash(' ');\n    s2 = mash(' ');\n\n    for (var i = 0; i < args.length; i++) {\n      s0 -= mash(args[i]);\n      if (s0 < 0) {\n        s0 += 1;\n      }\n      s1 -= mash(args[i]);\n      if (s1 < 0) {\n        s1 += 1;\n      }\n      s2 -= mash(args[i]);\n      if (s2 < 0) {\n        s2 += 1;\n      }\n    }\n    mash = null;\n\n    var random = function() {\n      var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n      s0 = s1;\n      s1 = s2;\n      return s2 = t - (c = t | 0);\n    };\n    random.uint32 = function() {\n      return random() * 0x100000000; // 2^32\n    };\n    random.fract53 = function() {\n      return random() +\n        (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n    };\n    random.version = 'Alea 0.9';\n    random.args = args;\n    return random;\n\n  }(Array.prototype.slice.call(arguments)));\n};\n\n/**\n * Create seeds array for a browser based on window sizes,\n * Date and some random number.\n * @return {Arrat}\n */\nexport function _getBrowserSeeds() {\n  var height = (typeof window !== 'undefined' && window.innerHeight) ||\n    (typeof document !== 'undefined'\n     && document.documentElement\n     && document.documentElement.clientHeight) ||\n    (typeof document !== 'undefined'\n     && document.body\n     && document.body.clientHeight) ||\n    1;\n\n  var width = (typeof window !== 'undefined' && window.innerWidth) ||\n    (typeof document !== 'undefined'\n     && document.documentElement\n     && document.documentElement.clientWidth) ||\n    (typeof document !== 'undefined'\n     && document.body\n     && document.body.clientWidth) ||\n    1;\n\n  var agent = (typeof navigator !== 'undefined' && navigator.userAgent) || '';\n  return [new Date(), height, width, agent, Math.random()];\n}\n\n/**\n * Random string generator copied from Meteor\n * with minor modifications and refactoring.\n */\nexport default class Random {\n  constructor(type, options = {}) {\n    this.type = type;\n\n    invariant(\n      RANDOM_GENERATOR_TYPE[type],\n      'Random(...): no generator type %s',\n      type\n    );\n\n    if (type === RANDOM_GENERATOR_TYPE.ALEA) {\n      invariant(\n        options.seeds,\n        'Random(...): seed is not provided for ALEA seeded generator'\n      );\n      this.alea = Alea.apply(null, options.seeds);\n    }\n  }\n\n  fraction() {\n    if (this.type === RANDOM_GENERATOR_TYPE.ALEA) {\n      return this.alea();\n    } else if (this.type === RANDOM_GENERATOR_TYPE.NODE_CRYPTO) {\n      const numerator = parseInt(this.hexString(8), 16);\n      return numerator * 2.3283064365386963e-10; // 2^-32\n    } else if (this.type === RANDOM_GENERATOR_TYPE.BROWSER_CRYPTO) {\n      const array = new Uint32Array(1);\n      window.crypto.getRandomValues(array);\n      return array[0] * 2.3283064365386963e-10; // 2^-32\n    } else {\n      throw new Error('Unknown random generator type: ' + this.type);\n    }\n  }\n\n  hexString(digits) {\n    if (this.type === RANDOM_GENERATOR_TYPE.NODE_CRYPTO) {\n      const nodeCrypto = require('crypto');\n      const numBytes = Math.ceil(digits / 2);\n\n      // Try to get cryptographically strong randomness. Fall back to\n      // non-cryptographically strong if not available.\n      let bytes = _try(() => nodeCrypto.randomBytes(numBytes));\n      if (bytes instanceof Error) {\n        bytes = nodeCrypto.pseudoRandomBytes(numBytes);\n      }\n\n      const result = bytes.toString('hex');\n      // If the number of digits is odd, we'll have generated an extra 4 bits\n      // of randomness, so we need to trim the last digit.\n      return result.substring(0, digits);\n    } else {\n      return this._randomString(digits, '0123456789abcdef');\n    }\n  }\n\n  _randomString(charsCount, alphabet) {\n    const digits = [];\n    for (let i = 0; i < charsCount; i++) {\n      digits[i] = this.choice(alphabet);\n    }\n    return digits.join('');\n  }\n\n  id(charsCount) {\n    // 17 characters is around 96 bits of entropy, which is the amount of\n    // state in the Alea PRNG.\n    if (charsCount === undefined) {\n      charsCount = 17;\n    }\n    return this._randomString(charsCount, UNMISTAKABLE_CHARS);\n  }\n\n  secret(charsCount) {\n    // Default to 256 bits of entropy, or 43 characters at 6 bits per\n    // character.\n    if (charsCount === undefined) {\n      charsCount = 43;\n    }\n    return this._randomString(charsCount, BASE64_CHARS);\n  }\n\n  choice(arrayOrString) {\n    const index = Math.floor(this.fraction() * arrayOrString.length);\n    if (typeof arrayOrString === 'string') {\n      return arrayOrString.substr(index, 1);\n    } else {\n      return arrayOrString[index];\n    }\n  }\n\n  static default() {\n    if (!_defaultRandomGenerator) {\n      if (typeof window !== 'undefined') {\n        if (window.crypto && window.crypto.getRandomValues) {\n          return new Random(RANDOM_GENERATOR_TYPE.BROWSER_CRYPTO);\n        } else {\n          return new Random(\n            RANDOM_GENERATOR_TYPE.ALEA,\n            { seeds: _getBrowserSeeds() }\n          );\n        }\n      } else {\n        return new Random(RANDOM_GENERATOR_TYPE.NODE_CRYPTO);\n      }\n    }\n    return _defaultRandomGenerator;\n  }\n\n  static createWithSeeds() {\n    invariant(\n      arguments.length,\n      'Random.createWithSeeds(...): no seeds were provided'\n    );\n\n    return new Random(\n      RANDOM_GENERATOR_TYPE.ALEA,\n      { seeds: arguments }\n    );\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/ShortIdGenerator.js":"import Random from './Random';\n\n\n/**\n * Generates a random short obhect id for given collection\n * @param  {String} modelName\n * @return {String}\n */\nexport default function(modelName) {\n  const nextSeed = Random.default().hexString(20);\n  const sequenceSeed = [nextSeed, `/collection/${modelName}`];\n  return {\n    value: Random.createWithSeeds.apply(null, sequenceSeed).id(17),\n    seed: nextSeed,\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/StorageManager.js":"import _keys from 'fast.js/object/keys';\nimport EventEmitter from 'eventemitter3';\nimport PromiseQueue from './PromiseQueue';\nimport EJSON from './EJSON';\n\n\n/**\n * Manager for dealing with backend storage\n * of the daatabase. Default implementation uses\n * memory. You can implement the same interface\n * and use another storage (with levelup, for example)\n */\nexport class StorageManager {\n  constructor(db, options = {}) {\n    this.db = db;\n    this.options = options;\n    this._queue = new PromiseQueue(1);\n    this._storage = {};\n    this.reload();\n  }\n\n  loaded() {\n    return this._loadedPromise;\n  }\n\n  reload() {\n    if (this._loadedPromise) {\n      this._loadedPromise = this._loadedPromise.then(() => {\n        return this._loadStorage();\n      });\n    } else {\n      this._loadedPromise = this._loadStorage();\n    }\n    return this.loaded();\n  }\n\n  destroy() {\n    return this.loaded().then(() => {\n      this._storage = {};\n    });\n  }\n\n  persist(key, value) {\n    return this.loaded().then(() => {\n      this._storage[key] = EJSON.clone(value);\n    });\n  }\n\n  delete(key) {\n    return this.loaded().then(() => {\n      delete this._storage[key];\n    });\n  }\n\n  get(key) {\n    return this.loaded().then(() => this._storage[key]);\n  }\n\n  createReadStream(options = {}) {\n    // Very limited subset of ReadableStream\n    let paused = false;\n    const emitter = new EventEmitter();\n    emitter.pause = () => paused = true;\n\n    this.loaded().then(() => {\n      const keys = _keys(this._storage);\n      for (let i = 0; i < keys.length; i++) {\n        emitter.emit('data', { value: this._storage[keys[i]] });\n        if (paused) {\n          return;\n        }\n      }\n      emitter.emit('end');\n    });\n\n    return emitter;\n  }\n\n  _loadStorage() {\n    this._storage = {};\n    return Promise.resolve();\n  }\n}\n\nexport default StorageManager;\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/gulp/tasks/clean.js":"'use strict';\n\nvar config = require('../config');\nvar gulp   = require('gulp');\nvar del    = require('del');\n\ngulp.task('clean', function(cb) {\n  del([config.dist, config.build]).then(function (paths) {\n    cb();\n  });\n});","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/gulp/tasks/default.js":"'use strict';\n\nvar gulp = require('gulp');\ngulp.task('default', ['dev']);","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/gulp/tasks/dev.js":"'use strict';\n\nvar gulp = require('gulp');\nvar runSequence = require('run-sequence');\n\ngulp.task('dev', ['clean'], function(cb) {\n  cb = cb || function() {};\n  global.isProd = true;\n  process.env.NODE_ENV = 'production';\n  runSequence('build', 'lint', 'watch', cb);\n});","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/gulp/tasks/lint.js":"'use strict';\n\nvar config = require('../config');\nvar gulp   = require('gulp');\nvar eslint = require('gulp-eslint');\n\ngulp.task('lint', function() {\n  return gulp.src([config.src])\n    .pipe(eslint())\n    .pipe(eslint.format())\n    //.pipe(eslint.failOnError());\n});","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/gulp/tasks/release.js":"'use strict';\n\nvar gulp = require('gulp');\nvar runSequence = require('run-sequence');\n\ngulp.task('release', ['clean'], function(cb) {\n  cb = cb || function() {};\n  global.isProd = true;\n  process.env.NODE_ENV = 'production';\n  runSequence('build', 'lint', cb);\n});","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/aggregate.js":"import invariant from 'invariant';\n\n\nexport const aggregate = {\n  method: function(aggrFn) {\n    invariant(\n      typeof aggrFn === 'function',\n      'aggregate(...): aggregator must be a function'\n    );\n\n    this._addPipeline('aggregate', aggrFn);\n    return this;\n  },\n\n  process: function(docs, pipeObj) {\n    return pipeObj.value(docs);\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/filter.js":"import invariant from 'invariant';\nimport _filter from 'fast.js/array/filter';\n\n\nexport const filter = {\n  method: function(filterFn) {\n    invariant(\n      typeof filterFn === 'function',\n      'filter(...): argument must be a function'\n    );\n\n    this._addPipeline('filter', filterFn);\n    return this;\n  },\n\n  process: function(docs, pipeObj) {\n    return _filter(docs, pipeObj.value);\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/ifNotEmpty.js":"import _check from 'check-types';\n\n\nexport const ifNotEmpty = {\n  method: function() {\n    this._addPipeline('ifNotEmpty');\n    return this;\n  },\n\n  process: function(docs) {\n    const isEmptyRes = (\n      !_check.assigned(docs) ||\n      (_check.array(docs) && _check.emptyArray(docs)) ||\n      (_check.object(docs) && _check.emptyObject(docs))\n    );\n    return isEmptyRes ? '___[STOP]___' : docs;\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/joinAll.js":"import _check from 'check-types';\nimport _map from 'fast.js/map';\nimport _bind from 'fast.js/function/bind';\nimport invariant from 'invariant';\n\n\nexport const joinAll = {\n  method: function(joinFn) {\n    invariant(\n      typeof joinFn === 'function',\n      'joinAll(...): argument must be a function'\n    );\n\n    this._addPipeline('joinAll', joinFn);\n    return this;\n  },\n\n  process: function(docs, pipeObj, cursor, i = 0, len = 1) {\n    const updatedFn = (cursor._propagateUpdate)\n      ? _bind(cursor._propagateUpdate, cursor)\n      : function() {};\n\n    let res = pipeObj.value(docs, updatedFn, i, len);\n    res = _check.array(res) ? res : [res];\n    res = _map(res, val => {\n      let cursorPromise;\n      if (val && val.joinAll) { // instanceof Cursor\n        cursorPromise = val.exec();\n      } else if (_check.object(val) && val.cursor && val.then) {\n        cursorPromise = val;\n      }\n      if (cursorPromise) {\n        cursor._trackChildCursorPromise(cursorPromise);\n      }\n      return cursorPromise || val;\n    });\n\n    return Promise.all(res).then(() => docs);\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/joinEach.js":"import _check from 'check-types';\nimport _map from 'fast.js/map';\nimport invariant from 'invariant';\nimport { joinAll } from './joinAll';\n\n\nexport const joinEach = {\n  method: function(joinFn) {\n    invariant(\n      typeof joinFn === 'function',\n      'joinEach(...): argument must be a function'\n    );\n\n    this._addPipeline('joinEach', joinFn);\n    return this;\n  },\n\n  process: function(docs, pipeObj, cursor) {\n    if (!docs) {\n      return Promise.resolve(docs);\n    } else {\n      docs = _check.array(docs) ? docs : [docs];\n      const docsLength = docs.length;\n      return Promise.all(_map(docs, (x, i) =>\n        joinAll.process(x, pipeObj, cursor, i, docsLength)\n      ));\n    }\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/join.js":"import _check from 'check-types';\nimport invariant from 'invariant';\nimport { joinObj } from './joinObj';\nimport { joinEach } from './joinEach';\nimport { joinAll } from './joinAll';\n\n\nexport const join = {\n  method: function(joinFn, options = {}) {\n    invariant(\n      typeof joinFn === 'function' || _check.object(joinFn),\n      'join(...): argument must be a function'\n    );\n\n    this._addPipeline('join', joinFn, options);\n    return this;\n  },\n\n  process: function(docs, pipeObj, cursor) {\n    if (_check.object(pipeObj.value)) {\n      return joinObj.process(docs, pipeObj, cursor);\n    } else if (_check.array(docs)) {\n      return joinEach.process(docs, pipeObj, cursor);\n    } else {\n      return joinAll.process(docs, pipeObj, cursor);\n    }\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/joinObj.js":"import _check from 'check-types';\nimport _each from 'fast.js/forEach';\nimport _map from 'fast.js/map';\nimport _filter from 'fast.js/array/filter';\nimport _reduce from 'fast.js/array/reduce';\nimport _keys from 'fast.js/object/keys';\nimport Collection from '../Collection';\nimport invariant from 'invariant';\nimport { joinAll } from './joinAll';\nimport { findModTarget } from '../DocumentModifier';\nimport { makeLookupFunction } from '../DocumentMatcher';\nimport { selectorIsId } from '../Document';\n\n\n/**\n * By given list of documents make mapping of joined\n * model ids to root document and vise versa.\n * @param  {Array}  docs\n * @param  {String} key\n * @return {Object}\n */\nfunction _decomposeDocuments(docs, key) {\n  const lookupFn = makeLookupFunction(key);\n  let allIds = [];\n\n  const docsWrapped = _map(docs, (d) => {\n    const val = lookupFn(d);\n    const joinIds = _filter(_reduce(_map(val, x => x.value), (a, b) => {\n      if (_check.array(b)) {\n        return [...a, ...b];\n      } else {\n        return [...a, b];\n      }\n    }, []), x => selectorIsId(x));\n\n    allIds = allIds.concat(joinIds);\n    return {\n      doc: d,\n      lookupResult: val,\n    };\n  });\n\n  return { allIds, docsWrapped };\n}\n\n\n/**\n * By given value of some key in join object return\n * an options object.\n * @param  {Object|Collection} joinValue\n * @return {Object}\n */\nfunction _getJoinOptions(key, value) {\n  if (value instanceof Collection) {\n    return { model: value, joinPath: key };\n  } else if (_check.object(value)) {\n    return {\n      model: value.model,\n      joinPath: value.joinPath || key,\n    };\n  } else {\n    throw new Error('Invalid join object value');\n  }\n}\n\n\n/**\n * By given result of joining objects restriving and root documents\n * decomposition set joining object on each root document\n * (if it is exists).\n * @param  {String} joinPath\n * @param  {Array}  res\n * @param  {Object} docsById\n * @param  {Object} childToRootMap\n */\nfunction _joinDocsWithResult(joinPath, res, docsWrapped) {\n  const resIdMap = {};\n  const initKeyparts = joinPath.split('.');\n\n  _each(res, v => resIdMap[v._id] = v);\n  _each(docsWrapped, wrap => {\n    _each(wrap.lookupResult, branch => {\n      if (branch.value) {\n        // `findModTarget` will modify `keyparts`. So, it should\n        // be copied each time.\n        const keyparts = initKeyparts.slice();\n        const target = findModTarget(wrap.doc, keyparts, {\n          noCreate: false,\n          forbidArray: false,\n          arrayIndices: branch.arrayIndices,\n        });\n        const field = keyparts[keyparts.length - 1];\n\n        if (_check.array(branch.value)) {\n          target[field] = _map(branch.value, id => resIdMap[id]);\n        } else {\n          target[field] = resIdMap[branch.value] || null;\n        }\n      }\n    });\n  });\n}\n\n\nexport const joinObj = {\n  method: function(obj, options = {}) {\n    invariant(\n      _check.object(obj),\n      'joinObj(...): argument must be an object'\n    );\n\n    this._addPipeline('joinObj', obj, options);\n    return this;\n  },\n\n  process: function(docs, pipeObj, cursor) {\n    if (!docs) {\n      return Promise.resolve(docs);\n    } else {\n      const obj = pipeObj.value;\n      const options = pipeObj.args[0] || {};\n      const isObj = !_check.array(docs);\n      docs = !isObj ? docs : [docs];\n\n      const joinerFn = (dcs) => _map(_keys(obj), k => {\n        const { model, joinPath } = _getJoinOptions(k, obj[k]);\n        const { allIds, docsWrapped } = _decomposeDocuments(docs, k);\n\n        const execFnName = options.observe ? 'observe' : 'then';\n        return model.find({_id: {$in: allIds}})[execFnName](res => {\n          _joinDocsWithResult(joinPath, res, docsWrapped);\n        });\n      });\n\n      const newPipeObj = { ...pipeObj, value: joinerFn };\n      return joinAll\n        .process(docs, newPipeObj, cursor)\n        .then(res => isObj ? res[0] : res);\n    }\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/map.js":"import _map from 'fast.js/map';\nimport invariant from 'invariant';\n\n\nexport const map = {\n  method: function(mapperFn) {\n    invariant(\n      typeof mapperFn === 'function',\n      'map(...): mapper must be a function'\n    );\n\n    this._addPipeline('map', mapperFn);\n    return this;\n  },\n\n  process: function(docs, pipeObj) {\n    return _map(docs, pipeObj.value);\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/reduce.js":"import _reduce from 'fast.js/array/reduce';\nimport invariant from 'invariant';\n\n\nexport const reduce = {\n  method: function(reduceFn, initial) {\n    invariant(\n      typeof reduceFn === 'function',\n      'reduce(...): reducer argument must be a function'\n    );\n\n    this._addPipeline('reduce', reduceFn, initial);\n    return this;\n  },\n\n  process: function(docs, pipeObj) {\n    return _reduce(docs, pipeObj.value, pipeObj.args[0]);\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-marsdb/node_modules/marsdb/lib/cursor-processors/sortFunc.js":"import invariant from 'invariant';\n\n\nexport const sortFunc = {\n  method: function(sortFn) {\n    invariant(\n      typeof sortFn === 'function',\n      'sortFunc(...): argument must be a function'\n    );\n\n    this._addPipeline('sortFunc', sortFn);\n    return this;\n  },\n\n  process: function(docs, pipeObj) {\n    return docs.sort(pipeObj.value);\n  },\n};\n"}